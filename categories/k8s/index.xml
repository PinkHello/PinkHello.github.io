<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>k8s on PinkHello</title><link>https://pinkhello.me/categories/k8s/</link><description>Recent content in k8s on PinkHello</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>PinkHello, All Rights Reserved</copyright><lastBuildDate>Sun, 21 Mar 2021 17:17:13 +0800</lastBuildDate><atom:link href="https://pinkhello.me/categories/k8s/index.xml" rel="self" type="application/rss+xml"/><item><title>22 回望K8S 持久化存储</title><link>https://pinkhello.me/posts/22-%E5%9B%9E%E6%9C%9Bk8s-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/</link><pubDate>Sun, 21 Mar 2021 17:17:13 +0800</pubDate><guid>https://pinkhello.me/posts/22-%E5%9B%9E%E6%9C%9Bk8s-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/</guid><description>PV、PVC、StorageClass 说的啥？ PV: 持久化存储数据卷，这个 API 主要定义的是一个持久化存储在宿主机上的一个目录。一般由运维人员进行定义，比如定义一个 NFS 类型的 PV
apiVersion:v1kind:PersistentVolumemetadata:name:nfsspec:storageClassName:manualcapacity:storage:1GiaccessModes:- ReadWriteManynfs:server:10.244.1.5path:&amp;#34;/&amp;#34;PVC: POD 所希望使用的持久化存储的属性. 比如 Volume 的存储大小、可读写权限等. PVC 一般由开发人员创建、或者由 PVC模板的方式成为StatefulSet的一部分，由StatefulSet控制器负责创建带编号的PVC.
# 创建一个 1 GB 大小的PVC---apiVersion:v1kind:PersistentVolumeClaimmetadata:name:nfsspec:accessModes:- ReadWriteManystorageClassName:manualresources:requests:storage:1Gi...用户创建的PVC要真正的被容器使用的化，需要于心和某个符合条件的PV进行绑定：
第一个条件，PV 和 PVC 的 spec 字段。例如: PV 的存储(storage)大小就必须满足 PVC 的要求 第二个条件，PV 和 PVC 的 storageClassName 字段名称必须一样。 下面是去使用这个PVC
apiVersion:v1kind:Podmetadata:labels:role:web-frontendspec:containers:- name:webimage:nginxports:- name:webcontainerPort:80volumeMounts:- name:nfsmountPath:&amp;#34;/usr/share/nginx/html&amp;#34;volumes:- name:nfspersistentVolumeClaim:claimName:nfsPVC 理解为持久化存储的 接口，它提供了对某种持久化存储的描述，但不提供具体的实现，而这个持久化的实现部分由 PV 完成。
假设，我们在创建 POD 的时候，系统内并没有合适的 PV 跟它定义的 PVC 绑定，这个时候容器想要使用的 Volume 不存在，怎么办呢？
在 Kubernetes 内，时机存在一个专门处理持久化存储的控制器，叫做 VolumeController。这个VolumeController维护着多个控制循环, 其中有个循环就是用来撮合 PV 和 PVC 进行绑定的角色，名字叫 PersistentVolumeController.</description></item><item><title>20 回望K8S 容器编排与Kubernetes作业管理</title><link>https://pinkhello.me/posts/20-%E5%9B%9E%E6%9C%9Bk8s-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8Ekubernetes%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/</link><pubDate>Tue, 16 Feb 2021 22:48:35 +0800</pubDate><guid>https://pinkhello.me/posts/20-%E5%9B%9E%E6%9C%9Bk8s-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8Ekubernetes%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/</guid><description>Pod pod 是 Kubernetes 项目的最小的 API 对象，原子调度单位.
假设 &amp;ldquo;容器的本质是进程&amp;rdquo;，容器镜像就是 exe 安装包, kubernetes 是操作系统
Pod 最重要的一个事实是一个逻辑概念。它对于 Kubernetes 最核心的意义是 容器设计模式。Kubernetes 真正处理的还是宿主机上操作系统上的 Linux 容器的 Namespace 和 Cgroups，而不是一个所谓的 Pod 边界和隔离环境。
Pod 其实是一组共享了某些资源的容器。Pod 里面所有的容器，共享的同一个 Network Namespace，并且可以声明共享同一个 Volume.
Kubernetes 项目内部，Pod 实现需要使用一个中间容器，这个容器叫做 Infra 容器，在 Pod 中，Infra 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起。
sidecar 典型的例子：WAR 包和 Web 服务器 POD后，将 WAR 包和 Tomcat 分别做成镜像，可以把他们容器结合在一起
---apiVersion:v1kind:Podmetadata:name:javaweb-2spec:# 启动后做了一件事 把应用的WAR包拷贝到 /app目录中，后退出initContainers:- image:sample-war:v2name:warcommand:[&amp;#34;cp&amp;#34;,&amp;#34;/sample.war&amp;#34;,&amp;#34;/app&amp;#34;]volumeMounts:- mountPath:/appname:app-volumecontainers:- image:tomcat:7.0name:tomcatcommand:[&amp;#34;sh&amp;#34;,&amp;#34;-c&amp;#34;,&amp;#34;/root/apache-tomcat-7.0.42-v2/bin/start.sh&amp;#34;]volumeMounts:- mountPath:/root/apache-tomcat-7.0.42-v2/webappsname:app-volumeports:- containerPort:8080hostPort:8001volumes:- name:app-volumeemptyDir:{}...这个POD中，定义了两个容器，第一个容器镜像 sample-war:v2，第二个容器镜像是 Tomcat 镜像，War包容器的类型不是一个普通容器，是一个 Init Container 类型的容器。</description></item><item><title>19 回望K8S Kubernetes拼图</title><link>https://pinkhello.me/posts/19-%E5%9B%9E%E6%9C%9Bk8s-kubernetes%E6%8B%BC%E5%9B%BE/</link><pubDate>Tue, 16 Feb 2021 20:57:38 +0800</pubDate><guid>https://pinkhello.me/posts/19-%E5%9B%9E%E6%9C%9Bk8s-kubernetes%E6%8B%BC%E5%9B%BE/</guid><description>kubernetes 安装 all 节点安装 Docker 和 Kubeadm 所有节点 root 用户下操作
&amp;gt; curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add - &amp;gt; cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/apt/sources.list.d/kubernetes.list deb http://apt.kubernetes.io/ kubernetes-xenial main EOF &amp;gt; apt-get update # 这一步安装的时候 kubeadm 和 kubelet、kubectl、kubernetes-cni 都会自动安装完毕 &amp;gt; apt-get install -y docker.io kubeadm 提示：如果 apt.kubernetes.io 因为网络问题访问不到，可以换成中科大的 Ubuntu 镜像源 deb http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial main。
部署 Kubernetes Master 声明一个 kubeadm.yaml
---apiVersion:kubeadm.k8s.io/v1alpha1kind:MasterConfigurationcontrollerManagerExtraArgs:# 配置了自定义自动水平扩展horizontal-pod-autoscaler-use-rest-clients:&amp;#34;true&amp;#34;horizontal-pod-autoscaler-sync-period:&amp;#34;10s&amp;#34;node-monitor-grace-period:&amp;#34;10s&amp;#34;apiServerExtraArgs:runtime-config:&amp;#34;api/all=true&amp;#34;# kubeadm 部署的 kubernetes 的版本kubernetesVersion:&amp;#34;stable-1.11&amp;#34;···执行下面的指令，完成 kubernetes master 部署，这回生成一行指令
&amp;gt; kubeadm init --config kubeadm.</description></item><item><title>18 回望K8S 白话容器</title><link>https://pinkhello.me/posts/18-%E5%9B%9E%E6%9C%9Bk8s-%E7%99%BD%E8%AF%9D%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 15 Feb 2021 10:16:34 +0800</pubDate><guid>https://pinkhello.me/posts/18-%E5%9B%9E%E6%9C%9Bk8s-%E7%99%BD%E8%AF%9D%E5%AE%B9%E5%99%A8/</guid><description>进程开启 容器, 到底是什么? 前面提出: 容器是一种沙盒技术. 就是一个集装箱, 把应用装起来的技术. 这样, 应用与应用之间有了边界不至于互相干扰; 有了这些集装箱, 也方便搬来搬去.
码农都知道可执行的二进制文件是代码的可执行镜像(executable image). 一旦程序执行起来, 内存数据、寄存器的值、堆栈的指令、打开的文件等这些集合汇集成一个程序的计算机执行环境总和: 进程.
进程: 静态表现是程序, 动态表现计算机的数据和状态的总和。
容器的核心功能, 就是通过约束和修改进程的动态表现, 从而为其创造一个&amp;quot;边界&amp;quot;.
Cgroups 技术 制造约束的主要手段 Namespace 技术 修改进程视图的主要方法 docker run , -it 告诉 Docker 启动容器后, 需要分配一个文本输入/输出环境, 也就是 TTY, 跟容器的标准输入相关联, 这样我们就可以和这个Docker容器进行交互了。而 /bin/sh 就是我们在 Docker 容器里运行的程序.
&amp;gt; docker run -it busybox /bin/sh / # 帮我启动一个容器, 在容器里执行 /bin/sh, 并且给我分配一个命令行终端跟这个容器进行交互, 在这个执行环境下可以完全执行LINUX命令,且与宿主机完全隔离在不同的世界中.
Docker对被隔离应用的进程空间做了手脚, 使得这些进程只能看到重新计算的进程编号, 可是实际上, 他们在宿主机的操作系统里, 还是原来的第N号进程. 这种技术就是Linux内部的Namespace机制。
Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 clone()，比如：</description></item><item><title>17 回望K8S 小鲸鱼容器技术</title><link>https://pinkhello.me/posts/17-%E5%9B%9E%E6%9C%9Bk8s-%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/</link><pubDate>Thu, 11 Feb 2021 10:50:42 +0800</pubDate><guid>https://pinkhello.me/posts/17-%E5%9B%9E%E6%9C%9Bk8s-%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/</guid><description>什么是容器 在容器之前, 火爆云计算市场的是 PAAS, PAAS已经深入人心. 那时候突然有一家公司 dotCloud 剑走偏锋, 直接开源出了 Docker 项目，并且直接面向的社区。 这样的做法直接将当时的PAAS流主要公司打的屁滚尿流。
回头看, PAAS 最核心的是隔离环境,或者叫 沙盒,在我看来也就是 容器. 而 Docker 项目和 Cloud Foundry 的容器没有太大的不同,但是它为什么能针对 PAAS进行了一场快速的闪电战呢？
对的, 就是 Docker 镜像, 这个小小的创新, 迅速改变了云计算的发展轨迹! Docker 镜像解决的是 打包 问题。也许有人说Docker 镜像就是一个压缩包。但是就是这个压缩包包含了完整的操作系统文件和目录, 包含了整个应用所需要的依赖，一包在手, 你可以轻易的运行你的沙盒,并且本地环境与云端环境高度一致（这是最宝贵的）。
Docker给PAAS进行了致命打击, 提供了便利的打包机制, 面向后端开发者来说, 屏蔽了机器、内核等技术细节, 避免了在不同环境间的差异引入的试错成本。是一次解放生产力的革命。当然很多开发者用脚投票, 了结了PAAS时代。
Docker 三大利器 Docker项目的高调开源, 解决了打包和发布困扰运维的技术难题，同时它也第一次纯后端的概念通过友好的设计和封装交付到了开发者的手里。 Swarm,Docker是创建和启停容器的工具,那么Swarm是为了向平台化发展而提出的。它提供了完整的整体对外提供集群管理功能,它的亮点是完全使用Docker原本的管理容器的API来完成集群管理 # Swarm多机环境下，指令会被Swarm拦截处理，后面通过调度算法找到合适的Docker Daemon运行 docker run -H &amp;#34;Swarm集群API&amp;#34; &amp;#34;我的容器&amp;#34; Compose(Fig)项目, 这是第一次在开发者面前提出 容器编排(Container Orchestration)概念。 应用容器 A, 数据库容器B, 负载均衡容器C, Compose 允许 A、B、C 三个容器定义在配置文件中, 并指定关联关系.</description></item></channel></rss>