<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>k8s on PinkHello</title><link>https://pinkhello.me/tags/k8s/</link><description>Recent content in k8s on PinkHello</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>PinkHello, All Rights Reserved</copyright><lastBuildDate>Sat, 15 Feb 2020 10:16:34 +0800</lastBuildDate><atom:link href="https://pinkhello.me/tags/k8s/index.xml" rel="self" type="application/rss+xml"/><item><title>回望K8S 白话容器</title><link>https://pinkhello.me/posts/18-%E5%9B%9E%E6%9C%9Bk8s-%E7%99%BD%E8%AF%9D%E5%AE%B9%E5%99%A8/</link><pubDate>Sat, 15 Feb 2020 10:16:34 +0800</pubDate><guid>https://pinkhello.me/posts/18-%E5%9B%9E%E6%9C%9Bk8s-%E7%99%BD%E8%AF%9D%E5%AE%B9%E5%99%A8/</guid><description>进程开启 容器, 到底是什么? 前面提出: 容器是一种沙盒技术. 就是一个集装箱, 把应用装起来的技术. 这样, 应用与应用之间有了边界不至于互相干扰; 有了这些集装箱, 也方便搬来搬去.
码农都知道可执行的二进制文件是代码的可执行镜像(executable image). 一旦程序执行起来, 内存数据、寄存器的值、堆栈的指令、打开的文件等这些集合汇集成一个程序的计算机执行环境总和: 进程.
进程: 静态表现是程序, 动态表现计算机的数据和状态的总和。
容器的核心功能, 就是通过约束和修改进程的动态表现, 从而为其创造一个&amp;quot;边界&amp;quot;.
Cgroups 技术 制造约束的主要手段 Namespace 技术 修改进程视图的主要方法 docker run , -it 告诉 Docker 启动容器后, 需要分配一个文本输入/输出环境, 也就是 TTY, 跟容器的标准输入相关联, 这样我们就可以和这个Docker容器进行交互了。而 /bin/sh 就是我们在 Docker 容器里运行的程序.
&amp;gt; docker run -it busybox /bin/sh / # 帮我启动一个容器, 在容器里执行 /bin/sh, 并且给我分配一个命令行终端跟这个容器进行交互, 在这个执行环境下可以完全执行LINUX命令,且与宿主机完全隔离在不同的世界中.
Docker对被隔离应用的进程空间做了手脚, 使得这些进程只能看到重新计算的进程编号, 可是实际上, 他们在宿主机的操作系统里, 还是原来的第N号进程. 这种技术就是Linux内部的Namespace机制。
Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 clone()，比如：</description></item><item><title>回望K8S 小鲸鱼容器技术</title><link>https://pinkhello.me/posts/17-%E5%9B%9E%E6%9C%9Bk8s-%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/</link><pubDate>Tue, 11 Feb 2020 10:50:42 +0800</pubDate><guid>https://pinkhello.me/posts/17-%E5%9B%9E%E6%9C%9Bk8s-%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/</guid><description>什么是容器 在容器之前, 火爆云计算市场的是 PAAS, PAAS已经深入人心. 那时候突然有一家公司 dotCloud 剑走偏锋, 直接开源出了 Docker 项目，并且直接面向的社区。 这样的做法直接将当时的PAAS流主要公司打的屁滚尿流。
回头看, PAAS 最核心的是隔离环境,或者叫 沙盒,在我看来也就是 容器. 而 Docker 项目和 Cloud Foundry 的容器没有太大的不同,但是它为什么能针对 PAAS进行了一场快速的闪电战呢？
对的, 就是 Docker 镜像, 这个小小的创新, 迅速改变了云计算的发展轨迹! Docker 镜像解决的是 打包 问题。也许有人说Docker 镜像就是一个压缩包。但是就是这个压缩包包含了完整的操作系统文件和目录, 包含了整个应用所需要的依赖，一包在手, 你可以轻易的运行你的沙盒,并且本地环境与云端环境高度一致（这是最宝贵的）。
Docker给PAAS进行了致命打击, 提供了便利的打包机制, 面向后端开发者来说, 屏蔽了机器、内核等技术细节, 避免了在不同环境间的差异引入的试错成本。是一次解放生产力的革命。当然很多开发者用脚投票, 了结了PAAS时代。
Docker 三大利器 Docker项目的高调开源, 解决了打包和发布困扰运维的技术难题，同时它也第一次纯后端的概念通过友好的设计和封装交付到了开发者的手里。 Swarm,Docker是创建和启停容器的工具,那么Swarm是为了向平台化发展而提出的。它提供了完整的整体对外提供集群管理功能,它的亮点是完全使用Docker原本的管理容器的API来完成集群管理 # Swarm多机环境下，指令会被Swarm拦截处理，后面通过调度算法找到合适的Docker Daemon运行 docker run -H &amp;#34;Swarm集群API&amp;#34; &amp;#34;我的容器&amp;#34; Compose(Fig)项目, 这是第一次在开发者面前提出 容器编排(Container Orchestration)概念。 应用容器 A, 数据库容器B, 负载均衡容器C, Compose 允许 A、B、C 三个容器定义在配置文件中, 并指定关联关系.</description></item></channel></rss>