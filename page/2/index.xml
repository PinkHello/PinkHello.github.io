<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PinkHello</title><link>https://pinkhello.me/</link><description>Recent content on PinkHello</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>PinkHello, All Rights Reserved</copyright><lastBuildDate>Tue, 25 May 2021 19:00:00 +0800</lastBuildDate><atom:link href="https://pinkhello.me/index.xml" rel="self" type="application/rss+xml"/><item><title>06 高性能队列Disruptor</title><link>https://pinkhello.me/posts/06-%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97disruptor/</link><pubDate>Mon, 15 Mar 2021 08:35:29 +0800</pubDate><guid>https://pinkhello.me/posts/06-%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97disruptor/</guid><description>PinkHello https://pinkhello.me/posts/06-%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97disruptor/ -&lt;h1 id="背景">背景&lt;/h1>
&lt;p>&lt;code>Disruptor&lt;/code> 是 外汇交易公司&lt;code>LMAX&lt;/code>开发的高性能队列、研发是为了解决内存队列延迟问题。
&lt;code>Disruptor&lt;/code> 一般用于线程间的消息传递。
&lt;a href="http://lmax-exchange.github.io/disruptor/">Disruptor GitHub 地址&lt;/a>&lt;/p>
&lt;h1 id="disruptor-介绍">&lt;code>Disruptor&lt;/code> 介绍&lt;/h1>
&lt;p>理解 &lt;code>Disruptor&lt;/code> 最好的方式，选择一个最接近熟悉的样本进行比较。在这个前提下，可以选择 &lt;code>Java&lt;/code> 中的 &lt;code>BlockingQueue&lt;/code>.
和队列相似，&lt;code>Disruptor&lt;/code> 也是在同一个进程中不同的线程之间进行传递数据的（例如消息或者事件），同时 &lt;code>Disruptor&lt;/code> 提供了一些将关键功能和队列分开的特性：&lt;/p>
&lt;ul>
&lt;li>向消费者发送多播事件&lt;/li>
&lt;li>消息者依赖关系图&lt;/li>
&lt;li>预先为事件分配内存&lt;/li>
&lt;li>可选的（无锁）&lt;/li>
&lt;/ul>
&lt;h1 id="disruptor-核心概念">&lt;code>Disruptor&lt;/code> 核心概念&lt;/h1>
&lt;p>在我们理解&lt;code>Disruptor&lt;/code>如何工作之前，了解下核心概念&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/RingBuffer.java">Ring Buffer&lt;/a>
环形数组设计，为了避免垃圾回收，采用的数组结构，从3.0开始，环形缓冲区主要存储和更新在&lt;code>Disruptor&lt;/code>中移动的数据（事件）&lt;/li>
&lt;li>&lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/Sequence.java">Sequence&lt;/a>
&lt;code>Disruptor&lt;/code> 每个消费者(&lt;code>EventProcessor&lt;/code>)维护一个 &lt;code>Sequence&lt;/code>，并发的大多数代码都依赖 &lt;code>Sequence&lt;/code> 值的改动，所以 &lt;code>Sequence&lt;/code> 支持 &lt;code>AtomicLong&lt;/code> 的大部分也行, 唯一不同的是 &lt;code>Sequence&lt;/code> 包含额外的功能来阻止&lt;code>Sequence&lt;/code>和其他值之间的伪共享(&lt;code>false sharing&lt;/code>)&lt;/li>
&lt;li>&lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/Sequencer.java">Sequencer&lt;/a>&lt;br>
&lt;code>Disruptor&lt;/code> 核心逻辑, 两个实现: 单生产者和多生产者。他们实现了生产者与消费者之间的快速传递的并发算法。&lt;/li>
&lt;li>&lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/SequenceBarrier.java">Sequence Barrier&lt;/a>
由 &lt;code>Sequencer&lt;/code> 生成，包含此 &lt;code>Sequencer&lt;/code> 发布的 &lt;code>Sequence&lt;/code> 指针以及依赖的其他消费者的 &lt;code>Sequence&lt;/code>。包含了消费者检查是否有可用的事件的代码。&lt;/li>
&lt;li>&lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/WaitStrategy.java">Wait Strategy&lt;/a>
消费者等待事件的策略，这个事件由生产者放入，决定了消费者怎么等待生产者将事件放入 &lt;code>Disruptor&lt;/code>&lt;/li>
&lt;li>Event 生产者与消费者传递的事件，完全由用户定义&lt;/li>
&lt;li>&lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/EventProcessor.java">EventProcessor&lt;/a>
处理事件的主要循环（&lt;code>main event loop&lt;/code>），包含了一个 &lt;code>Sequeuece&lt;/code>. 有一个具体的实现类 &lt;code>BatchEventProcessor&lt;/code>&lt;/li>
&lt;li>&lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/EventHandler.java">EventHandler&lt;/a>
用户实现的接口，代表一个消费者。处理事件。&lt;/li>
&lt;li>Producer 生产者、先获得占位，然后提交事件。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://pinkhello.me/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97-Disruptor/Disruptor%E8%AE%BE%E8%AE%A1%E7%BB%84%E4%BB%B6%E5%9B%BE.jpg" alt="Disruptor设计组件图">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>事件广播(&lt;code>Multicast Events&lt;/code>)&lt;/p>
&lt;p>事件广播是 &lt;code>Disruptor&lt;/code> 与 &lt;code>Queue&lt;/code> 最大的区别，当你有多个消费者监听一个 &lt;code>Disruptor&lt;/code>, 所有的事件将会发布到这个所有的消费者。
&lt;code>Disruptor&lt;/code> 这一特性被用来需要对同一数据进行多个并行操作的情况。
如在LMAX系统中有三个操作可以同时进行：日志（将数据持久到日志文件中），复制（将数据发送到其他的机器上，以确保存在数据远程副本），业务逻辑处理。
也可以使用&lt;code>WokrerPool&lt;/code>来并行处理不同的事件。&lt;/p>
&lt;p>如上图。可以看到有3个事件处理程序正在侦听&lt;code>Disrupto&lt;/code>r（&lt;code>JournalConsumer&lt;/code>，&lt;code>ReplicationConsumer&lt;/code> 和 &lt;code>ApplicationConsumer&lt;/code>），
这些事件处理程序中的每个将接收&lt;code>Disruptor&lt;/code>中所有可用的消息（按相同顺序）。这允许这些消费者中的每一个并行工作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>消费者依赖关系图(&lt;code>Consumer Dependency Graph&lt;/code>)&lt;/p>
&lt;p>为了支持实现业务并行处理流程，&lt;code>Disruptor&lt;/code> 提供了多个消费者之间的协作功能。回到上面的例子中，我们可以将 &lt;code>journalling&lt;/code> 和 &lt;code>replication&lt;/code> 消费完成他们的业务，后再继续执行业务逻辑流程。
我们称呼这个功能为 &lt;code>gating&lt;/code> , &lt;code>gating&lt;/code> 发生在两种场景下:&lt;/p>
&lt;ul>
&lt;li>确保 &lt;code>Producer&lt;/code> 不能运行超过 &lt;code>Consumer&lt;/code> ，可以通多调用 &lt;code>RingBuffer.addGatingConsumers()&lt;/code> 来增加相关的消费者来完成&lt;/li>
&lt;li>之前所说的场景，通过必须先完成的&lt;code>Consumer&lt;/code> 的 &lt;code>Sequence&lt;/code>的&lt;code>SequenceBarrier&lt;/code>来实现。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>事件预分配(&lt;code>Event Preallocation&lt;/code>)&lt;/p>
&lt;p>&lt;code>Disruptor&lt;/code> 的一个目标就是在低延时环境下，减少或异常内存的占用。（在JAVA环境下，需要较少GC停顿的次数）（C/C++环境下，大量的内存分配也是一个问题）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可选择的无锁(&lt;code>Optionally Lock-free&lt;/code>)&lt;/p>
&lt;p>无锁的 &lt;code>Disruptor&lt;/code> 的低延迟的无锁的特性实现细节是都是基于 内存屏障 和 CAS 操作实现的，只有一个场景 &lt;code>BlockingWaitStrategy&lt;/code> 中使用的 &lt;code>Lock&lt;/code>
是为了使用 &lt;code>Lock&lt;/code> 里面的 &lt;code>Condition&lt;/code>, 方便消费者线程被 &lt;code>Park&lt;/code> 时候等待新的事件来触发。许多低延迟系统使用自旋（&lt;code>busy-wait&lt;/code>）来避免使用 &lt;code>Condition&lt;/code>造成的抖动
然而，太多的 &lt;code>busy-wait&lt;/code> 会导致性能下降，特别在CPU资源受限的情况下。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="disruptor-几个核心的设计">&lt;code>Disruptor&lt;/code> 几个核心的设计&lt;/h1>
&lt;h2 id="sequence-设计">&lt;code>Sequence&lt;/code> 设计&lt;/h2>
&lt;p>&lt;img src="https://pinkhello.me/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97-Disruptor/Sequence.jpg" alt="Sequence 设计">&lt;/p>
&lt;p>Sequence 真正计数是 &lt;code>value&lt;/code> 采用缓冲行防止 &lt;code>false sharing&lt;/code>。在&lt;code>value&lt;/code>的前后有7个 &lt;code>long&lt;/code> 型的填充值，做&lt;code>CPU cache line&lt;/code>填充防止伪共享。&lt;/p>
&lt;h2 id="ringbuffer-设计">&lt;code>RingBuffer&lt;/code> 设计&lt;/h2>
&lt;p>&lt;img src="https://pinkhello.me/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97-Disruptor/RingBuffer.jpg" alt="RingBuffer 设计">&lt;/p>
&lt;p>&lt;code>RingBuffer&lt;/code> 是一个环（首尾相接），可以用作不同的上下文（线程）间传递数据的 &lt;code>Buffer&lt;/code>环形设计，每个元素都有个坐标，取得元素通过取mod操作。
是数组设计、非链表。&lt;/p>
&lt;p>一般是&lt;code>2^N&lt;/code>次方，这样 sequence &amp;amp; (array length - 1 ) = array index。哈希Map也是这种位运算做的。&lt;/p>
&lt;p>&lt;code>RingBuffer&lt;/code> 特点&lt;/p>
&lt;ul>
&lt;li>数组实现、快速访问&lt;/li>
&lt;li>元素是覆盖式的，不主动清除&lt;/li>
&lt;li>神奇的缓存行（缓存是由缓存行组成的，通常64个字节、一个JAVA long 类型 8 字节）&lt;/li>
&lt;/ul>
&lt;h2 id="消费者依赖设计">消费者依赖设计&lt;/h2>
&lt;h2 id="缓存内存加载过程">缓存内存加载过程&lt;/h2>
&lt;p>&lt;img src="https://pinkhello.me/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97-Disruptor/cache-line-1.jpg" alt="缓存加载过程">
&lt;img src="https://pinkhello.me/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97-Disruptor/cache-line-2.jpg" alt="缓存加载过程">
&lt;img src="https://pinkhello.me/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97-Disruptor/cache-line-3.jpg" alt="缓存加载过程">&lt;/p>
&lt;p>&lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/RingBuffer.java">神奇的解决方式&amp;mdash;&amp;ndash; 缓存行填充&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#00688b;font-weight:bold">long&lt;/span> p1, p2, p3, p4, p5, p6, p7; &lt;span style="color:#228b22">// cache line padding
&lt;/span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">private&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">volatile&lt;/span> &lt;span style="color:#00688b;font-weight:bold">long&lt;/span> cursor = INITIAL_CURSOR_VALUE;
&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#00688b;font-weight:bold">long&lt;/span> p8, p9, p10, p11, p12, p13, p14; &lt;span style="color:#228b22">// cache line padding
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="disruptor-使用demo">&lt;code>Disruptor&lt;/code> 使用Demo&lt;/h1>
&lt;p>&lt;code>TransactionOrder&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">class&lt;/span> &lt;span style="color:#008b45;font-weight:bold">TransactionOrder&lt;/span> {
&lt;span style="color:#8b008b;font-weight:bold">private&lt;/span> String id;
&lt;span style="color:#8b008b;font-weight:bold">private&lt;/span> &lt;span style="color:#00688b;font-weight:bold">double&lt;/span> price;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>TransactionHandler&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">class&lt;/span> &lt;span style="color:#008b45;font-weight:bold">TransactionHandler&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">implements&lt;/span> EventHandler&amp;lt;TransactionOrder&amp;gt;, WorkHandler&amp;lt;TransactionOrder&amp;gt; {
&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#00688b;font-weight:bold">void&lt;/span> &lt;span style="color:#008b45">onEvent&lt;/span>(TransactionOrder transactionOrder, &lt;span style="color:#00688b;font-weight:bold">long&lt;/span> sequence, &lt;span style="color:#00688b;font-weight:bold">boolean&lt;/span> endOfBatch) &lt;span style="color:#8b008b;font-weight:bold">throws&lt;/span> Exception {
&lt;span style="color:#8b008b;font-weight:bold">this&lt;/span>.&lt;span style="color:#658b00">onEvent&lt;/span>(transactionOrder);
}
&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#00688b;font-weight:bold">void&lt;/span> &lt;span style="color:#008b45">onEvent&lt;/span>(TransactionOrder transactionOrder) &lt;span style="color:#8b008b;font-weight:bold">throws&lt;/span> Exception {
&lt;span style="color:#228b22">//具体的消费逻辑
&lt;/span>&lt;span style="color:#228b22">&lt;/span> transactionOrder.&lt;span style="color:#658b00">setId&lt;/span>(UUID.&lt;span style="color:#658b00">randomUUID&lt;/span>().&lt;span style="color:#658b00">toString&lt;/span>());
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Demo1&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">class&lt;/span> &lt;span style="color:#008b45;font-weight:bold">Demo1&lt;/span> {
&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">static&lt;/span> &lt;span style="color:#00688b;font-weight:bold">void&lt;/span> &lt;span style="color:#008b45">main&lt;/span>(String[] args) &lt;span style="color:#8b008b;font-weight:bold">throws&lt;/span> ExecutionException, InterruptedException {
&lt;span style="color:#00688b;font-weight:bold">int&lt;/span> BUFFER_SIZE = 1024;
&lt;span style="color:#00688b;font-weight:bold">int&lt;/span> THREAD_NUM = 4;
&lt;span style="color:#228b22">//createSingleProducer 创建单生产者的 RingBuffer
&lt;/span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">final&lt;/span> RingBuffer&amp;lt;TransactionOrder&amp;gt; ringBuffer =
RingBuffer.&lt;span style="color:#658b00">createSingleProducer&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> EventFactory&amp;lt;TransactionOrder&amp;gt;() {
&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> TransactionOrder &lt;span style="color:#008b45">newInstance&lt;/span>() {
&lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> TransactionOrder();
}
}, BUFFER_SIZE, &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> YieldingWaitStrategy());
&lt;span style="color:#228b22">//创建线程池
&lt;/span>&lt;span style="color:#228b22">&lt;/span> ExecutorService service = Executors.&lt;span style="color:#658b00">newFixedThreadPool&lt;/span>(THREAD_NUM);
&lt;span style="color:#228b22">//创建 SequenceBarrier
&lt;/span>&lt;span style="color:#228b22">&lt;/span> SequenceBarrier sequenceBarrier = ringBuffer.&lt;span style="color:#658b00">newBarrier&lt;/span>();
&lt;span style="color:#228b22">//创建消息处理器
&lt;/span>&lt;span style="color:#228b22">&lt;/span> BatchEventProcessor&amp;lt;TransactionOrder&amp;gt; eventProcessor =
&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> BatchEventProcessor&amp;lt;TransactionOrder&amp;gt;(ringBuffer, sequenceBarrier, &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> TransactionHandler());
&lt;span style="color:#228b22">//这一部分是让 RingBuffer根据消费者状态进行gating, 只有一个消费者的话可以省略
&lt;/span>&lt;span style="color:#228b22">&lt;/span> ringBuffer.&lt;span style="color:#658b00">addGatingSequences&lt;/span>(eventProcessor.&lt;span style="color:#658b00">getSequence&lt;/span>());
&lt;span style="color:#228b22">//把消息处理器提交到线程池
&lt;/span>&lt;span style="color:#228b22">&lt;/span> service.&lt;span style="color:#658b00">submit&lt;/span>(eventProcessor);
Future&amp;lt;?&amp;gt; future = service.&lt;span style="color:#658b00">submit&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> Callable&amp;lt;Void&amp;gt;() {
&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> Void &lt;span style="color:#008b45">call&lt;/span>() &lt;span style="color:#8b008b;font-weight:bold">throws&lt;/span> Exception {
&lt;span style="color:#00688b;font-weight:bold">long&lt;/span> seq;
&lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> (&lt;span style="color:#00688b;font-weight:bold">int&lt;/span> i = 0; i&amp;lt;10000; i++) {
seq = ringBuffer.&lt;span style="color:#658b00">next&lt;/span>(); &lt;span style="color:#228b22">//ringbuffer 的一个可用区块
&lt;/span>&lt;span style="color:#228b22">&lt;/span> ringBuffer.&lt;span style="color:#658b00">get&lt;/span>(seq).&lt;span style="color:#658b00">setPrice&lt;/span>(Math.&lt;span style="color:#658b00">random&lt;/span>() *9999); &lt;span style="color:#228b22">// 给这个区块放入数据
&lt;/span>&lt;span style="color:#228b22">&lt;/span> ringBuffer.&lt;span style="color:#658b00">publish&lt;/span>(seq); &lt;span style="color:#228b22">//发布数据使得 consumer 可以获取该数据
&lt;/span>&lt;span style="color:#228b22">&lt;/span> }
&lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">null&lt;/span>;
}
});
future.&lt;span style="color:#658b00">get&lt;/span>(); &lt;span style="color:#228b22">//等待生产者结束
&lt;/span>&lt;span style="color:#228b22">&lt;/span>
eventProcessor.&lt;span style="color:#658b00">halt&lt;/span>(); &lt;span style="color:#228b22">//通知事件
&lt;/span>&lt;span style="color:#228b22">&lt;/span>
service.&lt;span style="color:#658b00">shutdown&lt;/span>(); &lt;span style="color:#228b22">//终止线程
&lt;/span>&lt;span style="color:#228b22">&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Demo2&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">class&lt;/span> &lt;span style="color:#008b45;font-weight:bold">Demo2&lt;/span> {
&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">static&lt;/span> &lt;span style="color:#00688b;font-weight:bold">void&lt;/span> &lt;span style="color:#008b45">main&lt;/span>(String[] args) {
&lt;span style="color:#00688b;font-weight:bold">int&lt;/span> BUFFER_SIZE = 1024;
&lt;span style="color:#00688b;font-weight:bold">int&lt;/span> THREAD_NUM = 4;
EventFactory&amp;lt;TransactionOrder&amp;gt; eventFactory = &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> EventFactory&amp;lt;TransactionOrder&amp;gt;() {
&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> TransactionOrder &lt;span style="color:#008b45">newInstance&lt;/span>() {
&lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> TransactionOrder();
}
};
RingBuffer&amp;lt;TransactionOrder&amp;gt; ringBuffer = RingBuffer.&lt;span style="color:#658b00">createSingleProducer&lt;/span>(eventFactory, BUFFER_SIZE);
SequenceBarrier sequenceBarrier = ringBuffer.&lt;span style="color:#658b00">newBarrier&lt;/span>();
ExecutorService service = Executors.&lt;span style="color:#658b00">newFixedThreadPool&lt;/span>(THREAD_NUM);
WorkHandler&amp;lt;TransactionOrder&amp;gt; workHandler = &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> TransactionHandler();
WorkerPool&amp;lt;TransactionOrder&amp;gt; workerPool =
&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> WorkerPool&amp;lt;TransactionOrder&amp;gt;(ringBuffer, sequenceBarrier, &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> IgnoreExceptionHandler(),
workHandler);
&lt;span style="color:#228b22">//序列协调者
&lt;/span>&lt;span style="color:#228b22">&lt;/span> ringBuffer.&lt;span style="color:#658b00">addGatingSequences&lt;/span>(workerPool.&lt;span style="color:#658b00">getWorkerSequences&lt;/span>());
workerPool.&lt;span style="color:#658b00">start&lt;/span>(service);
&lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> (&lt;span style="color:#00688b;font-weight:bold">int&lt;/span> i=0; i&amp;lt;8; i++) {
&lt;span style="color:#00688b;font-weight:bold">long&lt;/span> seq = ringBuffer.&lt;span style="color:#658b00">next&lt;/span>();
ringBuffer.&lt;span style="color:#658b00">get&lt;/span>(seq).&lt;span style="color:#658b00">setPrice&lt;/span>(Math.&lt;span style="color:#658b00">random&lt;/span>() * 9999);
ringBuffer.&lt;span style="color:#658b00">publish&lt;/span>(seq);
}
workerPool.&lt;span style="color:#658b00">halt&lt;/span>();
service.&lt;span style="color:#658b00">shutdown&lt;/span>();
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Demo3&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">class&lt;/span> &lt;span style="color:#008b45;font-weight:bold">Demo3&lt;/span> {
&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">static&lt;/span> &lt;span style="color:#00688b;font-weight:bold">void&lt;/span> &lt;span style="color:#008b45">main&lt;/span>(String[] args) &lt;span style="color:#8b008b;font-weight:bold">throws&lt;/span> InterruptedException {
&lt;span style="color:#00688b;font-weight:bold">long&lt;/span> start = System.&lt;span style="color:#658b00">currentTimeMillis&lt;/span>();
&lt;span style="color:#00688b;font-weight:bold">int&lt;/span> BUFFER_SIZE = 1024;
&lt;span style="color:#00688b;font-weight:bold">int&lt;/span> THREAD_NUM = 4;
ExecutorService service = Executors.&lt;span style="color:#658b00">newFixedThreadPool&lt;/span>(THREAD_NUM);
Disruptor&amp;lt;TransactionOrder&amp;gt; disruptor = &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> Disruptor&amp;lt;TransactionOrder&amp;gt;(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> EventFactory&amp;lt;TransactionOrder&amp;gt;() {
&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> TransactionOrder &lt;span style="color:#008b45">newInstance&lt;/span>() {
&lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> TransactionOrder();
}
}, BUFFER_SIZE, service, ProducerType.&lt;span style="color:#658b00">SINGLE&lt;/span>, &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> BusySpinWaitStrategy());
&lt;span style="color:#228b22">/**
&lt;/span>&lt;span style="color:#228b22"> * 菱形操作
&lt;/span>&lt;span style="color:#228b22"> */&lt;/span>
&lt;span style="color:#228b22">//使用 disruptor 创建消费组 C1 与 C2
&lt;/span>&lt;span style="color:#228b22">&lt;/span> EventHandlerGroup&amp;lt;TransactionOrder&amp;gt; eventHandlerGroup =
disruptor.&lt;span style="color:#658b00">handleEventsWith&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> TransactionHandler(), &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> TransactionVasConsumer());
&lt;span style="color:#228b22">//C3
&lt;/span>&lt;span style="color:#228b22">&lt;/span> TransactionJmsNotifyHandler jmsNotifyHandler = &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> TransactionJmsNotifyHandler();
&lt;span style="color:#228b22">//声明在 C1 和 C2 完事后 执行 JMS消息发送操作（C3）
&lt;/span>&lt;span style="color:#228b22">&lt;/span> eventHandlerGroup.&lt;span style="color:#658b00">then&lt;/span>(jmsNotifyHandler);
&lt;span style="color:#228b22">/**
&lt;/span>&lt;span style="color:#228b22"> * 顺序执行
&lt;/span>&lt;span style="color:#228b22"> */&lt;/span>
&lt;span style="color:#228b22">// disruptor.handleEventsWith(new TransactionHandler())
&lt;/span>&lt;span style="color:#228b22">// .then(new TransactionVasConsumer())
&lt;/span>&lt;span style="color:#228b22">// .then(new TransactionJmsNotifyHandler());
&lt;/span>&lt;span style="color:#228b22">&lt;/span> &lt;span style="color:#228b22">/**
&lt;/span>&lt;span style="color:#228b22"> * 六边形操作
&lt;/span>&lt;span style="color:#228b22"> */&lt;/span>
&lt;span style="color:#228b22">// TransactionHandler h1 = new TransactionHandler();
&lt;/span>&lt;span style="color:#228b22">// TransactionHandler h2 = new TransactionHandler();
&lt;/span>&lt;span style="color:#228b22">// TransactionHandler h3 = new TransactionHandler();
&lt;/span>&lt;span style="color:#228b22">// TransactionHandler h4 = new TransactionHandler();
&lt;/span>&lt;span style="color:#228b22">// TransactionHandler h5 = new TransactionHandler();
&lt;/span>&lt;span style="color:#228b22">// TransactionHandler h6 = new TransactionHandler();
&lt;/span>&lt;span style="color:#228b22">// disruptor.handleEventsWith(h1, h2);
&lt;/span>&lt;span style="color:#228b22">// disruptor.after(h1).handleEventsWith(h4);
&lt;/span>&lt;span style="color:#228b22">// disruptor.after(h2).handleEventsWith(h5);
&lt;/span>&lt;span style="color:#228b22">// disruptor.after(h4, h5).handleEventsWith(h3);
&lt;/span>&lt;span style="color:#228b22">&lt;/span>
&lt;span style="color:#228b22">//启动
&lt;/span>&lt;span style="color:#228b22">&lt;/span> disruptor.&lt;span style="color:#658b00">start&lt;/span>();
CountDownLatch latch = &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> CountDownLatch(1);
&lt;span style="color:#228b22">//生产者准备
&lt;/span>&lt;span style="color:#228b22">&lt;/span> service.&lt;span style="color:#658b00">submit&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> TransactionPubllisher(disruptor, latch));
latch.&lt;span style="color:#658b00">await&lt;/span>(); &lt;span style="color:#228b22">//等待生产者完事
&lt;/span>&lt;span style="color:#228b22">&lt;/span>
disruptor.&lt;span style="color:#658b00">shutdown&lt;/span>();
service.&lt;span style="color:#658b00">shutdown&lt;/span>();
System.&lt;span style="color:#658b00">out&lt;/span>.&lt;span style="color:#658b00">println&lt;/span>(&lt;span style="color:#cd5555">&amp;#34;总耗时:&amp;#34;&lt;/span>+ (System.&lt;span style="color:#658b00">currentTimeMillis&lt;/span>() - start));
}
}
&lt;/code>&lt;/pre>&lt;/div>- https://pinkhello.me/posts/06-%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97disruptor/ - PinkHello, All Rights Reserved</description></item><item><title>16 Hexo迁移Hugo</title><link>https://pinkhello.me/posts/16-hexo%E8%BF%81%E7%A7%BBhugo/</link><pubDate>Wed, 10 Feb 2021 19:36:33 +0800</pubDate><guid>https://pinkhello.me/posts/16-hexo%E8%BF%81%E7%A7%BBhugo/</guid><description>PinkHello https://pinkhello.me/posts/16-hexo%E8%BF%81%E7%A7%BBhugo/ -&lt;h1 id="为什么迁移-hugo">为什么迁移 &lt;code>Hugo&lt;/code>&lt;/h1>
&lt;ul>
&lt;li>&lt;code>Hugo&lt;/code> 使用比 &lt;code>Hexo&lt;/code> 简单, 只有单独的一个二进制文件&lt;/li>
&lt;li>苦于 &lt;code>Hexo&lt;/code> 的 &lt;code>NodeModule&lt;/code> 管理&lt;/li>
&lt;li>迁移成本更低, 结合 &lt;code>Github Action&lt;/code> 实现 &lt;code>Markdown&lt;/code> 文章发布, 自动更新至静态站&lt;/li>
&lt;li>规划：加入自定义域名以及做静态资源CDN做的加速&lt;/li>
&lt;/ul>
&lt;h1 id="前置工作">前置工作&lt;/h1>
&lt;p>1、 之前基本所有的博客都托管与 &lt;code>github&lt;/code>,这次也不例外, 复用 &lt;code>https://pinkhello.github.io&lt;/code>,创建两个项目&lt;/p>
&lt;ul>
&lt;li>pinkhello.github.io template 仓库&lt;/li>
&lt;li>pinkhello.github.io.source private 仓库&lt;/li>
&lt;/ul>
&lt;p>2、准备OpenSSH私钥和公钥&lt;/p>
&lt;ul>
&lt;li>pinkhello.github.io 仓库 添加 settings -&amp;gt; Deploy keys -&amp;gt; Add Deploy Key (将公钥添加进去、注意允许 Write)&lt;/li>
&lt;li>pinkhello.github.io.source 仓库 添加 settings -&amp;gt; Actions secrets -&amp;gt; New Repository Secret ( NAME : ACTION_DEPLOY_KEY, Value: 私钥 )&lt;/li>
&lt;/ul>
&lt;p>3、git clone pinkhello.github.io.source 仓库&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git clone git@github.com:PinkHello/pinkhello.github.io.source.git
&lt;span style="color:#658b00">cd&lt;/span> pinkhello.github.io.source
&lt;span style="color:#228b22"># 初始化站点【--force 强制初始化】&lt;/span>
hugo new site . --force
&lt;span style="color:#228b22"># content site &lt;/span>
&lt;span style="color:#228b22"># data json数据 or 其他&lt;/span>
&lt;span style="color:#228b22"># static 静态文件&lt;/span>
&lt;span style="color:#228b22"># themes 主题&lt;/span>
&lt;span style="color:#228b22"># 后面可以执行 hugo new posts/XXX.md 创建新的文章&lt;/span>
hugo new posts/XXX.md
&lt;span style="color:#228b22"># 具体参考 https://gohugo.io/getting-started/ 进行操作&lt;/span>
......
&lt;span style="color:#228b22"># 选择一个主题 https://themes.gohugo.io/ 可以选择&lt;/span>
git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke
&lt;span style="color:#228b22"># 后面的参照各个主题设置咯&lt;/span>
....
&lt;span style="color:#228b22"># 本地测试&lt;/span>
hugo serve
&lt;span style="color:#228b22"># 生成最小的静态文件, 会生成 public 文件&lt;/span>
hugo --minify
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="迁移-hexo-博客进入-hugo">迁移 &lt;code>hexo&lt;/code> 博客进入 &lt;code>hugo&lt;/code>&lt;/h1>
&lt;p>&amp;hellip;&amp;hellip;(可以手动、可以工具进行)&lt;/p>
&lt;h1 id="整合-github-action">整合 &lt;code>Github Action&lt;/code>&lt;/h1>
&lt;p>新建 &lt;code>Github Action&lt;/code> 描述文件 &lt;code>.github/workflows/deploy.yml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#228b22"># This is a basic workflow to help you get started with Actions&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Deploy on Main Branch&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#228b22"># Controls when the action will run. &lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">on&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># Triggers the workflow on push or pull request events but only for the main branch&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">push&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">branches&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>[&lt;span style="color:#bbb"> &lt;/span>main ]&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">pull_request&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">branches&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>[&lt;span style="color:#bbb"> &lt;/span>main ]&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#228b22"># schedule:&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#228b22"># - cron: &amp;#39;0 21 * * *&amp;#39; # 定时任务&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># Allows you to run this workflow manually from the Actions tab&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">workflow_dispatch&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#228b22"># A workflow run is made up of one or more jobs that can run sequentially or in parallel&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">jobs&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># This workflow contains a single job called &amp;#34;build&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">build&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># The type of runner that the job will run on&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">runs-on&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>ubuntu-latest&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># Steps represent a sequence of tasks that will be executed as part of the job&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">steps&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">uses&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>actions/checkout@v2&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Setup Hugo&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">uses&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>peaceiris/actions-hugo@v2&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># https://github.com/peaceiris/actions-hugo&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">with&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">hugo-version&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#39;latest&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">extended&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">true&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Build&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># 注意强制更新 git submodule 下载，否则生成的主题没有 html 文件哦&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">run&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>|&lt;span style="color:#cd5555">
&lt;/span>&lt;span style="color:#cd5555"> git submodule update --init --recursive
&lt;/span>&lt;span style="color:#cd5555"> hugo --minify --debug&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Deploy&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">uses&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>peaceiris/actions-gh-pages@v3&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># https://github.com/peaceiris/actions-gh-pages&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">with&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">deploy_key&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>${{ secrets.ACTION_DEPLOY_KEY }}&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># 这里的 ACTION_DEPLOY_KEY 则是上面设置 Private Key的变量名&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">external_repository&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>PinkHello/PinkHello.github.io&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># Pages 远程仓库 &lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">publish_dir&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>./public&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">keep_files&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">false&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># remove existing files&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">publish_branch&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>master &lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># deploying branch&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">commit_message&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>${{ github.event.head_commit.message }}&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>so 完美
&lt;img src="https://pinkhello.me/hexo%E8%BF%81%E7%A7%BB%E8%87%B3hugo/github_action_in_process_0.jpg" alt="迁移Hexo">
&lt;img src="https://pinkhello.me/hexo%E8%BF%81%E7%A7%BB%E8%87%B3hugo/github_action_in_process.jpg" alt="迁移Hexo">&lt;/p>
- https://pinkhello.me/posts/16-hexo%E8%BF%81%E7%A7%BBhugo/ - PinkHello, All Rights Reserved</description></item><item><title>15 记一次docker日志磁盘告警问题</title><link>https://pinkhello.me/posts/15-%E8%AE%B0%E4%B8%80%E6%AC%A1docker%E6%97%A5%E5%BF%97%E7%A3%81%E7%9B%98%E5%91%8A%E8%AD%A6%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 10 Feb 2021 10:05:29 +0800</pubDate><guid>https://pinkhello.me/posts/15-%E8%AE%B0%E4%B8%80%E6%AC%A1docker%E6%97%A5%E5%BF%97%E7%A3%81%E7%9B%98%E5%91%8A%E8%AD%A6%E9%97%AE%E9%A2%98/</guid><description>PinkHello https://pinkhello.me/posts/15-%E8%AE%B0%E4%B8%80%E6%AC%A1docker%E6%97%A5%E5%BF%97%E7%A3%81%E7%9B%98%E5%91%8A%E8%AD%A6%E9%97%AE%E9%A2%98/ -&lt;h1 id="前景">前景&lt;/h1>
&lt;p>今日，我正在开开心心的刷着JFX的Coding中，突然线上报警群中爆了个炸弹，EC2磁盘超过80%。&lt;/p>
&lt;p>&lt;img src="https://pinkhello.me/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/%E8%B5%84%E6%BA%90%E4%B8%8D%E8%B6%B3%E6%8A%A5%E8%AD%A6.png" alt="资源不足预警">&lt;/p>
&lt;h1 id="处理过程">处理过程&lt;/h1>
&lt;p>解决问题姿势就位：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>赶紧开机 ==》 ❤️中万匹🦙奔腾而过 ❤️中MMP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>默默的通过跳板机进入目标机器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不管三七二十一,执行查看磁盘占用大小，我的乖乖，占用确实超过了87%了，一下子暴涨的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#228b22"># 查看磁盘占用大小&lt;/span>
&amp;gt; sudo df -h
&lt;span style="color:#228b22"># 查看当前目录总量&lt;/span>
&amp;gt; sudo du -sh
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>开始定位具体哪个文件或者目录占用这么大,跑到根目录下。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#228b22"># 查看当前目录下一级子文件和子目录占用的磁盘容量&lt;/span>
&amp;gt; sudo du -lh --max-depth=&lt;span style="color:#b452cd">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>一开始猜想可能是docker容器的日志占用大，上面执行后，还真 TM 是&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">/var/lib/docker/containers 目录占用 42G
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>开始查看是哪个容器占用的这么大的空间&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#228b22"># 查看 containers 日志目录排序&lt;/span>
&amp;gt; sudo du -d1 -h /var/lib/docker/containers | sort -h
&lt;span style="color:#228b22"># 查看具体的哪个日志文件大&lt;/span>
&amp;gt; sudo find /var/lib/docker/containers -name *.log
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然这个配图是我清理之后的
&lt;img src="https://pinkhello.me/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/docker%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F.png" alt="docker容器文件排序">
&lt;img src="https://pinkhello.me/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/%E6%9F%A5%E6%89%BEdocker%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6.png" alt="查找docker容器日志文件">&lt;/p>
&lt;ul>
&lt;li>定位到最大的文件，一顿操作&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell"> &lt;span style="color:#228b22"># 清空比较大的日志文件&lt;/span>
&amp;gt; sudo sh -c &lt;span style="color:#cd5555">&amp;#34;cat /dev/null &amp;gt; &lt;/span>&lt;span style="color:#cd5555">${&lt;/span>&lt;span style="color:#00688b">log_file&lt;/span>&lt;span style="color:#cd5555">}&lt;/span>&lt;span style="color:#cd5555">&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://pinkhello.me/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/%E6%B8%85%E7%90%86docker%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97%E5%90%8E.png" alt="清理docker容器日志后">&lt;/p>
&lt;h1 id="思考">思考&lt;/h1>
&lt;ul>
&lt;li>上面的方式是一种方式解决【临时】
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell"> &lt;span style="color:#228b22"># 查看 docker 的 Logging Driver&lt;/span>
&amp;gt; docker info | grep &lt;span style="color:#cd5555">&amp;#39;Logging Driver&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如何彻底解决这个问题：&lt;/p>
&lt;ul>
&lt;li>写个&lt;code>shell脚本&lt;/code> 使用 &lt;code>crontab&lt;/code> 定期执行清理
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell"> &lt;span style="color:#228b22">#!/bin/sh&lt;/span>
&lt;span style="color:#658b00">echo&lt;/span> &lt;span style="color:#cd5555">&amp;#34;======== start clean docker containers logs ========&amp;#34;&lt;/span>
&lt;span style="color:#00688b">logs&lt;/span>=&lt;span style="color:#8b008b;font-weight:bold">$(&lt;/span>find /var/lib/docker/containers/ -name *-json.log&lt;span style="color:#8b008b;font-weight:bold">)&lt;/span>
&lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> log in &lt;span style="color:#00688b">$logs&lt;/span>
&lt;span style="color:#8b008b;font-weight:bold">do&lt;/span>
&lt;span style="color:#658b00">echo&lt;/span> &lt;span style="color:#cd5555">&amp;#34;clean logs : &lt;/span>&lt;span style="color:#00688b">$log&lt;/span>&lt;span style="color:#cd5555">&amp;#34;&lt;/span>
cat /dev/null &amp;gt; &lt;span style="color:#00688b">$log&lt;/span>
&lt;span style="color:#8b008b;font-weight:bold">done&lt;/span>
&lt;span style="color:#658b00">echo&lt;/span> &lt;span style="color:#cd5555">&amp;#34;======== end clean docker containers logs ========&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>假如是&lt;code>docker run&lt;/code>创建容器的,指定 &lt;code>--log-opt max-size=${MAX_SIZE}m --log-opt max-file=${NUMBER}&lt;/code>&lt;/li>
&lt;li>&lt;code>docker-compose&lt;/code> 方式更高&lt;code>docker-compose.yaml&lt;/code>文件
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">logging&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">driver&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;json-file&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">options&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">max-size&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;${MAX_SIZE}m&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">max-file&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>${NUMBER}&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;code>docker&lt;/code> 全局修改 &lt;code>/etc/docker/daemon.json&lt;/code>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json"> {
&lt;span style="color:#8b008b;font-weight:bold">&amp;#34;log-driver&amp;#34;&lt;/span>: &lt;span style="color:#cd5555">&amp;#34;json-file&amp;#34;&lt;/span>,
&lt;span style="color:#8b008b;font-weight:bold">&amp;#34;log-opts&amp;#34;&lt;/span>: {
&lt;span style="color:#8b008b;font-weight:bold">&amp;#34;max-size&amp;#34;&lt;/span>: &lt;span style="color:#cd5555">&amp;#34;${MAX_SIZE}m&amp;#34;&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell"> &amp;gt; systemctl daemon-reload
&amp;gt; systemctl restart docker
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为什么会瞬间💥式的增长 ???&lt;/li>
&lt;/ul>
- https://pinkhello.me/posts/15-%E8%AE%B0%E4%B8%80%E6%AC%A1docker%E6%97%A5%E5%BF%97%E7%A3%81%E7%9B%98%E5%91%8A%E8%AD%A6%E9%97%AE%E9%A2%98/ - PinkHello, All Rights Reserved</description></item><item><title>05 OAuth2.0 那点事</title><link>https://pinkhello.me/posts/05-oauth2.0%E9%82%A3%E7%82%B9%E4%BA%8B/</link><pubDate>Wed, 10 Feb 2021 08:32:02 +0800</pubDate><guid>https://pinkhello.me/posts/05-oauth2.0%E9%82%A3%E7%82%B9%E4%BA%8B/</guid><description>PinkHello https://pinkhello.me/posts/05-oauth2.0%E9%82%A3%E7%82%B9%E4%BA%8B/ -&lt;h2 id="oauth20-是什么">&lt;code>OAuth2.0&lt;/code> 是什么?&lt;/h2>
&lt;p>&lt;code>OAuth2.0&lt;/code> Framework RFC 6749 [https://tools.ietf.org/html/rfc6749]&lt;/p>
&lt;p>&lt;code>OAuth&lt;/code> 就是一种授权机制，它介于客户端与资源所有者的授权层，为了分离不同的角色。
在资源所有者同意并向客户端颁发令牌后，客户端携带令牌可以访问部分或全部资源。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->OAuth2.0&lt;!-- raw HTML omitted --> 是&lt;!-- raw HTML omitted -->OAuth&lt;!-- raw HTML omitted --> 协议的一个版本，为&lt;!-- raw HTML omitted -->2.0&lt;!-- raw HTML omitted -->版本。有意思的是 &lt;!-- raw HTML omitted -->2.0&lt;!-- raw HTML omitted --> 与 &lt;!-- raw HTML omitted -->1.0&lt;!-- raw HTML omitted --> 并不兼容。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h2 id="oauth20-授权方式">&lt;code>OAuth2.0&lt;/code> 授权方式&lt;/h2>
&lt;p>获取授权的过程&lt;/p>
&lt;ul>
&lt;li>授权码(&lt;!-- raw HTML omitted -->authorization-code&lt;!-- raw HTML omitted -->)&lt;/li>
&lt;li>隐藏式(&lt;!-- raw HTML omitted -->implicit&lt;!-- raw HTML omitted -->)&lt;/li>
&lt;li>密码(&lt;!-- raw HTML omitted -->password&lt;!-- raw HTML omitted -->)&lt;/li>
&lt;li>客户端凭证(&lt;!-- raw HTML omitted -->client credentials&lt;!-- raw HTML omitted -->)&lt;/li>
&lt;/ul>
&lt;p>不管哪种方式，都需要在第三方应用申请令牌之前，需要在系统中申请身份唯一标识: 客户端ID &lt;!-- raw HTML omitted -->Client ID&lt;!-- raw HTML omitted --> 和 客户端秘钥 &lt;!-- raw HTML omitted -->Client Secret&lt;!-- raw HTML omitted -->.
这样能确保Token不被恶意使用。&lt;/p>
&lt;p>授权重要的参数和指标:&lt;/p>
&lt;ul>
&lt;li>&lt;!-- raw HTML omitted -->response_type&lt;!-- raw HTML omitted --> 响应类型: &lt;!-- raw HTML omitted -->code&lt;!-- raw HTML omitted -->(要求返回授权码),&lt;!-- raw HTML omitted -->token&lt;!-- raw HTML omitted -->(要求返回授权Token)&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->client_id&lt;!-- raw HTML omitted --> 客户端身份标识&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->client_secret&lt;!-- raw HTML omitted --> 客户端秘钥&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->redirect_uri&lt;!-- raw HTML omitted --> 重定向地址&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->scope&lt;!-- raw HTML omitted --> 授权范围, &lt;!-- raw HTML omitted -->read&lt;!-- raw HTML omitted --> 只读权限, &lt;!-- raw HTML omitted -->all&lt;!-- raw HTML omitted --> 全部权限&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->grant_type&lt;!-- raw HTML omitted --> 授权方式 &lt;!-- raw HTML omitted -->authorization_code&lt;!-- raw HTML omitted -->(授权码)、&lt;!-- raw HTML omitted -->password&lt;!-- raw HTML omitted -->(密码)、&lt;!-- raw HTML omitted -->client_credentials&lt;!-- raw HTML omitted -->
(凭证)、&lt;!-- raw HTML omitted -->refresh_token&lt;!-- raw HTML omitted -->(更新令牌)&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->state&lt;!-- raw HTML omitted --> 应用程序传递的一个随机数，防止 &lt;!-- raw HTML omitted -->CSRF&lt;!-- raw HTML omitted --> 攻击&lt;/li>
&lt;/ul>
&lt;h3 id="授权码httpswwwoauthcomoauth2-serversaccess-tokensauthorization-code-request-authorization-code-request">&lt;a href="https://www.oauth.com/oauth2-servers/access-tokens/authorization-code-request/" title="authorization-code-request">授权码&lt;/a>&lt;/h3>
&lt;p>在访问第三方应用先申请一个授权码，然后再用授权码获取令牌.这种方式也是最常用的流程，安全性也是最高的，适用于有后端的&lt;!-- raw HTML omitted -->Web&lt;!-- raw HTML omitted -->应用。授权码通过前端传送，令牌存储在后端。所有的和资源服务器的交互都在服务端完成，避免了令牌的泄露。
授权码和令牌的在 浏览器和客户端&lt;!-- raw HTML omitted -->WEB&lt;!-- raw HTML omitted -->应用以及资源服务器的交互流程大致如下:
&lt;img src="https://pinkhello.me/OAuth2-0%E9%82%A3%E7%82%B9%E4%BA%8B/auth_code.png" alt="authorization-code">&lt;/p>
&lt;ul>
&lt;li>1.2.3.4 用户选择 &lt;!-- raw HTML omitted -->Google&lt;!-- raw HTML omitted --> 登陆 &lt;!-- raw HTML omitted -->yelp.com&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>3.4 &lt;!-- raw HTML omitted -->Yelp.com&lt;!-- raw HTML omitted --> 请求用户授权 &lt;!-- raw HTML omitted -->Google&lt;!-- raw HTML omitted --> 权限&lt;/li>
&lt;li>5.6 用户同意后返回授权码
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;/li>
&lt;li>7.8 &lt;!-- raw HTML omitted -->Yelp.com&lt;!-- raw HTML omitted --> 通过授权码 会向 &lt;!-- raw HTML omitted -->Google&lt;!-- raw HTML omitted -->发起请求&lt;!-- raw HTML omitted -->Token&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;/li>
&lt;li>9 验证必要参数，返回 &lt;!-- raw HTML omitted -->Token&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>10.11 操作请求&lt;/li>
&lt;/ul>
&lt;h3 id="隐藏式httpsauth0comblogoauth2-implicit-grant-and-spa-oauth2-implicit-grant-and-spa">&lt;a href="https://auth0.com/blog/oauth2-implicit-grant-and-spa/" title="oauth2-implicit-grant-and-spa">隐藏式&lt;/a>&lt;/h3>
&lt;p>&lt;img src="https://pinkhello.me/OAuth2-0%E9%82%A3%E7%82%B9%E4%BA%8B/implicit.png" alt="implicit">&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h3 id="密码式httpswwwoauthcomoauth2-serversaccess-tokenspassword-grant-password-grant">&lt;a href="https://www.oauth.com/oauth2-servers/access-tokens/password-grant/" title="password-grant">密码式&lt;/a>&lt;/h3>
&lt;p>顾名思议,在自己的系统输入第三方系统的账号密码,自己的系统拿账号密码去申请令牌，响应题里面返回token&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h3 id="凭证式httpswwwoauthcomoauth2-serversaccess-tokensclient-credentials-client-credentials">&lt;a href="https://www.oauth.com/oauth2-servers/access-tokens/client-credentials/" title="client-credentials">凭证式&lt;/a>&lt;/h3>
&lt;p>凭证式和密码很相似，主要给没有前端输入的项目或者命令行&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h2 id="令牌的使用和更新">令牌的使用和更新&lt;/h2>
&lt;h3 id="令牌的使用">&lt;a href="">令牌的使用&lt;/a>&lt;/h3>
&lt;p>令牌的拿到了，就可以调用Google的API进行请求数据了，
一般讲 Token 放入请求头 Authorization.&lt;/p>
&lt;h3 id="令牌的更新httpswwwoauthcomoauth2-serversaccess-tokensrefreshing-access-tokens-refreshing-access-tokens">&lt;a href="https://www.oauth.com/oauth2-servers/access-tokens/refreshing-access-tokens/" title="refreshing-access-tokens">令牌的更新&lt;/a>&lt;/h3>
&lt;p>&lt;!-- raw HTML omitted -->Token&lt;!-- raw HTML omitted --> 是有时效性的，一旦过期就需要重新获取，但是重走一遍授权流程，不仅麻烦而且用户体验也不好，那如何让用户使用的优雅呢？&lt;/p>
&lt;p>一般在颁发令牌的时候，颁发两个&lt;!-- raw HTML omitted -->Token&lt;!-- raw HTML omitted -->, 一个授权&lt;!-- raw HTML omitted -->Token&lt;!-- raw HTML omitted -->,一个&lt;!-- raw HTML omitted -->Refresh Token&lt;!-- raw HTML omitted -->,
在更新&lt;!-- raw HTML omitted -->refresh_token&lt;!-- raw HTML omitted -->时候,将&lt;!-- raw HTML omitted -->grant_type&lt;!-- raw HTML omitted -->指定为&lt;!-- raw HTML omitted -->refresh_token&lt;!-- raw HTML omitted -->,
参数&lt;!-- raw HTML omitted -->refresh_token&lt;!-- raw HTML omitted -->是用于更新&lt;!-- raw HTML omitted -->Token&lt;!-- raw HTML omitted -->的&lt;!-- raw HTML omitted -->refresh_token&lt;!-- raw HTML omitted -->&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h1 id="总结">总结&lt;/h1>
&lt;h1 id="安利">安利&lt;/h1>
&lt;ul>
&lt;li>Client
&lt;ul>
&lt;li>Go &lt;a href="https://godoc.org/golang.org/x/oauth2">https://godoc.org/golang.org/x/oauth2&lt;/a>&lt;/li>
&lt;li>Java
&lt;ul>
&lt;li>&lt;a href="https://spring.io/projects/spring-social/">https://spring.io/projects/spring-social/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://spring.io/projects/spring-security/">https://spring.io/projects/spring-security/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server
&lt;ul>
&lt;li>Go
&lt;ul>
&lt;li>&lt;a href="https://github.com/go-oauth2/oauth2">https://github.com/go-oauth2/oauth2&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/zalando/gin-oauth2">https://github.com/zalando/gin-oauth2&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Java &lt;a href="https://github.com/zalando/tokens">https://github.com/zalando/tokens&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>参考&lt;/p>
&lt;ul>
&lt;li>jsonwebtoken.io &lt;a href="https://www.jsonwebtoken.io/">https://www.jsonwebtoken.io/&lt;/a>&lt;/li>
&lt;li>oauth.net &lt;a href="https://oauth.net/2/">https://oauth.net/2/&lt;/a>&lt;/li>
&lt;li>aliyun.com
&lt;ul>
&lt;li>&lt;a href="https://help.aliyun.com/document_detail/32144.html?spm=5176.87240.400427.53.32fa4614S88B0N">https://help.aliyun.com/document_detail/32144.html?spm=5176.87240.400427.53.32fa4614S88B0N&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://help.aliyun.com/document_detail/32008.html?spm=a2c4g.11186623.6.780.40435837SXpbPT">https://help.aliyun.com/document_detail/32008.html?spm=a2c4g.11186623.6.780.40435837SXpbPT&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://help.aliyun.com/document_detail/32026.html?spm=a2c4g.11186623.6.856.20b1c06dgVW6Ri">https://help.aliyun.com/document_detail/32026.html?spm=a2c4g.11186623.6.856.20b1c06dgVW6Ri&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
- https://pinkhello.me/posts/05-oauth2.0%E9%82%A3%E7%82%B9%E4%BA%8B/ - PinkHello, All Rights Reserved</description></item><item><title>04 如何构建一个简单的RPC调用</title><link>https://pinkhello.me/posts/04-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84rpc%E8%B0%83%E7%94%A8/</link><pubDate>Wed, 10 Feb 2021 08:24:19 +0800</pubDate><guid>https://pinkhello.me/posts/04-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84rpc%E8%B0%83%E7%94%A8/</guid><description>PinkHello https://pinkhello.me/posts/04-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84rpc%E8%B0%83%E7%94%A8/ -&lt;p>1、什么叫RPC?&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;img src="https://pinkhello.me/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BARPC%E8%B0%83%E7%94%A8/RPC%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E8%BF%87%E7%A8%8B.jpg" alt="RPC调用服务过程">&lt;/p>
&lt;p>RPC构成&lt;/p>
&lt;ul>
&lt;li>RPC Consumer&lt;/li>
&lt;li>RPC Provider&lt;/li>
&lt;li>ConfigServer&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>1、&lt;code>Provider&lt;/code> 启动 &lt;code>ConfigServer&lt;/code> 注册服务&lt;/li>
&lt;li>2、&lt;code>Consumer&lt;/code> 启动 &lt;code>ConfigServer&lt;/code> 订阅服务，&lt;/li>
&lt;li>3、发起调用 &lt;code>Consumer&lt;/code> &amp;mdash;&amp;gt; &lt;code>Provider&lt;/code>&lt;/li>
&lt;li>4、响应调用 &lt;code>Consumer&lt;/code> &amp;lt;&amp;mdash; &lt;code>Provider&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>2、什么是 &lt;code>Netty&lt;/code> ? &lt;a href="https://netty.io/">https://netty.io/&lt;/a>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;img src="https://pinkhello.me/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BARPC%E8%B0%83%E7%94%A8/netty%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="netty框架图">&lt;/p>
&lt;p>3、现有的开源的项目是否使用了 &lt;code>Netty&lt;/code> ?&lt;/p>
&lt;ul>
&lt;li>Dubbo&lt;/li>
&lt;li>Grpc&lt;/li>
&lt;li>Spark&lt;/li>
&lt;li>&amp;hellip;.&lt;/li>
&lt;/ul>
&lt;p>4、&lt;code>RPC Provider&lt;/code> 启动&lt;/p>
&lt;ul>
&lt;li>&lt;code>Netty Server&lt;/code> 方式启动&lt;/li>
&lt;li>&lt;code>Rpc&lt;/code> 服务的注册
&lt;img src="https://pinkhello.me/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BARPC%E8%B0%83%E7%94%A8/RPC%E4%B8%8ENetty%E7%BB%93%E5%90%88Provider%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="RPC与Netty结合Provider调用过程">&lt;/li>
&lt;/ul>
&lt;p>5、&lt;code>RPC Consumer&lt;/code> 启动&lt;/p>
&lt;ul>
&lt;li>&lt;code>Netty Client&lt;/code> 方式启动&lt;/li>
&lt;li>&lt;code>RPC&lt;/code> 泛化调用、通过字节码基于反射来实现远程调度&lt;/li>
&lt;li>&lt;code>Consumer&lt;/code> 服务订阅&lt;/li>
&lt;li>启动时建立长连接
&lt;img src="https://pinkhello.me/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BARPC%E8%B0%83%E7%94%A8/RPC%E4%B8%8ENetty%E7%BB%93%E5%90%88Consumer%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="RPC与Netty结合Consumer调用过程">&lt;/li>
&lt;/ul>
&lt;p>6、从第四可以看出，多个 &lt;code>Provider&lt;/code> 是由一个 &lt;code>NettyServer&lt;/code> 提供的，通过 &lt;code>HandlerMap&lt;/code> 映射找到对应的 &lt;code>Ioc Bean&lt;/code>，完成服务调用&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">服务端
EventLoopGroup bossGroup = &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> NioEventLoopGroup(1);
EventLoopGroup workerGroup = &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> NioEventLoopGroup();
&lt;span style="color:#8b008b;font-weight:bold">try&lt;/span> {
ServerBootstrap b = &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> ServerBootstrap();
b.&lt;span style="color:#658b00">group&lt;/span>(bossGroup, workerGroup)
.&lt;span style="color:#658b00">channel&lt;/span>(NioServerSocketChannel.&lt;span style="color:#658b00">class&lt;/span>)
.&lt;span style="color:#658b00">option&lt;/span>(ChannelOption.&lt;span style="color:#658b00">SO_BACKLOG&lt;/span>, 100)
.&lt;span style="color:#658b00">handler&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> LoggingHandler(LogLevel.&lt;span style="color:#658b00">INFO&lt;/span>))
.&lt;span style="color:#658b00">childHandler&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
&lt;span style="color:#707a7c">@Override&lt;/span>
&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#00688b;font-weight:bold">void&lt;/span> &lt;span style="color:#008b45">initChannel&lt;/span>(SocketChannel ch) &lt;span style="color:#8b008b;font-weight:bold">throws&lt;/span> Exception {
ChannelPipeline p = ch.&lt;span style="color:#658b00">pipeline&lt;/span>();
p.&lt;span style="color:#658b00">addLast&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> RpcEncoder(RpcRequest.&lt;span style="color:#658b00">class&lt;/span>));
p.&lt;span style="color:#658b00">addLast&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> RpcDecoder(RpcResponse.&lt;span style="color:#658b00">class&lt;/span>));
p.&lt;span style="color:#658b00">addLast&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> RpcHandler());
}});
&lt;span style="color:#228b22">// Start the server.
&lt;/span>&lt;span style="color:#228b22">&lt;/span> ChannelFuture f = b.&lt;span style="color:#658b00">bind&lt;/span>(PORT).&lt;span style="color:#658b00">sync&lt;/span>();
&lt;span style="color:#228b22">// Wait until the server socket is closed.
&lt;/span>&lt;span style="color:#228b22">&lt;/span> f.&lt;span style="color:#658b00">channel&lt;/span>().&lt;span style="color:#658b00">closeFuture&lt;/span>().&lt;span style="color:#658b00">sync&lt;/span>();
} &lt;span style="color:#8b008b;font-weight:bold">finally&lt;/span> {
&lt;span style="color:#228b22">// Shut down all event loops to terminate all threads.
&lt;/span>&lt;span style="color:#228b22">&lt;/span> bossGroup.&lt;span style="color:#658b00">shutdownGracefully&lt;/span>();
workerGroup.&lt;span style="color:#658b00">shutdownGracefully&lt;/span>();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://pinkhello.me/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BARPC%E8%B0%83%E7%94%A8/Netty%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AFTCP%E9%93%BE%E6%8E%A5%E4%B8%8A%E7%9A%84%E8%AF%B7%E6%B1%82.jpg" alt="Netty如何处理客户端TCP链接上的请求">&lt;/p>
&lt;p>&lt;img src="https://pinkhello.me/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BARPC%E8%B0%83%E7%94%A8/NettyReactor%E5%B7%A5%E4%BD%9C%E6%A1%86%E6%9E%B6%E5%9B%BE.jpg" alt="NettyReactor工作框架图">&lt;/p>
&lt;ul>
&lt;li>&lt;code>BossGroup&lt;/code> -&amp;gt; 处理客户端的请求&lt;/li>
&lt;li>&lt;code>EventGroup&lt;/code> —&amp;gt; 处理IO &lt;code>Read/Write&lt;/code> 操作、执行任务系统Task、定时任务&lt;/li>
&lt;li>&lt;code>ChildChannelHandler&lt;/code> 方式是对 &lt;code>ChannelPipeline&lt;/code> 的设置、&lt;/li>
&lt;li>&lt;code>ChannelPipeline&lt;/code> 是相当于任务链的模式, 是一串 &lt;code>ChannelHandler&lt;/code> 的实例&lt;/li>
&lt;li>&lt;code>ChannelHandlerContext&lt;/code> 是 &lt;code>ChannelPipeline&lt;/code> 和 &lt;code>ChannelHandler&lt;/code> 的关系&lt;/li>
&lt;li>每个链接对于 &lt;code>Sever&lt;/code> 端都会创建一个 &lt;code>Channel&lt;/code> ，可以将 &lt;code>Channel&lt;/code> 理解为 &lt;code>Connection&lt;/code> （其实真正的是 &lt;code>Connection&lt;/code> 属于 &lt;code>Channel&lt;/code> 的一部分）&lt;/li>
&lt;li>每个 &lt;code>Channel&lt;/code> 都有一个自己的唯一的 &lt;code>ChannelPipeline&lt;/code> 操作，对于其他的 &lt;code>Channel&lt;/code> 的 &lt;code>ChannelPipeline&lt;/code> 是隔离的&lt;/li>
&lt;li>&lt;code>RPC Handler&lt;/code> 是我们对于自己的找寻 &lt;code>RPC&lt;/code> 服务处理的 &lt;code>Handler&lt;/code> 实现&lt;/li>
&lt;li>&lt;code>RPC Encoder&lt;/code> 是我们对于自己的找寻 &lt;code>RPC&lt;/code> 序列化的编码的 &lt;code>Handler&lt;/code> 实现&lt;/li>
&lt;li>&lt;code>RPC Decoder&lt;/code> 是我们对于自己的找寻 &lt;code>RPC&lt;/code> 序列化的解码的 &lt;code>Handler&lt;/code> 实现&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">客户端
EventLoopGroup group = &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> NioEventLoopGroup();
&lt;span style="color:#8b008b;font-weight:bold">try&lt;/span> {
Bootstrap b = &lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> Bootstrap();
b.&lt;span style="color:#658b00">group&lt;/span>(group)
.&lt;span style="color:#658b00">channel&lt;/span>(NioSocketChannel.&lt;span style="color:#658b00">class&lt;/span>)
.&lt;span style="color:#658b00">option&lt;/span>(ChannelOption.&lt;span style="color:#658b00">TCP_NODELAY&lt;/span>, &lt;span style="color:#8b008b;font-weight:bold">true&lt;/span>)
.&lt;span style="color:#658b00">handler&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
&lt;span style="color:#707a7c">@Override&lt;/span>
&lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#00688b;font-weight:bold">void&lt;/span> &lt;span style="color:#008b45">initChannel&lt;/span>(SocketChannel ch) &lt;span style="color:#8b008b;font-weight:bold">throws&lt;/span> Exception {
ChannelPipeline p = ch.&lt;span style="color:#658b00">pipeline&lt;/span>();
p.&lt;span style="color:#658b00">addLast&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> RpcEncoder(RpcResponse.&lt;span style="color:#658b00">class&lt;/span>));
p.&lt;span style="color:#658b00">addLast&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> RpcDecoder(RpcRequest.&lt;span style="color:#658b00">class&lt;/span>));
p.&lt;span style="color:#658b00">addLast&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">new&lt;/span> RpcClientHandler());
}});
&lt;span style="color:#228b22">// Start the client.
&lt;/span>&lt;span style="color:#228b22">&lt;/span> ChannelFuture f = b.&lt;span style="color:#658b00">connect&lt;/span>(HOST, PORT).&lt;span style="color:#658b00">sync&lt;/span>();
&lt;span style="color:#228b22">// Wait until the connection is closed.
&lt;/span>&lt;span style="color:#228b22">&lt;/span> f.&lt;span style="color:#658b00">channel&lt;/span>().&lt;span style="color:#658b00">closeFuture&lt;/span>().&lt;span style="color:#658b00">sync&lt;/span>();
} &lt;span style="color:#8b008b;font-weight:bold">finally&lt;/span> {
&lt;span style="color:#228b22">// Shut down the event loop to terminate all threads.
&lt;/span>&lt;span style="color:#228b22">&lt;/span> group.&lt;span style="color:#658b00">shutdownGracefully&lt;/span>();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>7、&lt;code>RPC&lt;/code> 序列化&lt;/p>
&lt;ul>
&lt;li>二进制数据&lt;/li>
&lt;li>Hessian&lt;/li>
&lt;li>Avro&lt;/li>
&lt;li>ProtoBuffer (Protobuf)&lt;/li>
&lt;li>JSON&lt;/li>
&lt;li>XML&lt;/li>
&lt;/ul>
&lt;p>8、关于 &lt;code>RPC&lt;/code> 的实现思考与技术讨论&lt;/p>
&lt;ul>
&lt;li>业务方法、因为是收到请求消息而触发的后续动作调用，不做额外设置，肯定是使用的 &lt;code>WorkGroup&lt;/code> 里面的线程操作的。
而作为业务层，不应该与底层关联，应该切割开来，势必会引入真的业务侧线程池。
那么如何引用、怎么引用？(关于 业务线程池 与 &lt;code>WorkGroup&lt;/code> 的 &lt;code>EvenLoop&lt;/code> 的思考 )&lt;/li>
&lt;li>关于 &lt;code>RPC&lt;/code> 调用大部分是同步的调用，而 &lt;code>Netty&lt;/code> 底层是完全异步事件机制，在RPC框架层面如何实现同步的调用方式的？&lt;/li>
&lt;li>基于 &lt;code>TCP&lt;/code> 的长链接调用，在 &lt;code>RPC&lt;/code> 上你会想到其他的哪些东东？&lt;/li>
&lt;li>在此环境下，我没有介绍 &lt;code>RPC&lt;/code> 服务于 IOC容器的结合，可以思考一下，如何做到 注解机制、&lt;code>JAVA CONFIG&lt;/code> 机制、&lt;code>XML SCHEMA&lt;/code> 机制来做?
&lt;ul>
&lt;li>GUICE&lt;/li>
&lt;li>SPRING&lt;/li>
&lt;li>SPI&lt;/li>
&lt;li>&amp;hellip;.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
- https://pinkhello.me/posts/04-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84rpc%E8%B0%83%E7%94%A8/ - PinkHello, All Rights Reserved</description></item><item><title>链接</title><link>https://pinkhello.me/links/</link><pubDate>Tue, 09 Feb 2021 10:38:21 +0800</pubDate><guid>https://pinkhello.me/links/</guid><description>PinkHello https://pinkhello.me/links/ -- https://pinkhello.me/links/ - PinkHello, All Rights Reserved</description></item><item><title>关于我</title><link>https://pinkhello.me/about/</link><pubDate>Tue, 09 Feb 2021 10:36:43 +0800</pubDate><guid>https://pinkhello.me/about/</guid><description>PinkHello https://pinkhello.me/about/ -&lt;h2 id="--pinkhello-viewshttpsviewswhatilearenedtodayviewsgithubpinkhellopinkhellosvg">📧 👷 pinkhello &lt;img src="https://views.whatilearened.today/views/github/pinkhello/pinkhello.svg" alt="views">&lt;/h2>
&lt;ul>
&lt;li>Email: &lt;a href="mailto:lee123lee123@163.com">lee123lee123@163.com&lt;/a>&lt;/li>
&lt;li>微信: chess_1&lt;/li>
&lt;li>博客: &lt;a href="https://pinkhello.me">https://pinkhello.me&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://github-readme-stats.vercel.app/api?username=pinkhello&amp;amp;show_icons=true&amp;amp;theme=vue&amp;amp;hide_border=true&amp;amp;line_height=20&amp;amp;count_private=true" alt="">
&lt;img src="https://github-readme-stats.vercel.app/api/top-langs/?username=pinkhello&amp;amp;layout=compact&amp;amp;hide_border=true&amp;amp;hide=html,vim&amp;amp;count_private=true" alt="">&lt;/p>
&lt;h2 id="-个人开源项目">🐳 个人开源项目&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">项目&lt;/th>
&lt;th style="text-align:left">描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://github.com/pinkhello/gopush">GoPush&lt;/a>&lt;/td>
&lt;td style="text-align:left">一个实时推送组件&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://github.com/pinkhello/spring-boot-starter-dubbo">spring-boot-starter-dubbo&lt;/a>&lt;/td>
&lt;td style="text-align:left">dubbo-spring-boot-脚手架&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://github.com/pinkhello/go-starter">go-starter&lt;/a>&lt;/td>
&lt;td style="text-align:left">Go服务开发脚手架&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="-技能">⚡ 技能&lt;/h2>
&lt;p>Language&lt;br>
&lt;img src="https://img.shields.io/badge/-Java-black?style=flat-square&amp;amp;logo=Java" alt="Java">
&lt;img src="https://img.shields.io/badge/-Go-black?style=flat-square&amp;amp;logo=Go" alt="Go">
&lt;img src="https://img.shields.io/badge/-Python-black?style=flat-square&amp;amp;logo=Python" alt="Python">
&lt;img src="https://img.shields.io/badge/-JavaScript-black?style=flat-square&amp;amp;logo=JavaScript" alt="JavaScript">&lt;/p>
&lt;p>Framework&lt;br>
&lt;img src="https://img.shields.io/badge/-Vue-000000?style=flat-square&amp;amp;logo=Vue.js" alt="Vue">
&lt;img src="https://img.shields.io/badge/-Spring-black?style=flat-square&amp;amp;logo=Spring" alt="Spring">
&lt;img src="https://img.shields.io/badge/-Spring%20Boot(Cloud)-black?style=flat-square&amp;amp;logo=Spring%20Boot(Cloud)" alt="Spring Boot(Cloud)">
&lt;img src="https://img.shields.io/badge/-Dubbo-black?style=flat-square&amp;amp;logo=Dubbo" alt="Dubbo">
&lt;img src="https://img.shields.io/badge/-Flask-black?style=flat-square&amp;amp;logo=Flask" alt="Flask">
&lt;img src="https://img.shields.io/badge/-Echo-black?style=flat-square&amp;amp;logo=Echo" alt="Echo">
&lt;img src="https://img.shields.io/badge/-Gin-black?style=flat-square&amp;amp;logo=Gin" alt="Gin">
&lt;img src="https://img.shields.io/badge/-Grpc-black?style=flat-square&amp;amp;logo=Grpc" alt="Grpc">&lt;/p>
&lt;p>Tools&lt;br>
&lt;img src="https://img.shields.io/badge/-Redis-black?style=flat-square&amp;amp;logo=Redis" alt="Redis">
&lt;img src="https://img.shields.io/badge/-MySQL-black?style=flat-square&amp;amp;logo=mysql" alt="MySQL">
&lt;img src="https://img.shields.io/badge/-Nginx-black?style=flat-square&amp;amp;logo=Nginx" alt="Nginx">
&lt;img src="https://img.shields.io/badge/-MongoDB-black?style=flat-square&amp;amp;logo=MongoDB" alt="MongoDB">
&lt;img src="https://img.shields.io/badge/-Pulsar-black?style=flat-square&amp;amp;logo=Pulsar" alt="Pulsar">
&lt;img src="https://img.shields.io/badge/-Kafka-black?style=flat-square&amp;amp;logo=Kafka" alt="Kafka">
&lt;img src="https://img.shields.io/badge/-Nsq-black?style=flat-square&amp;amp;logo=Nsq" alt="Nsq">
&lt;img src="https://img.shields.io/badge/-RabbitMQ-black?style=flat-square&amp;amp;logo=RabbitMQ" alt="RabbitMQ">
&lt;img src="https://img.shields.io/badge/-GitHub-181717?style=flat-square&amp;amp;logo=github" alt="GitHub">&lt;/p>
&lt;p>Others&lt;br>
&lt;img src="https://img.shields.io/badge/-Kubernetes-black?style=flat-square&amp;amp;logo=Kubernetes" alt="Kubernetes">
&lt;img src="https://img.shields.io/badge/-Docker-black?style=flat-square&amp;amp;logo=Docker" alt="Docker">
&lt;img src="https://img.shields.io/badge/-Linux-black?style=flat-square&amp;amp;logo=Linux" alt="Linux">
&lt;img src="https://img.shields.io/badge/-Deepin-007CFF?style=flat-square&amp;amp;logo=deepin" alt="Deepin">
&lt;img src="https://img.shields.io/badge/-Centos-262577?style=flat-square&amp;amp;logo=Centos" alt="Centos">
&lt;img src="https://img.shields.io/badge/-Raspberry%20Pi-C51A4A?style=flat-square&amp;amp;logo=Raspberry-Pi" alt="Raspberry Pi">&lt;/p>
&lt;h2 id="-2021-okr-进度">🚀 2021 OKR 进度&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">动作&lt;/th>
&lt;th style="text-align:left">进度&lt;/th>
&lt;th style="text-align:left">目标&lt;/th>
&lt;th style="text-align:left">缺陷&lt;/th>
&lt;th style="text-align:left">其他&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">👯 Go服务开发脚手架&lt;/td>
&lt;td style="text-align:left">done&lt;/td>
&lt;td style="text-align:left">&lt;a href="https://github.com/pinkhello/go-starter">go-starter&lt;/a>&lt;/td>
&lt;td style="text-align:left">ut&lt;/td>
&lt;td style="text-align:left">-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">💵 Go服务开发脚手架开发一个简单前后端系统&lt;/td>
&lt;td style="text-align:left">done&lt;/td>
&lt;td style="text-align:left">&lt;a href="http://121.4.242.26">房产CRM信息系统&lt;/a> test/123456&lt;/td>
&lt;td style="text-align:left">-&lt;/td>
&lt;td style="text-align:left">BE采用的&lt;a href="https://github.com/pinkhello/go-starter">go-starter&lt;/a>, FE 采用的&lt;a href="https://pro.antdv.com/">ant-design-vue-pro&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">🐳 K8S原理&lt;/td>
&lt;td style="text-align:left">running&lt;/td>
&lt;td style="text-align:left">&lt;a href="https://pinkhello.me/categories/k8s/">K8S博客成档&lt;/a>&lt;/td>
&lt;td style="text-align:left">-&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">🚀 RocketMQ 源代码阅读(Java)&lt;/td>
&lt;td style="text-align:left">running&lt;/td>
&lt;td style="text-align:left">&lt;a href="https://pinkhello.me/categories/rocketmq/">RocketMQ博客成档&lt;/a>&lt;/td>
&lt;td style="text-align:left">-&lt;/td>
&lt;td style="text-align:left">-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">🚀 RocketMQ 客户端代码阅读(Compare Go/Java)&lt;/td>
&lt;td style="text-align:left">running&lt;/td>
&lt;td style="text-align:left">&lt;a href="https://pinkhello.me/categories/rocketmq/">RocketMQ博客成档&lt;/a>&lt;/td>
&lt;td style="text-align:left">-&lt;/td>
&lt;td style="text-align:left">-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">😄 MySQL实现原理解析&lt;/td>
&lt;td style="text-align:left">prepare&lt;/td>
&lt;td style="text-align:left">博客成档&lt;/td>
&lt;td style="text-align:left">-&lt;/td>
&lt;td style="text-align:left">-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">🏫 数据结构与算法之美&lt;/td>
&lt;td style="text-align:left">prepare&lt;/td>
&lt;td style="text-align:left">博客成档&lt;/td>
&lt;td style="text-align:left">-&lt;/td>
&lt;td style="text-align:left">-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
- https://pinkhello.me/about/ - PinkHello, All Rights Reserved</description></item><item><title>回望K8S 持久化存储</title><link>https://pinkhello.me/posts/22-%E5%9B%9E%E6%9C%9Bk8s-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/</link><pubDate>Sat, 21 Mar 2020 17:17:13 +0800</pubDate><guid>https://pinkhello.me/posts/22-%E5%9B%9E%E6%9C%9Bk8s-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/</guid><description>PinkHello https://pinkhello.me/posts/22-%E5%9B%9E%E6%9C%9Bk8s-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/ -&lt;h1 id="pvpvcstorageclass-说的啥">&lt;code>PV&lt;/code>、&lt;code>PVC&lt;/code>、&lt;code>StorageClass&lt;/code> 说的啥？&lt;/h1>
&lt;p>&lt;code>PV&lt;/code>: 持久化存储数据卷，这个 API 主要定义的是一个持久化存储在宿主机上的一个目录。一般由运维人员进行定义，比如定义一个 NFS 类型的 PV&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>PersistentVolume&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nfs&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">storageClassName&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>manual&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">capacity&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">storage&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>1Gi&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">accessModes&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- ReadWriteMany&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">nfs&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">server&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b452cd">10.244.1.5&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">path&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;/&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>PVC&lt;/code>: POD 所希望使用的持久化存储的属性. 比如 &lt;code>Volume&lt;/code> 的存储大小、可读写权限等.
&lt;code>PVC&lt;/code> 一般由开发人员创建、或者由 &lt;code>PVC&lt;/code>模板的方式成为&lt;code>StatefulSet&lt;/code>的一部分，由&lt;code>StatefulSet&lt;/code>控制器负责创建带编号的&lt;code>PVC&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#228b22"># 创建一个 1 GB 大小的PVC&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008b45;text-decoration:underline">---&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>PersistentVolumeClaim&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nfs&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">accessModes&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- ReadWriteMany&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">storageClassName&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>manual&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">resources&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">requests&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">storage&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>1Gi&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008b45;text-decoration:underline">...&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用户创建的&lt;code>PVC&lt;/code>要真正的被容器使用的化，需要于心和某个符合条件的&lt;code>PV&lt;/code>进行绑定：&lt;/p>
&lt;ul>
&lt;li>第一个条件，&lt;code>PV&lt;/code> 和 &lt;code>PVC&lt;/code> 的 &lt;code>spec&lt;/code> 字段。例如: &lt;code>PV&lt;/code> 的存储(&lt;code>storage&lt;/code>)大小就必须满足 &lt;code>PVC&lt;/code> 的要求&lt;/li>
&lt;li>第二个条件，&lt;code>PV&lt;/code> 和 &lt;code>PVC&lt;/code> 的 &lt;code>storageClassName&lt;/code> 字段名称必须一样。&lt;/li>
&lt;/ul>
&lt;p>下面是去使用这个&lt;code>PVC&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Pod&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">labels&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">role&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>web-frontend&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">containers&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>web&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">image&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">ports&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>web&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">containerPort&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b452cd">80&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">volumeMounts&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nfs&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">mountPath&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;/usr/share/nginx/html&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">volumes&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nfs&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">persistentVolumeClaim&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">claimName&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nfs&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>PVC&lt;/code> 理解为持久化存储的 接口，它提供了对某种持久化存储的描述，但不提供具体的实现，而这个持久化的实现部分由 &lt;code>PV&lt;/code> 完成。&lt;/p>
&lt;p>假设，我们在创建 &lt;code>POD&lt;/code> 的时候，系统内并没有合适的 &lt;code>PV&lt;/code> 跟它定义的 &lt;code>PVC&lt;/code> 绑定，这个时候容器想要使用的 &lt;code>Volume&lt;/code> 不存在，怎么办呢？&lt;/p>
&lt;p>在 &lt;code>Kubernetes&lt;/code> 内，时机存在一个专门处理持久化存储的控制器，叫做 &lt;code>VolumeController&lt;/code>。这个&lt;code>VolumeController&lt;/code>维护着多个控制循环,
其中有个循环就是用来撮合 &lt;code>PV&lt;/code> 和 &lt;code>PVC&lt;/code> 进行绑定的角色，名字叫 &lt;code>PersistentVolumeController&lt;/code>. 它会不断的查看当前的每一个 &lt;code>PVC&lt;/code>， 是否处于 &lt;code>Bound&lt;/code> 状态
如果不是，它会遍历所以的、可用的 &lt;code>PV&lt;/code>，并尝试将其与这个声明的PVC进行绑定。这样，&lt;code>Kubernetes&lt;/code> 就可以保证用户提交的每一个 &lt;code>PVC&lt;/code>，只要有合适的 &lt;code>PV&lt;/code> 出现，它能快速的进入绑定状态。
而所谓的绑定，其实就是将这个 &lt;code>PV&lt;/code> 对象的名字填充在了 &lt;code>PVC&lt;/code> 对象的 &lt;code>spec.volumeName&lt;/code> 字段上。接下来 &lt;code>Kubernetes&lt;/code> 只要获取到这个 &lt;code>PVC&lt;/code> 对象，就一定能够找到它所绑定的 &lt;code>PV&lt;/code>.&lt;/p>
&lt;p>&lt;code>PV&lt;/code> 对象如何变成容器里的一个持久化存储的呢？&lt;/p>
&lt;p>所谓容器的 &lt;code>Volume&lt;/code> ，其实就是将一个宿主机上的目录，跟容器里的目录进行绑定挂载在一起的，
所谓的 &lt;code>持久化Volume&lt;/code> ，指的就是这个宿主机上的目录，具备&lt;code>持久化&lt;/code>,即当目录里面的内容，既不会因为容器的删除而被清理、也不会跟当前的宿主机绑定，当容器进行重启或者在其他节点上重建之后，依然能够挂载到这个 &lt;code>Volume&lt;/code>, 访问这些内容，
所以，大多数情况下，持久化的 &lt;code>Volume&lt;/code> 的实现，往往依赖一个远程存储服务，比如远程文件存储（&lt;code>NFS&lt;/code>、&lt;code>GlusterFS&lt;/code>），远程块存储（公有云的远程磁盘）。&lt;/p>
&lt;p>&lt;code>持久化&lt;/code>宿主机目录的过程，这个形象的成为 &lt;code>两阶段处理&lt;/code>&lt;/p>
&lt;p>当一个 &lt;code>POD&lt;/code> 调度到一个节点上后, &lt;code>Kubelet&lt;/code> 就要为这个 &lt;code>POD&lt;/code> 创建一个 &lt;code>Volume&lt;/code> 目录, 默认情况下 &lt;code>Kubelet&lt;/code> 为 &lt;code>Volume&lt;/code> 创建的目录如下所示（在宿主机上）&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">/var/lib/kubelet/pods/&amp;lt;Pod的ID&amp;gt;/volumes/kubernetes.io~&amp;lt;Volume类型&amp;gt;/&amp;lt;Volume名字&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来, &lt;code>Kubelet&lt;/code> 要做的操作取决于 &lt;code>Volume&lt;/code> 类型.
如果 &lt;code>Volume&lt;/code> 类型是远程块存储，比如 &lt;code>Google CLoud&lt;/code> 的 &lt;code>Persistent Disk&lt;/code>, 那么 &lt;code>Kubelet&lt;/code> 就需要先调用 &lt;code>Google Cloud&lt;/code> 的 &lt;code>API&lt;/code>, 将它所提供的 &lt;code>Persistent Disk&lt;/code> 挂载到 &lt;code>Pod&lt;/code> 所在的宿主机上。
相当于执行了&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">gcloud compute instances attach-disk &amp;lt;虚拟机名字&amp;gt; --disk &amp;lt;远程磁盘名字&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>为虚拟机挂载远程磁盘的操作，对应的正是 &lt;code>两阶段处理&lt;/code> 的第一段。即在 &lt;code>Kubernetes&lt;/code> 中的 &lt;code>Attach&lt;/code> 阶段。&lt;/p>
&lt;p>&lt;code>Attach&lt;/code> 阶段后,要能够使用这个远程磁盘, &lt;code>Kubelet&lt;/code> 需要进行第二个操作: 即使会这个磁盘设备, 然后将它挂载到宿主机知道的挂载点上。 这一步相当于执行:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#228b22"># 通过lsblk命令获取磁盘设备ID&lt;/span>
sudo lsblk
&lt;span style="color:#228b22"># 格式化成ext4格式&lt;/span>
sudo mkfs.ext4 -m &lt;span style="color:#b452cd">0&lt;/span> -F -E &lt;span style="color:#00688b">lazy_itable_init&lt;/span>=0,lazy_journal_init=0,discard /dev/&amp;lt;磁盘设备ID&amp;gt;
&lt;span style="color:#228b22"># 挂载到挂载点&lt;/span>
sudo mkdir -p /var/lib/kubelet/pods/&amp;lt;Pod的ID&amp;gt;/volumes/kubernetes.io~&amp;lt;Volume类型&amp;gt;/&amp;lt;Volume名字&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个将磁盘设备格式化并挂载到 &lt;code>Volume&lt;/code> 宿主机目录的操作,对应的正是 &amp;ldquo;两阶段处理&amp;rdquo; 的第二段: &lt;code>Mount&lt;/code>&lt;/p>
&lt;p>&lt;code>Kubernetes&lt;/code> 如何定义和区分这两个阶段的？
在具体的 &lt;code>Volume&lt;/code> 插件的实现接口上, &lt;code>Kubernetes&lt;/code> 分别给这两个阶段提供了两种不同的参数列表:&lt;/p>
&lt;ul>
&lt;li>第一阶段 &lt;code>Attach&lt;/code>, &lt;code>Kubernetes&lt;/code> 提供的可用参数是 &lt;code>nodeName&lt;/code>, 即宿主机的名字&lt;/li>
&lt;li>第二阶段 &lt;code>Mount&lt;/code>, &lt;code>Kubernetes&lt;/code> 提供的可用参数是 &lt;code>dir&lt;/code>, 即 &lt;code>Volume&lt;/code> 的宿主机目录&lt;/li>
&lt;/ul>
&lt;p>在经过 &amp;ldquo;两阶段处理&amp;rdquo;, 我们得到了一个 &lt;code>持久化&lt;/code> 的 &lt;code>Volume&lt;/code> 宿主机目录, 然后, &lt;code>Kubelet&lt;/code> 只要把这个 &lt;code>Volume&lt;/code> 目录通过 &lt;code>CRI&lt;/code> 里的 &lt;code>Mounts&lt;/code> 参数,传递给 &lt;code>Docker&lt;/code>, 然后就可以为 &lt;code>POD&lt;/code> 里的容器挂载这个 &amp;ldquo;持久化&amp;rdquo; 的 &lt;code>Volume&lt;/code>。&lt;/p>
&lt;p>另外还有一个核心的概念 &lt;code>StorageClass&lt;/code>, &lt;code>Kubernetes&lt;/code> 为我们提供了一套可以自动创建 &lt;code>PV&lt;/code> 的机制, 即 &lt;code>Dynamic Provisioning&lt;/code>, 前面人工管理的 &lt;code>PV&lt;/code> 方式叫做 &lt;code>Static Provisioning&lt;/code>。&lt;/p>
&lt;p>&lt;code>Dynamic Provisioning&lt;/code> 机制工作的核心, 在于一个名叫 &lt;code>StorageClass&lt;/code> 的API对象。而这个对象的作用，就是创建 PV 的模板。&lt;code>StorageClass&lt;/code>对象会定义如下两个部分内容:&lt;/p>
&lt;ul>
&lt;li>第一, &lt;code>PV&lt;/code> 的属性。比如 存储类型、&lt;code>Volume&lt;/code> 大小等&lt;/li>
&lt;li>第二, 创建这种 &lt;code>PV&lt;/code> 需要用到的存储插件。比如 &lt;code>Ceph&lt;/code> 等
有这两个信息后, &lt;code>Kubernetes&lt;/code> 就可以根据用户提交的 &lt;code>PVC&lt;/code>,找到一个对应的 &lt;code>StorageClass&lt;/code>，然后 &lt;code>Kubernetes&lt;/code> 就好调用该 &lt;code>StorageClass&lt;/code> 声明的存储插件, 创建出需要的 &lt;code>PV&lt;/code>。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#228b22">#在这个 YAML 文件里，我们定义了一个名叫 block-service 的 StorageClass。&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>storage.k8s.io/v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>StorageClass&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>block-service&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">provisioner&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>kubernetes.io/gce-pd&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># GCE PD 存储插件的名字&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">parameters&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>pd-ssd&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># SSD格式的GCE远程磁盘&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="kubernetes-pv-和-pvc-体系是不是多此一样">Kubernetes PV 和 PVC 体系是不是多此一样&lt;/h1>
&lt;p>Kubernetes 支持多种的持久化 &lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes">Kubernetes内置的持久化数据卷实现&lt;/a>&lt;/p>
&lt;p>在通过 &lt;code>PV&lt;/code> 和 &lt;code>PVC&lt;/code>, 以及 &lt;code>StorageClass&lt;/code> 这套存储体系, 为后来添加持久化存储方案,对已有的 &lt;code>Kubernetes&lt;/code> 的影响,几乎可以忽略不及。作位用户, &lt;code>POD&lt;/code> 的 &lt;code>YAML&lt;/code> 和 &lt;code>PVC&lt;/code> 的 &lt;code>YAML&lt;/code> 并没有任何特殊的改变.&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>&lt;img src="https://pinkhello.me/%E5%9B%9E%E6%9C%9BK8S/pvc-pv-storageclass-check.png" alt="PVC-PV设计">&lt;/p>
&lt;ul>
&lt;li>&lt;code>PVC&lt;/code> 描述 &lt;code>POD&lt;/code> 想要使用的持久化存储的属性，比如存储的大小、读写权限。&lt;/li>
&lt;li>&lt;code>PV&lt;/code> 描述的 一个具体的 &lt;code>Volume&lt;/code> 的属性、比如 &lt;code>Volume&lt;/code> 的类型、挂载目录、远程存储服务器地址&lt;/li>
&lt;li>&lt;code>StorageClass&lt;/code> 作用，充当 &lt;code>PV&lt;/code> 的模板，只要同属于一个 &lt;code>StorageClass&lt;/code> 的 &lt;code>PV&lt;/code> 和 &lt;code>PVC&lt;/code>，才可以绑定在一起。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://pinkhello.me/%E5%9B%9E%E6%9C%9BK8S/pvc-pv.png" alt="Kubernetes持久化存储的原理">
&lt;img src="https://pinkhello.me/%E5%9B%9E%E6%9C%9BK8S/CSI.png" alt="Kubernetes持久化存储的通过CSI插件操作原理">&lt;/p>
&lt;ul>
&lt;li>&lt;code>Driver Registrar&lt;/code> 组件负责将插件注册到 &lt;code>kubelet&lt;/code> 阶段，请求&lt;code>CSI&lt;/code>插件的 &lt;code>Identity服务&lt;/code> 获取插件信息&lt;/li>
&lt;li>&lt;code>External Provisioner&lt;/code> 组件 &lt;code>Provision 阶段&lt;/code>, &lt;code>External Provisioner&lt;/code> 监听（&lt;code>Watch&lt;/code>）了 &lt;code>APIServer&lt;/code> 里的 &lt;code>PVC对象&lt;/code>。当一个 &lt;code>PVC&lt;/code> 被创建时，它就会调用 &lt;code>CSI Controller&lt;/code> 的 &lt;code>CreateVolume&lt;/code> 方法，为你创建对应 &lt;code>PV&lt;/code>&lt;/li>
&lt;li>&lt;code>External Attacher&lt;/code> 组件负责正是 &amp;ldquo;&lt;code>Attach 阶段&lt;/code>&amp;rdquo;, 它监听了 &lt;code>APIServer&lt;/code> 里的 &lt;code>VolumeAttachment 对象&lt;/code>的变化, &lt;code>VolumeAttachment 对象&lt;/code>是 &lt;code>Kubernetes&lt;/code> 确认一个 &lt;code>Volume&lt;/code> 可以进入 &lt;code>Attach 阶段&lt;/code> 的重要标志&lt;/li>
&lt;/ul>
- https://pinkhello.me/posts/22-%E5%9B%9E%E6%9C%9Bk8s-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/ - PinkHello, All Rights Reserved</description></item><item><title>回望K8S 容器编排与Kubernetes作业管理</title><link>https://pinkhello.me/posts/20-%E5%9B%9E%E6%9C%9Bk8s-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8Ekubernetes%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/</link><pubDate>Sun, 16 Feb 2020 22:48:35 +0800</pubDate><guid>https://pinkhello.me/posts/20-%E5%9B%9E%E6%9C%9Bk8s-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8Ekubernetes%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/</guid><description>PinkHello https://pinkhello.me/posts/20-%E5%9B%9E%E6%9C%9Bk8s-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8Ekubernetes%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/ -&lt;h1 id="pod">Pod&lt;/h1>
&lt;p>&lt;code>pod&lt;/code> 是 &lt;code>Kubernetes&lt;/code> 项目的最小的 API 对象，原子调度单位.&lt;/p>
&lt;p>假设 &amp;ldquo;容器的本质是进程&amp;rdquo;，容器镜像就是 exe 安装包, kubernetes 是操作系统&lt;/p>
&lt;p>&lt;code>Pod&lt;/code> 最重要的一个事实是一个逻辑概念。它对于 &lt;code>Kubernetes&lt;/code> 最核心的意义是 &lt;code>容器设计模式&lt;/code>。&lt;code>Kubernetes&lt;/code> 真正处理的还是宿主机上操作系统上的 &lt;code>Linux&lt;/code> 容器的 &lt;code>Namespace&lt;/code> 和 &lt;code>Cgroups&lt;/code>，而不是一个所谓的 &lt;code>Pod&lt;/code> 边界和隔离环境。&lt;/p>
&lt;p>&lt;code>Pod&lt;/code> 其实是一组共享了某些资源的容器。&lt;code>Pod&lt;/code> 里面所有的容器，共享的同一个 &lt;code>Network Namespace&lt;/code>，并且可以声明共享同一个 &lt;code>Volume&lt;/code>.&lt;/p>
&lt;p>&lt;code>Kubernetes&lt;/code> 项目内部，&lt;code>Pod&lt;/code> 实现需要使用一个中间容器，这个容器叫做 &lt;code>Infra&lt;/code> 容器，在 &lt;code>Pod&lt;/code> 中，&lt;code>Infra&lt;/code> 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 &lt;code>Join Network Namespace&lt;/code> 的方式，与 &lt;code>Infra&lt;/code> 容器关联在一起。&lt;/p>
&lt;h2 id="sidecar">&lt;code>sidecar&lt;/code>&lt;/h2>
&lt;h3 id="典型的例子war-包和-web-服务器">典型的例子：WAR 包和 Web 服务器&lt;/h3>
&lt;p>&lt;code>POD&lt;/code>后，将 &lt;code>WAR&lt;/code> 包和 &lt;code>Tomcat&lt;/code> 分别做成镜像，可以把他们容器结合在一起&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#008b45;text-decoration:underline">---&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Pod&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>javaweb-2&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#228b22"># 启动后做了一件事 把应用的WAR包拷贝到 /app目录中，后退出&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">initContainers&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">image&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>sample-war:v2&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>war&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">command&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>[&lt;span style="color:#cd5555">&amp;#34;cp&amp;#34;&lt;/span>,&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;/sample.war&amp;#34;&lt;/span>,&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;/app&amp;#34;&lt;/span>]&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">volumeMounts&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">mountPath&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>/app&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>app-volume&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">containers&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">image&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>tomcat:7.0&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>tomcat&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">command&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>[&lt;span style="color:#cd5555">&amp;#34;sh&amp;#34;&lt;/span>,&lt;span style="color:#cd5555">&amp;#34;-c&amp;#34;&lt;/span>,&lt;span style="color:#cd5555">&amp;#34;/root/apache-tomcat-7.0.42-v2/bin/start.sh&amp;#34;&lt;/span>]&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">volumeMounts&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">mountPath&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>/root/apache-tomcat-7.0.42-v2/webapps&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>app-volume&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">ports&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">containerPort&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b452cd">8080&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">hostPort&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b452cd">8001&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">volumes&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>app-volume&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">emptyDir&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>{}&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008b45;text-decoration:underline">...&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个&lt;code>POD&lt;/code>中，定义了两个容器，第一个容器镜像&lt;code> sample-war:v2&lt;/code>，第二个容器镜像是 &lt;code>Tomcat&lt;/code> 镜像，War包容器的类型不是一个普通容器，是一个 &lt;code>Init Container&lt;/code> 类型的容器。&lt;/p>
&lt;p>在Pod中，所有 &lt;code>Init Container&lt;/code> 定义的容器，都比 &lt;code>spec.containers&lt;/code> 定义的用户容器先启动。并且， &lt;code>Init Container&lt;/code> 容器会按顺序准一启动，而直到他们都启动并且退出了，用户容器才会启动。&lt;/p>
&lt;p>这种组合的方式，正是容器设计模式里面最常用的一种模式：&lt;code>sidecar&lt;/code>&lt;/p>
&lt;h3 id="容器的日志收集">容器的日志收集&lt;/h3>
&lt;p>应用把日志文件输出到容器的 &lt;code>/var/log&lt;/code> 目录中，&lt;code>Pod&lt;/code>的 &lt;code>Volume&lt;/code> 挂载到应用容器的 &lt;code>/var/log&lt;/code> 目录上，然后在这个 &lt;code>Pod&lt;/code> 里的运行一个 &lt;code>sidecar&lt;/code> 容器，也声明挂载同一个 &lt;code>Volume&lt;/code> 到自己的 &lt;code>/var/log&lt;/code> 目录上，
这样这个 &lt;code>sidecar&lt;/code> 容器只需要做一件事，把自己的 &lt;code>/var/log&lt;/code> 目录中读取日志文件，转发就可以了，就是一个基本的日志收集&lt;/p>
&lt;h1 id="pod-对象的基本概念">&lt;code>Pod&lt;/code> 对象的基本概念&lt;/h1>
&lt;p>&lt;code>Pod&lt;/code> 是容器环境的 &lt;code>Kubernetes&lt;/code> 的基本单元，调度、网络、存储、以及安全相关的熟悉，都是属于 &lt;code>Pod&lt;/code> 级别的。&lt;/p>
&lt;p>&lt;code>Pod&lt;/code> 下重要的字段和含义&lt;/p>
&lt;ul>
&lt;li>&lt;code>NodeSelector&lt;/code> : 用户将 &lt;code>Pod&lt;/code> 和 &lt;code>Node&lt;/code> 绑定的字段&lt;/li>
&lt;li>&lt;code>NodeName&lt;/code> : 一旦 &lt;code>Pod&lt;/code> 的这个阻断被赋值，&lt;code>K8S&lt;/code> 会认为这个 &lt;code>Pod&lt;/code> 已经经过调度。&lt;/li>
&lt;li>&lt;code>HostAliases&lt;/code>：定义了 &lt;code>Pod&lt;/code> 的 &lt;code>hosts&lt;/code> 文件（比如 &lt;code>/etc/hosts&lt;/code>）里的内容&lt;/li>
&lt;/ul>
&lt;p>凡是跟容器的 &lt;code>Linux Namespace&lt;/code> 相关的属性，也一定是 &lt;code>Pod&lt;/code> 级别的。
&lt;code>shareProcessNamespace=true&lt;/code>&lt;/p>
&lt;p>&lt;code>Pod&lt;/code> 对象在 &lt;code>Kubernetes&lt;/code> 中的生命周期。&lt;code>Pod&lt;/code> 生命周期的变化，主要体现在 &lt;code>Pod API 对象&lt;/code>的 &lt;code>Status&lt;/code> 部分，这是它除了 &lt;code>Metadata&lt;/code> 和 &lt;code>Spec&lt;/code> 之外的第三个重要字段。其中，&lt;code>pod.status.phase&lt;/code>，就是 &lt;code>Pod&lt;/code> 的当前状态，
它有如下几种可能的情况：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Pending&lt;/code>。这个状态意味着，&lt;code>Pod&lt;/code> 的 &lt;code>YAML&lt;/code> 文件已经提交给了 &lt;code>Kubernetes&lt;/code>，&lt;code>API&lt;/code> 对象已经被创建并保存在 &lt;code>Etcd&lt;/code> 当中。但是，这个 &lt;code>Pod&lt;/code> 里有些容器因为某种原因而不能被顺利创建。比如，调度不成功。&lt;/li>
&lt;li>&lt;code>Running&lt;/code>。这个状态下，&lt;code>Pod&lt;/code> 已经调度成功，跟一个具体的节点绑定。它包含的容器都已经创建成功，并且至少有一个正在运行中。&lt;/li>
&lt;li>&lt;code>Succeeded&lt;/code>。这个状态意味着，&lt;code>Pod&lt;/code> 里的所有容器都正常运行完毕，并且已经退出了。这种情况在运行一次性任务时最为常见。&lt;/li>
&lt;li>&lt;code>Failed&lt;/code>。这个状态下，&lt;code>Pod&lt;/code> 里至少有一个容器以不正常的状态（非 0 的返回码）退出。这个状态的出现，意味着你得想办法 &lt;code>Debug&lt;/code> 这个容器的应用，比如查看 &lt;code>Pod&lt;/code> 的 &lt;code>Events&lt;/code> 和日志。&lt;/li>
&lt;li>&lt;code>Unknown&lt;/code>。这是一个异常状态，意味着 &lt;code>Pod&lt;/code> 的状态不能持续地被 &lt;code>kubelet&lt;/code> 汇报给 &lt;code>kube-apiserver&lt;/code>，这很有可能是主从节点（&lt;code>Master&lt;/code> 和 &lt;code>Kubelet&lt;/code>）间的通信出现了问题。&lt;/li>
&lt;/ul>
&lt;h1 id="kubernetes-其他对象-volume">&lt;code>Kubernetes&lt;/code> 其他对象 &lt;code>Volume&lt;/code>&lt;/h1>
&lt;p>&lt;code>Kubernetes&lt;/code> 支持的 &lt;code>Project Volume&lt;/code> 一共有四种:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Secret&lt;/code> : 把 Pod 想要访问的加密数据，存放到 &lt;code>Etcd&lt;/code> 中，然后通过在 Pod 的容器里挂载 Volume 的方式。&lt;/li>
&lt;li>&lt;code>ConfigMap&lt;/code> : 保存的是不需要加密的、应用所需的配置信息。而 &lt;code>ConfigMap&lt;/code> 的用法几乎与 &lt;code>Secret&lt;/code> 完全相同：你可以使用 &lt;code>kubectl create configmap&lt;/code> 从文件或者目录创建 &lt;code>ConfigMap&lt;/code>，也可以直接编写 &lt;code>ConfigMap&lt;/code> 对象的 &lt;code>YAML&lt;/code> 文件。&lt;/li>
&lt;li>&lt;code>Downward API&lt;/code> : 让 Pod 里的容器能够直接获取到这个&lt;code> Pod API&lt;/code> 对象本身的信息。
&lt;blockquote>
&lt;p>一定是 Pod 里的容器进程启动之前就能够确定下来的信息。而如果你想要获取 Pod 容器运行后才会出现的信息，比如，容器进程的 &lt;code>PID&lt;/code>，那就肯定不能使用 &lt;code>Downward API&lt;/code> 了，而应该考虑在 &lt;code>Pod&lt;/code> 里定义一个 &lt;code>sidecar&lt;/code> 容器。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>&lt;code>ServiceAccountToken&lt;/code> : 这种把 &lt;code>Kubernetes&lt;/code> 客户端以容器的方式运行在集群里，然后使用 &lt;code>default Service Account&lt;/code> 自动授权的方式，被称作“InClusterConfig”.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#008b45;text-decoration:underline">---&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Secret&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>mysecret&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Opaque&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">data&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">user&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>YWRtaW4=&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">pass&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>MWYyZDFlMmU2N2Rm&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008b45;text-decoration:underline">...&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&amp;gt; kubectl create secret
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="容器的健康检查和恢复机制">容器的健康检查和恢复机制&lt;/h1>
&lt;p>&lt;code>Pod&lt;/code> 容器定义了一个健康检查的&amp;quot;探针&amp;quot;（Probe）, 这样kubelet就会根据这个 probe 返回的值决定这个容器的状态，而不是直接以容器镜像十分运行来作为依据。生产环境保证应用健康存活的重要手段。&lt;/p>
&lt;p>&lt;code>Pod&lt;/code> 恢复机制 restartPolicy, 它是 Pod 的 Spec 部分的一个标准字段（&lt;code>pod.spec.restartPolicy&lt;/code>），默认值是 &lt;code>Always&lt;/code>，即：任何时候这个容器发生了异常，它一定会被重新创建。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>pod&lt;/code> 恢复，永远只发生在当前节点，而不会跑到别的节点上去。（不会发生故障转移）需要转移的需要切换到 &lt;code>Deployment&lt;/code> 这样的控制器来管理&lt;code>POD &lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>你还可以通过设置 &lt;code>restartPolicy&lt;/code>，改变 &lt;code>Pod&lt;/code> 的恢复策略。除了 &lt;code>Always&lt;/code>，它还有 &lt;code>OnFailure&lt;/code> 和 &lt;code>Never&lt;/code> 两种情况：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Always&lt;/code>：在任何情况下，只要容器不在运行状态，就自动重启容器；&lt;/li>
&lt;li>&lt;code>OnFailure&lt;/code>: 只在容器 异常时才自动重启容器；&lt;/li>
&lt;li>&lt;code>Never&lt;/code>: 从来不重启容器。&lt;/li>
&lt;/ul>
&lt;h1 id="编排其实很简单-控制器模型">编排其实很简单-&amp;ldquo;控制器&amp;quot;模型&lt;/h1>
&lt;p>前面已经知道 &lt;code>POD&lt;/code> 是一个复杂的&lt;code>API对象&lt;/code>，实际也是对容器的进一步抽象和封装；也就是说&lt;code>Pod对象&lt;/code>是容器的升级版,它对容器的组合，添加了很多的属性和字段。&lt;/p>
&lt;p>&lt;code>Kubernetes&lt;/code>操作&lt;code>POD&lt;/code>是依赖控制器(Controller)完成的。就是 kube-controller-manager 组件&lt;/p>
&lt;p>通过查看 &lt;code>https://github.com/kubernetes/kubernetes/tree/master/pkg/controller&lt;/code> 源代码下能看见这些目录&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">deployment/ job/ podautoscaler/ cloud/ disruption/ namespace/
replicaset/ serviceaccount/ volume/cronjob/ garbagecollector/ nodelifecycle/
replication/ statefulset/ daemon/...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些每个目录都是一种类型的 &lt;code>controller&lt;/code>,各自负责某种编排功能。&lt;/p>
&lt;p>控制循环（control loop）&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">
&lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> {
实际状态 := 获取集群中对象X的实际状态&lt;span style="color:#a61717;background-color:#e3d2d2">（&lt;/span>Actual State&lt;span style="color:#a61717;background-color:#e3d2d2">）&lt;/span>
期望状态 := 获取集群中对象X的期望状态&lt;span style="color:#a61717;background-color:#e3d2d2">（&lt;/span>Desired State&lt;span style="color:#a61717;background-color:#e3d2d2">）&lt;/span>
&lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> 实际状态 == 期望状态{
什么都不做
} &lt;span style="color:#8b008b;font-weight:bold">else&lt;/span> {
执行编排动作&lt;span style="color:#a61717;background-color:#e3d2d2">，&lt;/span>将实际状态调整为期望状态
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>具体实现时候，&lt;code>实际状态&lt;/code>来自于&lt;code>Kubernetes&lt;/code> 集群本身，&lt;code>期望状态&lt;/code>来自于用户提交的 &lt;code>YAML&lt;/code> 文件。&lt;/p>
&lt;blockquote>
&lt;p>比如&lt;/p>
&lt;ul>
&lt;li>&lt;code>Deployment控制器&lt;/code>从&lt;code>Etcd&lt;/code>中获取到目标标签的 &lt;code>POD&lt;/code>，然后统计他们的数量，这是实际状态；&lt;/li>
&lt;li>&lt;code>Deployment对象&lt;/code>的 &lt;code>Replicas&lt;/code> 字段的值是期望状态；&lt;/li>
&lt;li>&lt;code>Deployment控制器&lt;/code>将两个状态做比较，然后根据比较结果，确定创建&lt;code>POD&lt;/code>还是删除已经存在的&lt;code>POD&lt;/code>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>这个操作叫做协调（&lt;code>Reconcile&lt;/code>）即 控制循环&lt;/p>
&lt;blockquote>
&lt;p>为什么是循环，因为事件往往是一次性的，如果操作失败比较难处理，但是控制器循环一直尝试，更符合 Kubernetes 声明式API，最终达成一致。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://pinkhello.me/%E5%9B%9E%E6%9C%9BK8S/deployment.png" alt="deployment结构">&lt;/p>
&lt;p>上半部分的控制器定义（包含期望状态），下面的部分被控制对象的模板组成的。&lt;/p>
&lt;h1 id="作业副本和水平扩展">作业副本和水平扩展&lt;/h1>
&lt;h2 id="pod-的水平扩展--收缩horizontal-scaling-outin">Pod 的“水平扩展 / 收缩”（horizontal scaling out/in）&lt;/h2>
&lt;p>如果我们更新了 &lt;code>Deployment&lt;/code> 的 &lt;code>Pod&lt;/code> 模板（假如更新了容器镜像），那么 &lt;code>Deployment&lt;/code> 需要遵循一种 &amp;ldquo;滚动更新&amp;rdquo;（&lt;code>rolling update&lt;/code>）的方式来升级现有的容器。这也是 &lt;code>kubernetes&lt;/code> 重要的概念（API对象）：&lt;code>ReplicaSet&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>apps/v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>ReplicaSet&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx-set&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">labels&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">app&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">replicas&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b452cd">3&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">selector&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">matchLabels&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">app&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">template&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">labels&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">app&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">containers&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">image&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx:1.7.9&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一个 &lt;code>ReplicaSet&lt;/code>对象，由 副本数目的定义和一个Pod模板组成的。它其实是 &lt;code>Deployment&lt;/code> 的子集。而且，&lt;code>Deployment控制器&lt;/code>操作的正是 &lt;code>ReplicaSet&lt;/code> 对象，而不是&lt;code>Pod对象&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">kubectl scale
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://pinkhello.me/%E5%9B%9E%E6%9C%9BK8S/replicaset.jpg" alt="ReplicaSet结构">&lt;/p>
&lt;h2 id="滚动更新">滚动更新&lt;/h2>
&lt;p>将一个集群中正在运行的多个 &lt;code>Pod&lt;/code> 版本，交替地逐一升级的过程，就是“滚动更新”。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>依赖 &lt;code>health check&lt;/code> 机制&lt;/li>
&lt;li>保证服务的连续性&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://pinkhello.me/%E5%9B%9E%E6%9C%9BK8S/deployment-replicaset-pod.jpg" alt="DeploymentReplicaSet">&lt;/p>
&lt;p>&lt;code>Deployment&lt;/code> 实际上是一个两层控制器。首先，它通过 &lt;code>ReplicaSet&lt;/code> 的个数来描述应用的版本；然后，它再通过 &lt;code>ReplicaSet&lt;/code> 的属性（比如 &lt;code>replicas&lt;/code> 的值），来保证 &lt;code>Pod&lt;/code> 的副本数量。&lt;/p>
&lt;h1 id="深入理解statefulset">深入理解StatefulSet&lt;/h1>
&lt;ul>
&lt;li>拓扑状态：应用间不完全对等，需要谁先启动，谁后启动，必须按照某些顺序来启动。（在&lt;code>Pod&lt;/code>删除和再创建中保持稳定）&lt;/li>
&lt;li>存储状态：多个实例绑定了不同的存储数据，一个数据库应用的多个存储实例&lt;/li>
&lt;/ul>
&lt;h2 id="拓扑状态">拓扑状态&lt;/h2>
&lt;p>StatefulSet 核心功能：通过某种方式纪录这些状态，等POD被重新创建时候，能够为新的POD恢复状态。&lt;/p>
&lt;p>Headless Service&lt;/p>
&lt;p>Service 是 Kubernetes 项目中用来将一组 Pod 暴露给外界访问的一种机制。比如，一个 &lt;code>Deployment&lt;/code> 有 &lt;code>3&lt;/code> 个 &lt;code>Pod&lt;/code>，那么我就可以定义一个 &lt;code>Service&lt;/code>。然后，用户只要能访问到这个 &lt;code>Service&lt;/code>，它就能访问到某个具体的 &lt;code>Pod&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>第一种方式，是以 &lt;code>Service&lt;/code> 的 &lt;code>VIP&lt;/code>（&lt;code>Virtual IP&lt;/code>，即：虚拟 IP）方式。&lt;/li>
&lt;li>第二种方式，就是以 &lt;code>Service&lt;/code> 的 &lt;code>DNS&lt;/code> 方式, 比如 只要我访问“&lt;code>my-svc.my-namespace.svc.cluster.local&lt;/code>”这条 DNS 记录，就可以访问到名叫 &lt;code>my-svc&lt;/code> 的 &lt;code>Service&lt;/code> 所代理的某一个 &lt;code>Pod&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Service DNS&lt;/code> 下两种处理方法&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Normal Service&lt;/code>。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，正是 my-svc 这个 Service 的 VIP，后面的流程就跟 VIP 方式一致了。
&lt;code>Headless Service&lt;/code>。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，直接就是 my-svc 代理的某一个 Pod 的 IP 地址。可以看到，这里的区别在于，Headless Service 不需要分配一个 VIP，而是可以直接以 DNS 记录的方式解析出被代理 Pod 的 IP 地址。&lt;/p>
&lt;/blockquote>
&lt;p>Headless Service Yaml&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Service&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">labels&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">app&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">ports&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">port&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b452cd">80&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>web&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">clusterIP&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>None&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">selector&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">app&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>StatefulSet Yaml&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>apps/v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>StatefulSet&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>web&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># 多了这个 ServiceName 就是告诉 StatefulSet 控制器，在执行控制循环（Control Loop）的时候，请使用 nginx 这个 Headless Service 来保证 Pod 的“可解析身份”。&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">serviceName&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;nginx&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">replicas&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b452cd">2&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">selector&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">matchLabels&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">app&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">template&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">labels&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">app&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">containers&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">image&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx:1.9.1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">ports&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">containerPort&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b452cd">80&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>web&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>，对于“有状态应用”实例的访问，你必须使用 &lt;code>DNS 记录&lt;/code>或者 &lt;code>hostname&lt;/code> 的方式，而绝不应该直接访问这些 &lt;code>Pod&lt;/code> 的 IP 地址。&lt;/p>
&lt;h2 id="存储状态">存储状态&lt;/h2>
&lt;p>&lt;code>StatefulSet&lt;/code> 存储状态的管理机制，主要使用的是一个叫做 &lt;code>Persistent Volume Claim&lt;/code> 功能。&lt;/p>
&lt;p>要在一个 Pod 里面声明 Volume，只要在 Pod 里加上 &lt;code>spec.volumes&lt;/code> 字段，然后就可以在这个字段里面定义一个具体的类型的 &lt;code>Volume&lt;/code>。比如 &lt;code>hostPath&lt;/code>。&lt;/p>
&lt;p>&lt;code>Kubernetes&lt;/code> 项目引入了一组叫作 &lt;code>Persistent Volume Claim&lt;/code>（PVC）和 &lt;code>Persistent Volume&lt;/code>（PV）的 API 对象，大大降低了用户声明和使用持久化 &lt;code>Volume&lt;/code> 的门槛。&lt;/p>
&lt;p>使用PVC的两步：&lt;/p>
&lt;ul>
&lt;li>定义一个 &lt;code>PVC&lt;/code>，声明想要的 &lt;code>Volume&lt;/code> 属性&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>PersistentVolumeClaim&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>pv-claim&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">accessModes&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- ReadWriteOnce&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># 挂载方式：可读写，并且只能被挂载在一个节点上，非多个节点共享&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">resources&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">requests&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">storage&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>1Gi &lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22">#存储大小&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>在应用 &lt;code>POD&lt;/code> 中，使用这个 &lt;code>PVC&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Pod&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>pv-pod&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">containers&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>pv-container&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">image&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">ports&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">containerPort&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b452cd">80&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;http-server&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">volumeMounts&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">mountPath&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;/usr/share/nginx/html&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>pv-storage&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">volumes&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>pv-storage&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">persistentVolumeClaim&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">claimName&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>pv-claim&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># 指定上面的PVC的名字&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面来看，这个 &lt;code>Volume&lt;/code> 又从何而来呢？（运维人员维护的 &lt;code>PV&lt;/code>）&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#228b22"># 这个 PV 对象的 spec.rbd 字段，正是我们前面介绍过的 Ceph RBD Volume 的详细定义。而且，它还声明了这个 PV 的容量是 10 GiB。这样，Kubernetes 就会为我们刚刚创建的 PVC 对象绑定这个 PV&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>PersistentVolume&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>pv-volume&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">labels&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">type&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>local&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">capacity&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">storage&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>10Gi&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">accessModes&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- ReadWriteOnce&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">rbd&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">monitors&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># 使用 kubectl get pods -n rook-ceph 查看 rook-ceph-mon- 开头的 POD IP 即可得下面的列表&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#cd5555">&amp;#39;10.16.154.78:6789&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#cd5555">&amp;#39;10.16.154.82:6789&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#cd5555">&amp;#39;10.16.154.83:6789&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">pool&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>kube&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">image&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>foo&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">fsType&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>ext4&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">readOnly&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">true&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">user&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>admin&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">keyring&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>/etc/ceph/keyring&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以 &lt;code>Kubernetes&lt;/code> 中的 &lt;code>PVC&lt;/code> 和 &lt;code>PV&lt;/code> 的设计，类似于 &amp;ldquo;接口&amp;rdquo; 和 &amp;ldquo;实现&amp;rdquo; 的思想，这种解耦，避免了暴露系统更多的细节，也是职责的分离，更容易定位问题&lt;/p>
&lt;h2 id="statefulset-的工作原理">StatefulSet 的工作原理&lt;/h2>
&lt;ul>
&lt;li>&lt;code>StatefulSet&lt;/code> 控制器直接管理的是 &lt;code>POD&lt;/code>&lt;/li>
&lt;li>&lt;code>Kubernetes&lt;/code> 通过 &lt;code>Headless Service&lt;/code> 为这些有编号的 &lt;code>POD&lt;/code>。在 &lt;code>DNS&lt;/code> 服务器众生成同样带有编号的 &lt;code>DNS纪录&lt;/code>。只要 &lt;code>StatefulSet&lt;/code> 能够保证这些 &lt;code>POD&lt;/code> 的名字编号不变，类似 &amp;ldquo;&lt;code>web-0.default.svc.cluster.local&lt;/code>&amp;rdquo; 这样的 &lt;code>DNS纪录&lt;/code> 就不会变，而这条纪录解析出来的&lt;code>POD&lt;/code>的&lt;code>IP&lt;/code>地址，会随着&lt;code>后端的POD删除和再创建&lt;/code>而更新。&lt;/li>
&lt;li>&lt;code>StatefulSet&lt;/code> 还为每个 &lt;code>POD&lt;/code> 分配并创建一个同样编号的 &lt;code>PVC&lt;/code>，这样 &lt;code>Kubernetes&lt;/code> 可以通过 &lt;code>Persistent Volume&lt;/code> 机制为这个 &lt;code>PVC&lt;/code> 绑定对应的 &lt;code>PV&lt;/code>，保证一个&lt;code>POD&lt;/code>都有一个独立的 &lt;code>Volume&lt;/code>（即使&lt;code>POD&lt;/code>被删除，但是对应的 &lt;code>PVC&lt;/code> 和 &lt;code>PV&lt;/code> 保留下来，重新创建&lt;code>POD&lt;/code>的时候，还会找回来，数据还存在）&lt;/li>
&lt;/ul>
&lt;h1 id="容器化守护进程的意义-daemonset">容器化守护进程的意义 DaemonSet&lt;/h1>
&lt;p>&lt;code>DaemonSet&lt;/code> 主要的作用: 在&lt;code>Kubernetes&lt;/code>集群里运行一个 &lt;code>Daemon Pod&lt;/code>,这个&lt;code>Pod&lt;/code>三个特征&lt;/p>
&lt;ul>
&lt;li>每个&lt;code>Kubernetes&lt;/code>节点都会运行一个这样的&lt;code>POD&lt;/code>&lt;/li>
&lt;li>每个节点上只有一个这样的 &lt;code>Pod&lt;/code> 实例&lt;/li>
&lt;li>当有新的节点加入 &lt;code>Kuberntes&lt;/code> 集群后，该 &lt;code>Pod&lt;/code> 会自动的在新的节点上被创建出来，而当旧节点被删除后, 它上面的 Pod 也会相应地被回收掉。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>eg：&lt;/p>
&lt;ul>
&lt;li>网络插件的 Agent 组件，必须运行在每个节点上，用来处理容器的网络&lt;/li>
&lt;li>存储插件 Agent 组件，必须运行在每个节点上，用来挂载远程存储目录，操作容器的 Volume 目录&lt;/li>
&lt;li>监控组件 以及 日志组件，也是一样，负责节点的监控信息和日志收集&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>跟其他编排不一样，DaemonSet 开始运行的时机，很多时候比整个 Kubernetes 集群出现的还要早。比如容器网络组件，在所有的 Worker节点状态都是 NotReady。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#228b22"># fluentd-elasticsearch 镜像POD， 通过 Fluentd 将 Docker 容器日志转发到 ES 内。&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>apps/v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>DaemonSet&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>fluentd-elasticsearch&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">namespace&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>kube-system&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">labels&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">k8s-app&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>fluentd-logging&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">selector&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">matchLabels&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>fluentd-elasticsearch&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">template&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">labels&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>fluentd-elasticsearch&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">tolerations&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">key&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>node-role.kubernetes.io/master&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">effect&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>NoSchedule&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">containers&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>fluentd-elasticsearch&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">image&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>k8s.gcr.io/fluentd-elasticsearch:1.20&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">resources&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">limits&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">memory&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>200Mi&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">requests&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">cpu&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>100m&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">memory&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>200Mi&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># 挂载了两个hostPath类型 的 Volume &lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">volumeMounts&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>varlog&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">mountPath&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>/var/log&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># Docker 容器里应用的日志，默认会保存在宿主机的 /var/lib/docker/containers/{{. 容器 ID}}/{{. 容器 ID}}-json.log 文件里，所以这个目录正是 fluentd 的搜集目标 &lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>varlibdockercontainers&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">mountPath&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>/var/lib/docker/containers&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">readOnly&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">true&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">terminationGracePeriodSeconds&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b452cd">30&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">volumes&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>varlog&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">hostPath&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">path&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>/var/log&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>varlibdockercontainers&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">hostPath&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">path&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>/var/lib/docker/containers&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>DaemonSet Controller&lt;/code>，首先从 &lt;code>Etcd&lt;/code> 里获取所有的 &lt;code>Node&lt;/code> 列表，然后遍历所有的 &lt;code>Node&lt;/code>。这时就会去检查这个&lt;code>Node&lt;/code>上是不是已经存在携带了 &lt;code>name=fluentd-elasticsearch&lt;/code> 的 &lt;code>POD&lt;/code> 在运行了&lt;/p>
&lt;ul>
&lt;li>没有这个POD，则创建一个新的 POD&lt;/li>
&lt;li>有这种POD，数量 &amp;gt; 1, 删除多余的&lt;/li>
&lt;li>正好一个，节点正常&lt;/li>
&lt;/ul>
&lt;p>&lt;code>DaemonSet&lt;/code> 会自动加上 &lt;code>tolerations&lt;/code>字段&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Pod&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>with-toleration&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># “容忍”所有被标记为 unschedulable“污点”的 Node；“容忍”的效果是允许调度。&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">tolerations&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">key&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>node.kubernetes.io/unschedulable&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">operator&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Exists&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">effect&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>NoSchedule&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在正常情况下，被标记了 unschedulable“污点”的 Node，是不会有任何 Pod 被调度上去的（effect: NoSchedule）。可是，DaemonSet 自动地给被管理的 Pod 加上了这个特殊的 Toleration，就使得这些 Pod 可以忽略这个限制，继而保证每个节点上都会被调度一个 Pod。当然，如果这个节点有故障的话，这个 Pod 可能会启动失败，而 DaemonSet 则会始终尝试下去，直到 Pod 启动成功。&lt;/p>
&lt;h1 id="离线业务-job-与-cronjob">离线业务 Job 与 CronJob&lt;/h1>
&lt;p>像在线业务诸如应用一类的，抽离了描述离线业务的API对象：Job&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>batch/v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Job&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>pi&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">template&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">containers&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>pi&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">image&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>resouer/ubuntu-bc &lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">command&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>[&lt;span style="color:#cd5555">&amp;#34;sh&amp;#34;&lt;/span>,&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;-c&amp;#34;&lt;/span>,&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;echo &amp;#39;scale=10000; 4*a(1)&amp;#39; | bc -l &amp;#34;&lt;/span>]&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">restartPolicy&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Never&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">backoffLimit&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b452cd">4&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">
$ kubectl describe jobs/pi
Name: pi
Namespace: default
Selector: controller-uid=c2db599a-2c9d-11e6-b324-0209dc45a495
Labels: controller-uid=c2db599a-2c9d-11e6-b324-0209dc45a495
job-name=pi
Annotations: &amp;lt;none&amp;gt;
Parallelism: &lt;span style="color:#b452cd">1&lt;/span>
Completions: &lt;span style="color:#b452cd">1&lt;/span>
..
Pods Statuses: &lt;span style="color:#b452cd">0&lt;/span> Running / &lt;span style="color:#b452cd">1&lt;/span> Succeeded / &lt;span style="color:#b452cd">0&lt;/span> Failed
Pod Template:
Labels: controller-uid=c2db599a-2c9d-11e6-b324-0209dc45a495
job-name=pi
Containers:
...
Volumes: &amp;lt;none&amp;gt;
Events:
FirstSeen LastSeen Count From SubobjectPath Type Reason Message
--------- -------- ----- ---- ------------- -------- ------ -------
1m 1m &lt;span style="color:#b452cd">1&lt;/span> {job-controller } Normal SuccessfulCreate Created pod: pi-rq5rl
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个 Job 对象在创建后，它的 Pod 模板，被自动加上了一个 controller-uid=&amp;lt; 一个随机字符串 &amp;gt; 这样的 Label。而这个 Job 对象本身，则被自动加上了这个 Label 对应的 Selector，从而 保证了 Job 与它所管理的 Pod 之间的匹配关系。而 Job Controller 之所以要使用这种携带了 UID 的 Label，就是为了避免不同 Job 对象所管理的 Pod 发生重合。&lt;/p>
&lt;p>如果作业失败了怎么办？&lt;/p>
&lt;p>定义了 restartPolicy=Never，那么离线作业失败后 Job Controller 就会不断地尝试创建一个新 Pod
我们就在 Job 对象的 spec.backoffLimit 字段里定义了重试次数为 4（即，backoffLimit=4），而这个字段的默认值是 6。
定义的 restartPolicy=OnFailure，那么离线作业失败后，Job Controller 就不会去尝试创建新的 Pod。但是，它会不断地尝试重启 Pod 里的容器&lt;/p>
&lt;p>Job 对象中，并行作业的控制方法&lt;/p>
&lt;ul>
&lt;li>1、spec.parallelism，它定义的是一个 Job 在任意时间最多可以启动多少个 Pod 同时运行；&lt;/li>
&lt;li>2、spec.completions，它定义的是 Job 至少要完成的 Pod 数目，即 Job 的最小完成数。&lt;/li>
&lt;/ul>
&lt;h2 id="常用的使用-job对象的方法">常用的使用 Job对象的方法&lt;/h2>
&lt;ul>
&lt;li>外部管理器 + Job模板 （sed）&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>batch/v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Job&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># 带遍历替换&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>process-item-$ITEM&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">labels&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">jobgroup&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>jobexample&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">template&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>jobexample&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">labels&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">jobgroup&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>jobexample&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">containers&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>c&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">image&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>busybox&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">command&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>[&lt;span style="color:#cd5555">&amp;#34;sh&amp;#34;&lt;/span>,&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;-c&amp;#34;&lt;/span>,&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;echo Processing item $ITEM &amp;amp;&amp;amp; sleep 5&amp;#34;&lt;/span>]&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">restartPolicy&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>Never&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>拥有固定任务数目的并行Job&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指定并行度（parallelism），但不设置固定的 completions 的值。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="cronjob-对象">CronJob 对象&lt;/h2>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>batch/v1beta1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>CronJob&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>hello&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#228b22"># cron &lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">schedule&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;*/1 * * * *&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">jobTemplate&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">template&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">containers&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#8b008b;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>hello&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">image&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>busybox&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">args&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- /bin/sh&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- -c&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- date; echo Hello from the Kubernetes cluster&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">restartPolicy&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>OnFailure&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CronJob 是专门管理 Job 对象的控制其。只不过它的创建和删除Job依据是根据
schedule 字段来定义的。&lt;/p>
&lt;p>在 定时任务的时候，可能有任务未执行完毕，就下面的Pod启动&lt;/p>
&lt;ul>
&lt;li>concurrencyPolicy=Allow，这也是默认情况，这意味着这些 Job 可以同时存在；&lt;/li>
&lt;li>concurrencyPolicy=Forbid，这意味着不会创建新的 Pod，该创建周期被跳过；&lt;/li>
&lt;li>concurrencyPolicy=Replace，这意味着新产生的 Job 会替换旧的、没有执行完的 Job。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#228b22"># startingDeadlineSeconds=200，意味着在过去 200 s 里，如果 miss 的数目达到了 100 次，那么这个 Job 就不会被创建执行了&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>spec.startingDeadlineSeconds 时间窗口&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>- https://pinkhello.me/posts/20-%E5%9B%9E%E6%9C%9Bk8s-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8Ekubernetes%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/ - PinkHello, All Rights Reserved</description></item><item><title>回望K8S Kubernetes拼图</title><link>https://pinkhello.me/posts/19-%E5%9B%9E%E6%9C%9Bk8s-kubernetes%E6%8B%BC%E5%9B%BE/</link><pubDate>Sun, 16 Feb 2020 20:57:38 +0800</pubDate><guid>https://pinkhello.me/posts/19-%E5%9B%9E%E6%9C%9Bk8s-kubernetes%E6%8B%BC%E5%9B%BE/</guid><description>PinkHello https://pinkhello.me/posts/19-%E5%9B%9E%E6%9C%9Bk8s-kubernetes%E6%8B%BC%E5%9B%BE/ -&lt;h1 id="kubernetes-安装">&lt;code>kubernetes&lt;/code> 安装&lt;/h1>
&lt;h2 id="all-节点安装-docker-和-kubeadm">all 节点安装 &lt;code>Docker&lt;/code> 和 &lt;code>Kubeadm&lt;/code>&lt;/h2>
&lt;p>所有节点 &lt;code>root&lt;/code> 用户下操作&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&amp;gt; curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
&amp;gt; cat &lt;span style="color:#cd5555">&amp;lt;&amp;lt;EOF &amp;gt; /etc/apt/sources.list.d/kubernetes.list
&lt;/span>&lt;span style="color:#cd5555">deb http://apt.kubernetes.io/ kubernetes-xenial main
&lt;/span>&lt;span style="color:#cd5555">EOF&lt;/span>
&amp;gt; apt-get update
&lt;span style="color:#228b22"># 这一步安装的时候 kubeadm 和 kubelet、kubectl、kubernetes-cni 都会自动安装完毕&lt;/span>
&amp;gt; apt-get install -y docker.io kubeadm
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>提示：如果 &lt;code>apt.kubernetes.io&lt;/code> 因为网络问题访问不到，可以换成中科大的 &lt;code>Ubuntu&lt;/code> 镜像源 deb &lt;a href="http://mirrors.ustc.edu.cn/kubernetes/apt">http://mirrors.ustc.edu.cn/kubernetes/apt&lt;/a> kubernetes-xenial main。&lt;/p>
&lt;/blockquote>
&lt;h2 id="部署-kubernetes-master">部署 &lt;code>Kubernetes&lt;/code> &lt;code>Master&lt;/code>&lt;/h2>
&lt;p>声明一个 &lt;code>kubeadm.yaml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#008b45;text-decoration:underline">---&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>kubeadm.k8s.io/v1alpha1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>MasterConfiguration&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">controllerManagerExtraArgs&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#228b22"># 配置了自定义自动水平扩展&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">horizontal-pod-autoscaler-use-rest-clients&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">horizontal-pod-autoscaler-sync-period&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;10s&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">node-monitor-grace-period&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;10s&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">apiServerExtraArgs&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#8b008b;font-weight:bold">runtime-config&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;api/all=true&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#228b22"># kubeadm 部署的 kubernetes 的版本&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">kubernetesVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#cd5555">&amp;#34;stable-1.11&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>···&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行下面的指令，完成 &lt;code>kubernetes&lt;/code> &lt;code>master&lt;/code> 部署，这回生成一行指令&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&amp;gt; kubeadm init --config kubeadm.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">kubeadm join 10.168.0.2:6443 --token 00bwbx.uvnaa2ewjflwu1ry --discovery-token-ca-cert-hash sha256:00eb62a2a6020f94132e3fe1ab721349bbcd3e9b94da9654cfe15f2985ebd711
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个 &lt;code>kubeadm join&lt;/code> 命令, 用来给这个 &lt;code>Master&lt;/code> 节点添加更多的 &lt;code>Worker&lt;/code> 节点.&lt;/p>
&lt;p>另外 &lt;code>kubeadm&lt;/code> 会提示我们第一次使用 &lt;code>kubernetes&lt;/code> 集群所需要的配置命令:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&amp;gt; mkdir -p &lt;span style="color:#00688b">$HOME&lt;/span>/.kube
&amp;gt; sudo cp -i /etc/kubernetes/admin.conf &lt;span style="color:#00688b">$HOME&lt;/span>/.kube/config
&amp;gt; sudo chown &lt;span style="color:#8b008b;font-weight:bold">$(&lt;/span>id -u&lt;span style="color:#8b008b;font-weight:bold">)&lt;/span>:&lt;span style="color:#8b008b;font-weight:bold">$(&lt;/span>id -g&lt;span style="color:#8b008b;font-weight:bold">)&lt;/span> &lt;span style="color:#00688b">$HOME&lt;/span>/.kube/config
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为 &lt;code>Kubernetes&lt;/code> 集群默认需要加密方式访问，所以，需要将刚刚部署生成的 &lt;code>kubernetes&lt;/code> 集群安全配置文件，保存到当前用户的 &lt;code>.kube&lt;/code> 目录下, &lt;code>kubectl&lt;/code> 默认会使用这个目录下的授权信息进行访问&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#228b22">#查看kubernetes集群的节点状态&lt;/span>
&amp;gt; kubectl get nodes
NAME STATUS ROLES AGE VERSION
master NotReady master 1d v1.11.1
&lt;span style="color:#228b22"># NotReady 因为还没有部署任何网络插件&lt;/span>
&amp;gt; kubectl describe node master
...
Conditions:
...
Ready False ... KubeletNotReady runtime network not ready: &lt;span style="color:#00688b">NetworkReady&lt;/span>=&lt;span style="color:#658b00">false&lt;/span> reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&amp;gt; kubectl get pods -n kube-system
NAME READY STATUS RESTARTS AGE
coredns-78fcdf6894-j9s52 0/1 Pending &lt;span style="color:#b452cd">0&lt;/span> 1h
coredns-78fcdf6894-jm4wf 0/1 Pending &lt;span style="color:#b452cd">0&lt;/span> 1h
etcd-master 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 2s
kube-apiserver-master 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 1s
kube-controller-manager-master 0/1 Pending &lt;span style="color:#b452cd">0&lt;/span> 1s
kube-proxy-xbd47 1/1 NodeLost &lt;span style="color:#b452cd">0&lt;/span> 1h
kube-scheduler-master 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 1s
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="部署-容器网络插件">部署 容器网络插件&lt;/h2>
&lt;p>在 &lt;code>kubernetes&lt;/code> 内部里面 &lt;code>一切皆容器&lt;/code> 设计方式，部署网络插件非常简单,以 &lt;code>Weave&lt;/code> 为例子&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&amp;gt; kubectl apply -f https://git.io/weave-kube-1.6
&lt;/code>&lt;/pre>&lt;/div>&lt;p>部署完毕后, 通过 &lt;code>kubectl get&lt;/code> 检查 &lt;code>POD&lt;/code> 状态&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&amp;gt; kubectl get pods -n kube-system
NAME READY STATUS RESTARTS AGE
coredns-78fcdf6894-j9s52 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 1d
coredns-78fcdf6894-jm4wf 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 1d
etcd-master 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 9s
kube-apiserver-master 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 9s
kube-controller-manager-master 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 9s
kube-proxy-xbd47 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 1d
kube-scheduler-master 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 9s
weave-net-cmk27 2/2 Running &lt;span style="color:#b452cd">0&lt;/span> 19s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>而刚刚部署的 &lt;code>Weave&lt;/code> 网络插件则在 &lt;code>kube-system&lt;/code> 下面新建了一个名叫 &lt;code>weave-net-cmk27&lt;/code> 的 &lt;code>Pod&lt;/code>，一般来说，这些 &lt;code>Pod&lt;/code> 就是容器网络插件在每个节点上的控制组件。&lt;/p>
&lt;p>&lt;code>Kubernetes&lt;/code> 的支持的容器网络插件，使用的 &lt;code>CNI&lt;/code> 的通用接口，当前开源的容器网络插件有&lt;/p>
&lt;ul>
&lt;li>&lt;code>Flannel&lt;/code> 这个采用应该比较多的&lt;/li>
&lt;li>&lt;code>Calico&lt;/code>&lt;/li>
&lt;li>&lt;code>Canal&lt;/code>&lt;/li>
&lt;li>&lt;code>Romana&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="部署-kubernetes-worker">部署 &lt;code>Kubernetes&lt;/code> &lt;code>Worker&lt;/code>&lt;/h2>
&lt;p>&lt;code>Worker&lt;/code> 节点的部署 和 &lt;code>Master&lt;/code> 节点的运行的程序几乎相同, 都运行这 &lt;code>kubelet&lt;/code> 组件，唯一的区别是 &lt;code>kubelet&lt;/code> 启动后，&lt;code>Master&lt;/code> 节点需要自动运行 &lt;code>kube-apiserver&lt;/code>，&lt;code>kube-scheduler&lt;/code>，&lt;code>kube-controller-manager&lt;/code> 三个 &lt;code>Pod&lt;/code>&lt;/p>
&lt;p>执行部署&lt;code>Master&lt;/code>时候生成的 &lt;code>kubeadm join&lt;/code> 指令&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&amp;gt; kubeadm join 10.168.0.2:6443 --token 00bwbx.uvnaa2ewjflwu1ry --discovery-token-ca-cert-hash sha256:00eb62a2a6020f94132e3fe1ab721349bbcd3e9b94da9654cfe15f2985ebd711
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过 &lt;code>Taint/Toleration&lt;/code> 调整 &lt;code>Master&lt;/code> 执行 &lt;code>Pod&lt;/code> 的策略&lt;/p>
&lt;blockquote>
&lt;p>默认情况下 &lt;code>Master&lt;/code> 节点是不允许运行用户 &lt;code>Pod&lt;/code> 的。而 &lt;code>Kubernetes&lt;/code> 做到这一点，依靠的是 &lt;code>Kubernetes&lt;/code> 的 Taint/Toleration 机制。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>它的原理非常简单：一旦某个节点被加上了一个 Taint，即被“打上了污点”，那么所有 Pod 就都不能在这个节点上运行，因为 Kubernetes 的 Pod 都有“洁癖”。除非，有个别的 Pod 声明自己能“容忍”这个“污点”，即声明了 Toleration，它才可以在这个节点上运行。其中，为节点打上“污点”（Taint）的命令是：kubectl taint nodes node1 foo=bar:NoSchedule&lt;/p>
&lt;/blockquote>
&lt;p>默认情况下 &lt;code>Master&lt;/code> 节点是不允许运行用户 &lt;code>Pod&lt;/code> 的, 可以通过 &lt;code>kubectl describe&lt;/code> 检查一下 &lt;code>Master&lt;/code> 节点的 &lt;code>Taint&lt;/code> 字段&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&amp;gt; kubectl describe node master
Name: master
Roles: master
Taints: node-role.kubernetes.io/master:NoSchedule
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，&lt;code>Master&lt;/code> 节点默认被加上了 &lt;code>node-role.kubernetes.io/master:NoSchedule&lt;/code> 这样一个“污点”，其中“键”是 &lt;code>node-role.kubernetes.io/master&lt;/code>，而没有提供“值”。&lt;/p>
&lt;p>当然，如果你就是想要一个单节点的 &lt;code>Kubernetes&lt;/code>，删除这个 &lt;code>Taint&lt;/code> 才是正确的选择：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#228b22"># “node-role.kubernetes.io/master”这个键后面加上了一个短横线“-”，这个格式就意味着移除所有以“node-role.kubernetes.io/master”为键的 Taint。&lt;/span>
&amp;gt; kubectl taint nodes --all node-role.kubernetes.io/master-
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="部署-dashboard-可视化插件">部署 &lt;code>Dashboard&lt;/code> 可视化插件&lt;/h2>
&lt;p>&lt;code>Web&lt;/code> 页面展示也是一个很重要的方面，能可视化的查看集群的各种信息&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&amp;gt; kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-rc6/aio/deploy/recommended.yaml
&amp;gt; kubectl get pods -n kube-system
kubernetes-dashboard-6948bdb78-f67xk 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 1m
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Dashboard&lt;/code> 项目部署完成后，默认只能通过 &lt;code>Proxy&lt;/code> 的方式在本地访问&lt;/p>
&lt;h2 id="部署-容器存储插件">部署 容器存储插件&lt;/h2>
&lt;p>&lt;code>Kubernetes&lt;/code> 松耦合的设计，所以绝大多数存储项目都可以为 &lt;code>Kubernetes&lt;/code> 提供持久化存储能力.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Ceph&lt;/code>&lt;/li>
&lt;li>&lt;code>GlusterFS&lt;/code>&lt;/li>
&lt;li>&lt;code>NFS&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Rook&lt;/code> 插件是基于 &lt;code>Ceph&lt;/code> 的 &lt;code>Kubernetes&lt;/code> 存储插件，&lt;code>Rook&lt;/code> 在自己的实现中加入了水平扩展、迁移、灾备、监控等大量的企业级功能，这是一个完整的，可以应用在生产上的容器存储插件&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&amp;gt; kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/common.yaml
&amp;gt; kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/operator.yaml
&amp;gt; kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/cluster.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在部署完成后，你就可以看到 &lt;code>Rook&lt;/code> 项目会将自己的 &lt;code>Pod&lt;/code> 放置在由它自己管理的两个 &lt;code>Namespace&lt;/code> 当中：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&amp;gt; kubectl get pods -n rook-ceph-system
NAME READY STATUS RESTARTS AGE
rook-ceph-agent-7cv62 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 15s
rook-ceph-operator-78d498c68c-7fj72 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 44s
rook-discover-2ctcv 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 15s
&amp;gt; kubectl get pods -n rook-ceph
NAME READY STATUS RESTARTS AGE
rook-ceph-mon0-kxnzh 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 13s
rook-ceph-mon1-7dn2t 1/1 Running &lt;span style="color:#b452cd">0&lt;/span> 2s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样，一个基于 &lt;code>Rook&lt;/code> 持久化存储集群就以容器的方式运行起来了，而接下来在 &lt;code>Kubernetes&lt;/code> 项目上创建的所有 &lt;code>Pod&lt;/code> 就能够通过 &lt;code>Persistent Volume&lt;/code>（PV）和 &lt;code>Persistent Volume Claim&lt;/code>（PVC）的方式，在容器里挂载由 &lt;code>Ceph&lt;/code> 提供的数据卷了。&lt;/p>
- https://pinkhello.me/posts/19-%E5%9B%9E%E6%9C%9Bk8s-kubernetes%E6%8B%BC%E5%9B%BE/ - PinkHello, All Rights Reserved</description></item></channel></rss>