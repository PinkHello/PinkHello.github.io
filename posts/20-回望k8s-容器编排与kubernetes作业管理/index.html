<!doctype html><html><head><title>20 回望K8S 容器编排与Kubernetes作业管理</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><meta property="og:title" content="20 回望K8S 容器编排与Kubernetes作业管理"><meta property="og:description" content="Pod pod 是 Kubernetes 项目的最小的 API 对象，原子调度单位.
假设 &ldquo;容器的本质是进程&rdquo;，容器镜像就是 exe 安装包, kubernetes 是操作系统
Pod 最重要的一个事实是一个逻辑概念。它对于 Kubernetes 最核心的意义是 容器设计模式。Kubernetes 真正处理的还是宿主机上操作系统上的 Linux 容器的 Namespace 和 Cgroups，而不是一个所谓的 Pod 边界和隔离环境。
Pod 其实是一组共享了某些资源的容器。Pod 里面所有的容器，共享的同一个 Network Namespace，并且可以声明共享同一个 Volume.
Kubernetes 项目内部，Pod 实现需要使用一个中间容器，这个容器叫做 Infra 容器，在 Pod 中，Infra 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起。
sidecar 典型的例子：WAR 包和 Web 服务器 POD后，将 WAR 包和 Tomcat 分别做成镜像，可以把他们容器结合在一起
---apiVersion:v1kind:Podmetadata:name:javaweb-2spec:# 启动后做了一件事 把应用的WAR包拷贝到 /app目录中，后退出initContainers:- image:sample-war:v2name:warcommand:[&#34;cp&#34;,&#34;/sample.war&#34;,&#34;/app&#34;]volumeMounts:- mountPath:/appname:app-volumecontainers:- image:tomcat:7.0name:tomcatcommand:[&#34;sh&#34;,&#34;-c&#34;,&#34;/root/apache-tomcat-7.0.42-v2/bin/start.sh&#34;]volumeMounts:- mountPath:/root/apache-tomcat-7.0.42-v2/webappsname:app-volumeports:- containerPort:8080hostPort:8001volumes:- name:app-volumeemptyDir:{}...这个POD中，定义了两个容器，第一个容器镜像 sample-war:v2，第二个容器镜像是 Tomcat 镜像，War包容器的类型不是一个普通容器，是一个 Init Container 类型的容器。"><meta property="og:type" content="article"><meta property="og:url" content="https://pinkhello.github.io/posts/20-%E5%9B%9E%E6%9C%9Bk8s-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8Ekubernetes%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/"><meta property="article:published_time" content="2021-02-16T22:48:35+08:00"><meta property="article:modified_time" content="2021-02-16T22:48:35+08:00"><meta property="og:site_name" content="一杯哈希不加盐"><meta name=twitter:card content="summary"><meta name=twitter:title content="20 回望K8S 容器编排与Kubernetes作业管理"><meta name=twitter:description content="Pod pod 是 Kubernetes 项目的最小的 API 对象，原子调度单位.
假设 &ldquo;容器的本质是进程&rdquo;，容器镜像就是 exe 安装包, kubernetes 是操作系统
Pod 最重要的一个事实是一个逻辑概念。它对于 Kubernetes 最核心的意义是 容器设计模式。Kubernetes 真正处理的还是宿主机上操作系统上的 Linux 容器的 Namespace 和 Cgroups，而不是一个所谓的 Pod 边界和隔离环境。
Pod 其实是一组共享了某些资源的容器。Pod 里面所有的容器，共享的同一个 Network Namespace，并且可以声明共享同一个 Volume.
Kubernetes 项目内部，Pod 实现需要使用一个中间容器，这个容器叫做 Infra 容器，在 Pod 中，Infra 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起。
sidecar 典型的例子：WAR 包和 Web 服务器 POD后，将 WAR 包和 Tomcat 分别做成镜像，可以把他们容器结合在一起
---apiVersion:v1kind:Podmetadata:name:javaweb-2spec:# 启动后做了一件事 把应用的WAR包拷贝到 /app目录中，后退出initContainers:- image:sample-war:v2name:warcommand:[&#34;cp&#34;,&#34;/sample.war&#34;,&#34;/app&#34;]volumeMounts:- mountPath:/appname:app-volumecontainers:- image:tomcat:7.0name:tomcatcommand:[&#34;sh&#34;,&#34;-c&#34;,&#34;/root/apache-tomcat-7.0.42-v2/bin/start.sh&#34;]volumeMounts:- mountPath:/root/apache-tomcat-7.0.42-v2/webappsname:app-volumeports:- containerPort:8080hostPort:8001volumes:- name:app-volumeemptyDir:{}...这个POD中，定义了两个容器，第一个容器镜像 sample-war:v2，第二个容器镜像是 Tomcat 镜像，War包容器的类型不是一个普通容器，是一个 Init Container 类型的容器。"><script src=/vendor/js/jquery.min.js></script><script src=/vendor/js/popper.min.js></script><script src=/vendor/js/bootstrap.min.js></script><script src=/vendor/js/smooth-scroll.polyfills.min.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script><link rel=stylesheet href=https://pinkhello.github.io/scss/journal.min.c116bc90d171283f099f173854157ec8f183f9073b93443b2c8ad82899ee9025.css integrity="sha256-wRa8kNFxKD8Jnxc4VBV+yPGD+Qc7k0Q7LIrYKJnukCU=" media=screen><link rel=stylesheet href=https://pinkhello.github.io/scss/dark-mode.min.552aae4638a84aa57cf0b195750a49ea9131d3bb621d1ed3ebc9b14b18166536.css integrity="sha256-VSquRjioSqV88LGVdQpJ6pEx07tiHR7T68mxSxgWZTY=" media=screen><script src=https://pinkhello.github.io//js/loadCSS.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");</script><script src=https://pinkhello.github.io//js/toc-collapse.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script src=/vendor/js/md5.min.js></script><script>var gitalk=new Gitalk({clientID:'419eb00d100865eb61e7',clientSecret:'f171ccc842eab6f06942e6a943a62546fc95b411',repo:'PinkHello.github.io',owner:'PinkHello',admin:['PinkHello'],id:md5(location.pathname),distractionFreeMode:'false',proxy:'https:\/\/netnr-proxy.cloudno.de\/https:\/\/github.com\/login\/oauth\/access_token'});window.onload=function(){gitalk.render('gitalk-container')}</script></head><body><div id=app><div ref=sideContainer class=side-container><a class="a-block nav-head false" href=https://pinkhello.github.io/><div class=nav-title>一杯哈希不加盐</div><div class=nav-subtitle>做一个快乐的程序猿</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>Archive</a>
<a class="a-block nav-link-item false" href=/categories>Categories</a>
<a class="a-block nav-link-item false" href=/tags>Tags</a>
<a class="a-block nav-link-item false" href=/about>About</a>
<a class="a-block nav-link-item false" href=/links>Links</a>
<a class="a-block nav-link-item false" href=/index.xml>RSS Feed</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
一杯哈希不加盐, All Rights Reserved</div></div><div ref=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- 目录 -</center><ul><li><a href=#pod onclick="onNavClick(`#pod-nav`)" id=pod-nav>Pod</a></li><ul class=collapse data-toggle=collapse><li><a href=#sidecar onclick="onNavClick(`#sidecar-nav`)" id=sidecar-nav>sidecar</a></li><ul class=collapse data-toggle=collapse><li><a href=#%e5%85%b8%e5%9e%8b%e7%9a%84%e4%be%8b%e5%ad%90war-%e5%8c%85%e5%92%8c-web-%e6%9c%8d%e5%8a%a1%e5%99%a8 onclick="onNavClick(`#典型的例子war-包和-web-服务器-nav`)" id=典型的例子war-包和-web-服务器-nav>典型的例子：WAR 包和 Web 服务器</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e7%9a%84%e6%97%a5%e5%bf%97%e6%94%b6%e9%9b%86 onclick="onNavClick(`#容器的日志收集-nav`)" id=容器的日志收集-nav>容器的日志收集</a></li></ul></ul><li><a href=#pod-%e5%af%b9%e8%b1%a1%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 onclick="onNavClick(`#pod-对象的基本概念-nav`)" id=pod-对象的基本概念-nav>Pod 对象的基本概念</a></li><li><a href=#kubernetes-%e5%85%b6%e4%bb%96%e5%af%b9%e8%b1%a1-volume onclick="onNavClick(`#kubernetes-其他对象-volume-nav`)" id=kubernetes-其他对象-volume-nav>Kubernetes 其他对象 Volume</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e7%9a%84%e5%81%a5%e5%ba%b7%e6%a3%80%e6%9f%a5%e5%92%8c%e6%81%a2%e5%a4%8d%e6%9c%ba%e5%88%b6 onclick="onNavClick(`#容器的健康检查和恢复机制-nav`)" id=容器的健康检查和恢复机制-nav>容器的健康检查和恢复机制</a></li><li><a href=#%e7%bc%96%e6%8e%92%e5%85%b6%e5%ae%9e%e5%be%88%e7%ae%80%e5%8d%95-%e6%8e%a7%e5%88%b6%e5%99%a8%e6%a8%a1%e5%9e%8b onclick="onNavClick(`#编排其实很简单-控制器模型-nav`)" id=编排其实很简单-控制器模型-nav>编排其实很简单-“控制器"模型</a></li><li><a href=#%e4%bd%9c%e4%b8%9a%e5%89%af%e6%9c%ac%e5%92%8c%e6%b0%b4%e5%b9%b3%e6%89%a9%e5%b1%95 onclick="onNavClick(`#作业副本和水平扩展-nav`)" id=作业副本和水平扩展-nav>作业副本和水平扩展</a></li><ul class=collapse data-toggle=collapse><li><a href=#pod-%e7%9a%84%e6%b0%b4%e5%b9%b3%e6%89%a9%e5%b1%95--%e6%94%b6%e7%bc%a9horizontal-scaling-outin onclick="onNavClick(`#pod-的水平扩展--收缩horizontal-scaling-outin-nav`)" id=pod-的水平扩展--收缩horizontal-scaling-outin-nav>Pod 的“水平扩展 / 收缩”（horizontal scaling out/in）</a></li><li><a href=#%e6%bb%9a%e5%8a%a8%e6%9b%b4%e6%96%b0 onclick="onNavClick(`#滚动更新-nav`)" id=滚动更新-nav>滚动更新</a></li></ul><li><a href=#%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3statefulset onclick="onNavClick(`#深入理解statefulset-nav`)" id=深入理解statefulset-nav>深入理解StatefulSet</a></li></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a class=pagination-action v-on:click=toggleDarkMode><i class="material-icons pagination-action-icon" v-if=isDarkMode>brightness_4</i>
<i class="material-icons pagination-action-icon" v-else=isDarkMode>brightness_7</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>Archive</a>
<a class="a-block drawer-menu-item false" href=/categories>Categories</a>
<a class="a-block drawer-menu-item false" href=/tags>Tags</a>
<a class="a-block drawer-menu-item false" href=/about>About</a>
<a class="a-block drawer-menu-item false" href=/links>Links</a>
<a class="a-block drawer-menu-item false" href=/index.xml>RSS Feed</a><div class=toc><div class=toc-content><center>- 目录 -</center><ul><li><a href=#pod onclick="onNavClick(`#pod-nav`)" id=pod-nav>Pod</a></li><ul class=collapse data-toggle=collapse><li><a href=#sidecar onclick="onNavClick(`#sidecar-nav`)" id=sidecar-nav>sidecar</a></li><ul class=collapse data-toggle=collapse><li><a href=#%e5%85%b8%e5%9e%8b%e7%9a%84%e4%be%8b%e5%ad%90war-%e5%8c%85%e5%92%8c-web-%e6%9c%8d%e5%8a%a1%e5%99%a8 onclick="onNavClick(`#典型的例子war-包和-web-服务器-nav`)" id=典型的例子war-包和-web-服务器-nav>典型的例子：WAR 包和 Web 服务器</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e7%9a%84%e6%97%a5%e5%bf%97%e6%94%b6%e9%9b%86 onclick="onNavClick(`#容器的日志收集-nav`)" id=容器的日志收集-nav>容器的日志收集</a></li></ul></ul><li><a href=#pod-%e5%af%b9%e8%b1%a1%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 onclick="onNavClick(`#pod-对象的基本概念-nav`)" id=pod-对象的基本概念-nav>Pod 对象的基本概念</a></li><li><a href=#kubernetes-%e5%85%b6%e4%bb%96%e5%af%b9%e8%b1%a1-volume onclick="onNavClick(`#kubernetes-其他对象-volume-nav`)" id=kubernetes-其他对象-volume-nav>Kubernetes 其他对象 Volume</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e7%9a%84%e5%81%a5%e5%ba%b7%e6%a3%80%e6%9f%a5%e5%92%8c%e6%81%a2%e5%a4%8d%e6%9c%ba%e5%88%b6 onclick="onNavClick(`#容器的健康检查和恢复机制-nav`)" id=容器的健康检查和恢复机制-nav>容器的健康检查和恢复机制</a></li><li><a href=#%e7%bc%96%e6%8e%92%e5%85%b6%e5%ae%9e%e5%be%88%e7%ae%80%e5%8d%95-%e6%8e%a7%e5%88%b6%e5%99%a8%e6%a8%a1%e5%9e%8b onclick="onNavClick(`#编排其实很简单-控制器模型-nav`)" id=编排其实很简单-控制器模型-nav>编排其实很简单-“控制器"模型</a></li><li><a href=#%e4%bd%9c%e4%b8%9a%e5%89%af%e6%9c%ac%e5%92%8c%e6%b0%b4%e5%b9%b3%e6%89%a9%e5%b1%95 onclick="onNavClick(`#作业副本和水平扩展-nav`)" id=作业副本和水平扩展-nav>作业副本和水平扩展</a></li><ul class=collapse data-toggle=collapse><li><a href=#pod-%e7%9a%84%e6%b0%b4%e5%b9%b3%e6%89%a9%e5%b1%95--%e6%94%b6%e7%bc%a9horizontal-scaling-outin onclick="onNavClick(`#pod-的水平扩展--收缩horizontal-scaling-outin-nav`)" id=pod-的水平扩展--收缩horizontal-scaling-outin-nav>Pod 的“水平扩展 / 收缩”（horizontal scaling out/in）</a></li><li><a href=#%e6%bb%9a%e5%8a%a8%e6%9b%b4%e6%96%b0 onclick="onNavClick(`#滚动更新-nav`)" id=滚动更新-nav>滚动更新</a></li></ul><li><a href=#%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3statefulset onclick="onNavClick(`#深入理解statefulset-nav`)" id=深入理解statefulset-nav>深入理解StatefulSet</a></li></ul></div></div></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=https://pinkhello.github.io/>一杯哈希不加盐</a>
<button type=button class=nav-darkmode-toggle v-on:click=toggleDarkMode>
<i class=material-icons v-if=isDarkMode>brightness_4</i>
<i class=material-icons v-else=isDarkMode>brightness_7</i></button></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://pinkhello.github.io/><div class=single-column-header-title>一杯哈希不加盐</div><div class=single-column-header-subtitle>做一个快乐的程序猿</div></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper style=background-image:url(https://pinkhello.github.io/%E5%85%B6%E4%BB%96/dog_cool_summer_other.jpg)><div class=post-title>20 回望K8S 容器编排与Kubernetes作业管理<div class=post-meta><time itemprop=datePublished>2021-02-16 22:48</time>
<i class=material-icons>folder</i>
<a href=/categories/k8s>k8s</a>
&nbsp;
<i class=material-icons>label</i>
<a href=/tags/k8s>k8s</a>
&nbsp;
<a href=/tags/%E5%AE%B9%E5%99%A8>容器</a>
&nbsp;
<i class=material-icons>schedule</i>
14 min
25 s.</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h1 id=pod>Pod</h1><p><code>pod</code> 是 <code>Kubernetes</code> 项目的最小的 API 对象，原子调度单位.</p><p>假设 &ldquo;容器的本质是进程&rdquo;，容器镜像就是 exe 安装包, kubernetes 是操作系统</p><p><code>Pod</code> 最重要的一个事实是一个逻辑概念。它对于 <code>Kubernetes</code> 最核心的意义是 <code>容器设计模式</code>。<code>Kubernetes</code> 真正处理的还是宿主机上操作系统上的 <code>Linux</code> 容器的 <code>Namespace</code> 和 <code>Cgroups</code>，而不是一个所谓的 <code>Pod</code> 边界和隔离环境。</p><p><code>Pod</code> 其实是一组共享了某些资源的容器。<code>Pod</code> 里面所有的容器，共享的同一个 <code>Network Namespace</code>，并且可以声明共享同一个 <code>Volume</code>.</p><p><code>Kubernetes</code> 项目内部，<code>Pod</code> 实现需要使用一个中间容器，这个容器叫做 <code>Infra</code> 容器，在 <code>Pod</code> 中，<code>Infra</code> 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 <code>Join Network Namespace</code> 的方式，与 <code>Infra</code> 容器关联在一起。</p><h2 id=sidecar><code>sidecar</code></h2><h3 id=典型的例子war-包和-web-服务器>典型的例子：WAR 包和 Web 服务器</h3><p><code>POD</code>后，将 <code>WAR</code> 包和 <code>Tomcat</code> 分别做成镜像，可以把他们容器结合在一起</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#008b45;text-decoration:underline>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#8b008b;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#8b008b;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#8b008b;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#8b008b;font-weight:700>name</span>:<span style=color:#bbb> </span>javaweb-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#8b008b;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#228b22>#  启动后做了一件事 把应用的WAR包拷贝到 /app目录中，后退出</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#8b008b;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#8b008b;font-weight:700>image</span>:<span style=color:#bbb> </span>sample-war:v2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#8b008b;font-weight:700>name</span>:<span style=color:#bbb> </span>war<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#8b008b;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#cd5555>&#34;cp&#34;</span>,<span style=color:#bbb> </span><span style=color:#cd5555>&#34;/sample.war&#34;</span>,<span style=color:#bbb> </span><span style=color:#cd5555>&#34;/app&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#8b008b;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#8b008b;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/app<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#8b008b;font-weight:700>name</span>:<span style=color:#bbb> </span>app-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#8b008b;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#8b008b;font-weight:700>image</span>:<span style=color:#bbb> </span>tomcat:7.0<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#8b008b;font-weight:700>name</span>:<span style=color:#bbb> </span>tomcat<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#8b008b;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#cd5555>&#34;sh&#34;</span>,<span style=color:#cd5555>&#34;-c&#34;</span>,<span style=color:#cd5555>&#34;/root/apache-tomcat-7.0.42-v2/bin/start.sh&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#8b008b;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#8b008b;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/root/apache-tomcat-7.0.42-v2/webapps<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#8b008b;font-weight:700>name</span>:<span style=color:#bbb> </span>app-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#8b008b;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#8b008b;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#b452cd>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#8b008b;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#b452cd>8001</span><span style=color:#bbb> 
</span><span style=color:#bbb>  </span><span style=color:#8b008b;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#8b008b;font-weight:700>name</span>:<span style=color:#bbb> </span>app-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#8b008b;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#008b45;text-decoration:underline>...</span><span style=color:#bbb>
</span></code></pre></div><p>这个<code>POD</code>中，定义了两个容器，第一个容器镜像<code> sample-war:v2</code>，第二个容器镜像是 <code>Tomcat</code> 镜像，War包容器的类型不是一个普通容器，是一个 <code>Init Container</code> 类型的容器。</p><p>在Pod中，所有 <code>Init Container</code> 定义的容器，都比 <code>spec.containers</code> 定义的用户容器先启动。并且， <code>Init Container</code> 容器会按顺序准一启动，而直到他们都启动并且退出了，用户容器才会启动。</p><p>这种组合的方式，正是容器设计模式里面最常用的一种模式：<code>sidecar</code></p><h3 id=容器的日志收集>容器的日志收集</h3><p>应用把日志文件输出到容器的 <code>/var/log</code> 目录中，<code>Pod</code>的 <code>Volume</code> 挂载到应用容器的 <code>/var/log</code> 目录上，然后在这个 <code>Pod</code> 里的运行一个 <code>sidecar</code> 容器，也声明挂载同一个 <code>Volume</code> 到自己的 <code>/var/log</code> 目录上，
这样这个 <code>sidecar</code> 容器只需要做一件事，把自己的 <code>/var/log</code> 目录中读取日志文件，转发就可以了，就是一个基本的日志收集</p><h1 id=pod-对象的基本概念><code>Pod</code> 对象的基本概念</h1><p><code>Pod</code> 是容器环境的 <code>Kubernetes</code> 的基本单元，调度、网络、存储、以及安全相关的熟悉，都是属于 <code>Pod</code> 级别的。</p><p><code>Pod</code> 下重要的字段和含义</p><ul><li><code>NodeSelector</code> : 用户将 <code>Pod</code> 和 <code>Node</code> 绑定的字段</li><li><code>NodeName</code> : 一旦 <code>Pod</code> 的这个阻断被赋值，<code>K8S</code> 会认为这个 <code>Pod</code> 已经经过调度。</li><li><code>HostAliases</code>：定义了 <code>Pod</code> 的 <code>hosts</code> 文件（比如 <code>/etc/hosts</code>）里的内容</li></ul><p>凡是跟容器的 <code>Linux Namespace</code> 相关的属性，也一定是 <code>Pod</code> 级别的。
<code>shareProcessNamespace=true</code></p><p><code>Pod</code> 对象在 <code>Kubernetes</code> 中的生命周期。<code>Pod</code> 生命周期的变化，主要体现在 <code>Pod API 对象</code>的 <code>Status</code> 部分，这是它除了 <code>Metadata</code> 和 <code>Spec</code> 之外的第三个重要字段。其中，<code>pod.status.phase</code>，就是 <code>Pod</code> 的当前状态，
它有如下几种可能的情况：</p><ul><li><code>Pending</code>。这个状态意味着，<code>Pod</code> 的 <code>YAML</code> 文件已经提交给了 <code>Kubernetes</code>，<code>API</code> 对象已经被创建并保存在 <code>Etcd</code> 当中。但是，这个 <code>Pod</code> 里有些容器因为某种原因而不能被顺利创建。比如，调度不成功。</li><li><code>Running</code>。这个状态下，<code>Pod</code> 已经调度成功，跟一个具体的节点绑定。它包含的容器都已经创建成功，并且至少有一个正在运行中。</li><li><code>Succeeded</code>。这个状态意味着，<code>Pod</code> 里的所有容器都正常运行完毕，并且已经退出了。这种情况在运行一次性任务时最为常见。</li><li><code>Failed</code>。这个状态下，<code>Pod</code> 里至少有一个容器以不正常的状态（非 0 的返回码）退出。这个状态的出现，意味着你得想办法 <code>Debug</code> 这个容器的应用，比如查看 <code>Pod</code> 的 <code>Events</code> 和日志。</li><li><code>Unknown</code>。这是一个异常状态，意味着 <code>Pod</code> 的状态不能持续地被 <code>kubelet</code> 汇报给 <code>kube-apiserver</code>，这很有可能是主从节点（<code>Master</code> 和 <code>Kubelet</code>）间的通信出现了问题。</li></ul><h1 id=kubernetes-其他对象-volume><code>Kubernetes</code> 其他对象 <code>Volume</code></h1><p><code>Kubernetes</code> 支持的 <code>Project Volume</code> 一共有四种:</p><ul><li><code>Secret</code> : 把 Pod 想要访问的加密数据，存放到 <code>Etcd</code> 中，然后通过在 Pod 的容器里挂载 Volume 的方式。</li><li><code>ConfigMap</code> : 保存的是不需要加密的、应用所需的配置信息。而 <code>ConfigMap</code> 的用法几乎与 <code>Secret</code> 完全相同：你可以使用 <code>kubectl create configmap</code> 从文件或者目录创建 <code>ConfigMap</code>，也可以直接编写 <code>ConfigMap</code> 对象的 <code>YAML</code> 文件。</li><li><code>Downward API</code> : 让 Pod 里的容器能够直接获取到这个<code> Pod API</code> 对象本身的信息。<blockquote><p>一定是 Pod 里的容器进程启动之前就能够确定下来的信息。而如果你想要获取 Pod 容器运行后才会出现的信息，比如，容器进程的 <code>PID</code>，那就肯定不能使用 <code>Downward API</code> 了，而应该考虑在 <code>Pod</code> 里定义一个 <code>sidecar</code> 容器。</p></blockquote></li><li><code>ServiceAccountToken</code> : 这种把 <code>Kubernetes</code> 客户端以容器的方式运行在集群里，然后使用 <code>default Service Account</code> 自动授权的方式，被称作“InClusterConfig”.</li></ul><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#008b45;text-decoration:underline>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#8b008b;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#8b008b;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#8b008b;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#8b008b;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#8b008b;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#8b008b;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#8b008b;font-weight:700>user</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#8b008b;font-weight:700>pass</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#008b45;text-decoration:underline>...</span><span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; kubectl create secret
</code></pre></div><h1 id=容器的健康检查和恢复机制>容器的健康检查和恢复机制</h1><p><code>Pod</code> 容器定义了一个健康检查的"探针"（Probe）, 这样kubelet就会根据这个 probe 返回的值决定这个容器的状态，而不是直接以容器镜像十分运行来作为依据。生产环境保证应用健康存活的重要手段。</p><p><code>Pod</code> 恢复机制 restartPolicy, 它是 Pod 的 Spec 部分的一个标准字段（<code>pod.spec.restartPolicy</code>），默认值是 <code>Always</code>，即：任何时候这个容器发生了异常，它一定会被重新创建。</p><blockquote><p><code>pod</code> 恢复，永远只发生在当前节点，而不会跑到别的节点上去。（不会发生故障转移）需要转移的需要切换到 <code>Deployment</code> 这样的控制器来管理<code>POD</code></p></blockquote><p>你还可以通过设置 <code>restartPolicy</code>，改变 <code>Pod</code> 的恢复策略。除了 <code>Always</code>，它还有 <code>OnFailure</code> 和 <code>Never</code> 两种情况：</p><ul><li><code>Always</code>：在任何情况下，只要容器不在运行状态，就自动重启容器；</li><li><code>OnFailure</code>: 只在容器 异常时才自动重启容器；</li><li><code>Never</code>: 从来不重启容器。</li></ul><h1 id=编排其实很简单-控制器模型>编排其实很简单-&ldquo;控制器"模型</h1><p>前面已经知道 <code>POD</code> 是一个复杂的<code>API对象</code>，实际也是对容器的进一步抽象和封装；也就是说<code>Pod对象</code>是容器的升级版,它对容器的组合，添加了很多的属性和字段。</p><p><code>Kubernetes</code>操作<code>POD</code>是依赖控制器(Controller)完成的。就是 kube-controller-manager 组件</p><p>通过查看 <code>https://github.com/kubernetes/kubernetes/tree/master/pkg/controller</code> 源代码下能看见这些目录</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment/ job/ podautoscaler/ cloud/ disruption/ namespace/ 
replicaset/ serviceaccount/ volume/cronjob/ garbagecollector/ nodelifecycle/ 
replication/ statefulset/ daemon/...
</code></pre></div><p>这些每个目录都是一种类型的 <code>controller</code>,各自负责某种编排功能。</p><p>控制循环（control loop）</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>
<span style=color:#8b008b;font-weight:700>for</span> {
  实际状态 := 获取集群中对象X的实际状态<span style=color:#a61717;background-color:#e3d2d2>（</span>Actual State<span style=color:#a61717;background-color:#e3d2d2>）</span>
  期望状态 := 获取集群中对象X的期望状态<span style=color:#a61717;background-color:#e3d2d2>（</span>Desired State<span style=color:#a61717;background-color:#e3d2d2>）</span>
  <span style=color:#8b008b;font-weight:700>if</span> 实际状态 == 期望状态{
    什么都不做
  } <span style=color:#8b008b;font-weight:700>else</span> {
    执行编排动作<span style=color:#a61717;background-color:#e3d2d2>，</span>将实际状态调整为期望状态
  }
}
</code></pre></div><p>具体实现时候，<code>实际状态</code>来自于<code>Kubernetes</code> 集群本身，<code>期望状态</code>来自于用户提交的 <code>YAML</code> 文件。</p><blockquote><p>比如</p><ul><li><code>Deployment控制器</code>从<code>Etcd</code>中获取到目标标签的 <code>POD</code>，然后统计他们的数量，这是实际状态；</li><li><code>Deployment对象</code>的 <code>Replicas</code> 字段的值是期望状态；</li><li><code>Deployment控制器</code>将两个状态做比较，然后根据比较结果，确定创建<code>POD</code>还是删除已经存在的<code>POD</code></li></ul></blockquote><p>这个操作叫做协调（<code>Reconcile</code>）即 控制循环</p><blockquote><p>为什么是循环，因为事件往往是一次性的，如果操作失败比较难处理，但是控制器循环一直尝试，更符合 Kubernetes 声明式API，最终达成一致。</p></blockquote><p><img src=/%E5%9B%9E%E6%9C%9BK8S/deployment.png alt=deployment结构></p><p>上半部分的控制器定义（包含期望状态），下面的部分被控制对象的模板组成的。</p><h1 id=作业副本和水平扩展>作业副本和水平扩展</h1><h2 id=pod-的水平扩展--收缩horizontal-scaling-outin>Pod 的“水平扩展 / 收缩”（horizontal scaling out/in）</h2><p>如果我们更新了 Deployment 的 Pod 模板（假如更新了容器镜像），那么 Deployment 需要遵循一种 &ldquo;滚动更新&rdquo;（rolling update）的方式来升级现有的容器。这也是 kubernetes 重要的概念（API对象）：ReplicaSet</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#8b008b;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#8b008b;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#8b008b;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#8b008b;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-set<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#8b008b;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#8b008b;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#8b008b;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#8b008b;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#b452cd>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#8b008b;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#8b008b;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#8b008b;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#8b008b;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#8b008b;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#8b008b;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#8b008b;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#8b008b;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#8b008b;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#8b008b;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#8b008b;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></code></pre></div><p>一个 <code>ReplicaSet</code>对象，由 副本数目的定义和一个Pod模板组成的。它其实是 Deployment 的子集。而且，Deployment控制器操作的正是 ReplicaSet 对象，而不是Pod对象。</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale
</code></pre></div><p><img src=/%E5%9B%9E%E6%9C%9BK8S/replicaset.jpg alt=ReplicaSet结构></p><h2 id=滚动更新>滚动更新</h2><p>将一个集群中正在运行的多个 Pod 版本，交替地逐一升级的过程，就是“滚动更新”。</p><blockquote><ul><li>依赖 health check机制</li><li>保证服务的连续性</li></ul></blockquote><p><img src=/%E5%9B%9E%E6%9C%9BK8S/deployment-replicaset-pod.jpg alt=DeploymentReplicaSet></p><p>Deployment 实际上是一个两层控制器。首先，它通过 ReplicaSet 的个数来描述应用的版本；然后，它再通过 ReplicaSet 的属性（比如 replicas 的值），来保证 Pod 的副本数量。</p><h1 id=深入理解statefulset>深入理解StatefulSet</h1><ul><li>拓扑状态：应用间不完全对等，需要谁先启动，谁后启动，必须按照某些顺序来启动。</li><li>存储状态：多个实例绑定了不同的存储数据，一个数据库应用的多个存储实例</li></ul><p>StatefulSet 核心功能：通过某种方式纪录这些状态，等POD被重新创建时候，能够为新的POD恢复状态。</p><p>Headless Service</p><hr width=100% id=EOF><p style=color:#777>最后修改于 2021-02-16</p></div></div><nav class=post-pagination><a class=newer-posts>下回<br>已经到头啦。</a>
<a class=older-posts href=https://pinkhello.github.io/posts/19-%E5%9B%9E%E6%9C%9Bk8s-kubernetes%E6%8B%BC%E5%9B%BE/>上回<br>19 回望K8S Kubernetes拼图</a></nav><div class=post-comment-wrapper><div id=gitalk-container></div></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
一杯哈希不加盐, All Rights Reserved</div></div><script>let app;app=new Vue({el:'#app',data:{scrollY:0,navOpacity:0,isDrawerOpen:false,mounted:false,isDarkMode:false},methods:{sgn(t,x){let k=1./(1.-2*t);if(x<=t)return 0;else if(x>=1-t)return 1;else{return k*(x-t);}},handleScroll(){this.scrollY=window.scrollY;this.navOpacity=this.sgn(.0,Math.min(1,Math.max(0,window.scrollY/(this.pageHeadHeight()-this.navBarHeight()*0.8))));const{navBar,navBackground,navTitle,extraContainer,streamContainer}=this.$refs;if(this.navOpacity>=1){navBackground.style.opacity=1;navTitle.style.opacity=1;}else{navBackground.style.opacity=0;navTitle.style.opacity=0;}},handleResize(){const{navBar,navBackground,navTitle,extraContainer,streamContainer}=this.$refs;extraContainer.style.left=(streamContainer.offsetWidth-extraContainer.offsetWidth)+'px';},navBarHeight(){return this.$refs.navBar.offsetHeight;},pageHeadHeight(){return this.$refs.pageHead.offsetHeight;},toggleDrawer(){this.isDrawerOpen=!this.isDrawerOpen;document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset';},closeDrawer(){this.isDrawerOpen=false;document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset';},toggleDarkMode(){this.isDarkMode=!this.isDarkMode;if(this.isDarkMode==true){document.cookie="night=1;path=/";document.body.classList.add("night");}else{document.cookie="night=0;path=/";document.body.classList.remove("night");}}},created(){window.addEventListener('scroll',this.handleScroll);window.addEventListener('resize',this.handleResize);window._nonDesktop=function(){let check=false;(function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check=true;})(navigator.userAgent||navigator.vendor||window.opera);return check;};var night=document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/,"$1");if(night==""){if(window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches){}}else{if(night=="1"){this.toggleDarkMode();}}},mounted(){this.handleScroll();this.handleResize();this.mounted=true;},destroyed(){window.removeEventListener('scroll',this.handleScroll);window.removeEventListener('resize',this.handleResize);}});</script><script src=https://pinkhello.github.io//js/journal.js></script></body></html>