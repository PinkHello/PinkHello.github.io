<!doctype html><html lang=en><head><title>一杯哈希不加盐</title><meta charset=utf-8><meta content="utf-8" http-equiv=encoding><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#000084"><link rel=icon href=https://pinkhello.github.io//favicon.ico><link rel=canonical href=https://pinkhello.github.io/></head><body><nav class="navbar navbar-inverse navbar-fixed-top"><div class=navbar-inner><div class=container><button type=button class="btn btn-navbar" data-toggle=collapse data-target=.nav-collapse></button>
<a class=brand href=https://pinkhello.github.io/>一杯哈希不加盐</a><div class="nav-collapse collapse"><ul class=nav><li><a href=/about/><span>About</span></a></li><li><a href=/posts/><span>Archive</span></a></li></ul></div></div></div></nav><div id=content class=container><div class="row-fluid navmargin"><div class=page-header><h1>01 一致性哈希算法 - Tue, Feb 9, 2021</h1></div><p class=lead></p><h1 id=分布式均衡寻址算法>分布式均衡寻址算法</h1><p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱落集群的操作是分布式集群管理的基本功能。</p><blockquote><p>在集群环境中，判断分布式寻址算法好坏的原则：</p><ul><li>平衡性（Balance）</li><li>单调性（Monotonicity）</li><li>分散性（Spread）</li><li>负载（Load）</li></ul></blockquote><h2 id=hashobjectn>Hash(Object)%N</h2><p>集群N台机器，根据N取模，路由到对应的机器，但是缺点在于，对于机器的添加删除，已经缓存的数据都失效、严重违反单调性，
大量的缓存重建</p><blockquote><p>假设0-3个节点、20个数据:
<img src=/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hash.png alt=哈希数据></p><p>进行取模后分布:
<img src=/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hash1.png alt=哈希取模后分布></p><p>扩容后:
<img src=/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hash3.png alt=扩容后>
当前只有4个数据能命中。命中率 4/20 = 20% ,命中率底下，并且有大量缓存需要重建</p></blockquote><h2 id=一致性hash--dht->一致性Hash ( DHT )</h2><blockquote><p>公共哈希函数和哈希环
Hash算法设计: 采取取模方式，按常用的 Hash 算法将对应的 Key 哈希到一个具有 2^32 次方的桶空间中，即 0 ~ (2^32)-1 的数字空间。想想一下，将数字首位相连，组成一个闭合的环形。
<img src=/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hash4.png alt=环形Hash空间></p></blockquote><blockquote><p>对象(Object)映射到哈希环
把对象映射到 0-2^32-1 空间里，假设有4个对象 object1-4 ，映射进hash环状
<img src=/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hash5.png alt=对象映射环形Hash空间></p></blockquote><blockquote><p>缓存(Cache)映射到哈希环
下面将 Cache 映射进 Hash 空间，假设现在有三个cache：</p><blockquote><p>基本思想就是 Object 和 Cache 都映射到同一 Hash 数值空间中，并且使用相同的 Hash算法，可以使用 Cache 的 IP地址或者其他因子）</p></blockquote><p><img src=/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hash6.png alt=Cache映射环形Hash空间></p></blockquote><blockquote><p>对象（Object映射到缓存(Cache)节点
每个 Cache 的 Key 顺时针，找到第一个 Cache 节点就是存储位置:
<img src=/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hash7.png alt=找到Cache存储位置></p></blockquote><blockquote><p>移除一个缓存节点
移除一个 CacheB 节点, 这时候 key4 无法找寻到 Cache，key4将继续使用一致性Hash算法算出最新的 CacheC, 以后存储与读取都在 CacheC 上。
<img src=/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hash8.png alt=移除CacheB节点></p><blockquote><p>移除节点后的影响范围在该节点逆时针计算到遇到的第一个cache节点之间的数据节点。</p></blockquote></blockquote><blockquote><p>增加一个缓存节点
增加一个 Cache节点
<img src=/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/hash9.png alt=新增Cache节点></p><blockquote><p>影响范围为：添加节点逆时针遇到的第一个cache节点之间的数据节点</p></blockquote></blockquote><blockquote><p>虚拟Cache节点
物理上不可能部署节点有限，所以需要虚拟出足够多的虚拟节点，最终达到数据在哈希换上均匀分布</p><blockquote><p>假如只有两个节点,每个节点都复制成3倍，结果看上去部署了6个节点。可以想象当复制倍数是 2^32 时候，就达到绝对的均匀，通常可取的复制倍数为32 或者更高</p></blockquote><p>虚拟节点哈希值计算方法调整为 对 &ldquo;节点IP（或机器名）+虚拟节点的序号（1~N）&rdquo; 作哈希</p></blockquote><h1 id=redis-cluster>Redis Cluster</h1><p>Redis Cluster 是 Redis 官方出品的分布式解决方案</p><p>Redis Cluster 由多个 Redis 实例组成的整体，数据按照 <em>槽(slot)</em> 存储分布在多个实例上，通过 Gossip 协议来进行节点通信。</p><p>redis 为什么使用 16384 slots? <a href=https://github.com/antirez/redis/issues/2576>redis 作者给出答案</a></p><h1 id=一致性hash算法的java实现与检验>一致性hash算法的JAVA实现与检验</h1><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConsistentHashing</span> <span style=color:#f92672>{</span>
       <span style=color:#75715e>// 物理节点
</span><span style=color:#75715e></span>       <span style=color:#66d9ef>private</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> physicalNodes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TreeSet<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;()</span> <span style=color:#f92672>{</span>
           <span style=color:#f92672>{</span>
               add<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;192.168.1.101&#34;</span><span style=color:#f92672>);</span>
               add<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;192.168.1.102&#34;</span><span style=color:#f92672>);</span>
               add<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;192.168.1.103&#34;</span><span style=color:#f92672>);</span>
               add<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;192.168.1.104&#34;</span><span style=color:#f92672>);</span>
               add<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;192.168.1.105&#34;</span><span style=color:#f92672>);</span>
               add<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;192.168.1.106&#34;</span><span style=color:#f92672>);</span>
           <span style=color:#f92672>}</span>
       <span style=color:#f92672>};</span>
   
       <span style=color:#75715e>//虚拟节点
</span><span style=color:#75715e></span>       <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> VIRTUAL_COPIES <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span> <span style=color:#75715e>// 物理节点至虚拟节点的复制倍数
</span><span style=color:#75715e></span>       <span style=color:#66d9ef>private</span> TreeMap<span style=color:#f92672>&lt;</span>Long<span style=color:#f92672>,</span> String<span style=color:#f92672>&gt;</span> virtualNodes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TreeMap<span style=color:#f92672>&lt;&gt;();</span> <span style=color:#75715e>// 哈希值 =&gt; 物理节点
</span><span style=color:#75715e></span>   
       <span style=color:#75715e>// 32位的 Fowler-Noll-Vo 哈希算法
</span><span style=color:#75715e></span>       <span style=color:#75715e>// https://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function
</span><span style=color:#75715e></span>       <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Long <span style=color:#a6e22e>FNVHash</span><span style=color:#f92672>(</span>String key<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
           <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> p <span style=color:#f92672>=</span> 16777619<span style=color:#f92672>;</span>
           Long hash <span style=color:#f92672>=</span> 2166136261L<span style=color:#f92672>;</span>
           <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> idx <span style=color:#f92672>=</span> 0<span style=color:#f92672>,</span> num <span style=color:#f92672>=</span> key<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>();</span> idx <span style=color:#f92672>&lt;</span> num<span style=color:#f92672>;</span> <span style=color:#f92672>++</span>idx<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
               hash <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>hash <span style=color:#f92672>^</span> key<span style=color:#f92672>.</span><span style=color:#a6e22e>charAt</span><span style=color:#f92672>(</span>idx<span style=color:#f92672>))</span> <span style=color:#f92672>*</span> p<span style=color:#f92672>;</span>
           <span style=color:#f92672>}</span>
           hash <span style=color:#f92672>+=</span> hash <span style=color:#f92672>&lt;&lt;</span> 13<span style=color:#f92672>;</span>
           hash <span style=color:#f92672>^=</span> hash <span style=color:#f92672>&gt;&gt;</span> 7<span style=color:#f92672>;</span>
           hash <span style=color:#f92672>+=</span> hash <span style=color:#f92672>&lt;&lt;</span> 3<span style=color:#f92672>;</span>
           hash <span style=color:#f92672>^=</span> hash <span style=color:#f92672>&gt;&gt;</span> 17<span style=color:#f92672>;</span>
           hash <span style=color:#f92672>+=</span> hash <span style=color:#f92672>&lt;&lt;</span> 5<span style=color:#f92672>;</span>
   
           <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>hash <span style=color:#f92672>&lt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
               hash <span style=color:#f92672>=</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>abs</span><span style=color:#f92672>(</span>hash<span style=color:#f92672>);</span>
           <span style=color:#f92672>}</span>
           <span style=color:#66d9ef>return</span> hash<span style=color:#f92672>;</span>
       <span style=color:#f92672>}</span>
   
       <span style=color:#75715e>// 根据物理节点，构建虚拟节点映射表
</span><span style=color:#75715e></span>       <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ConsistentHashing</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
           <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>String nodeIp <span style=color:#f92672>:</span> physicalNodes<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
               addPhysicalNode<span style=color:#f92672>(</span>nodeIp<span style=color:#f92672>);</span>
           <span style=color:#f92672>}</span>
       <span style=color:#f92672>}</span>
   
       <span style=color:#75715e>// 添加物理节点
</span><span style=color:#75715e></span>       <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addPhysicalNode</span><span style=color:#f92672>(</span>String nodeIp<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
           <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> idx <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> idx <span style=color:#f92672>&lt;</span> VIRTUAL_COPIES<span style=color:#f92672>;</span> <span style=color:#f92672>++</span>idx<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
               <span style=color:#66d9ef>long</span> hash <span style=color:#f92672>=</span> FNVHash<span style=color:#f92672>(</span>nodeIp <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;#&#34;</span> <span style=color:#f92672>+</span> idx<span style=color:#f92672>);</span>
               virtualNodes<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>hash<span style=color:#f92672>,</span> nodeIp<span style=color:#f92672>);</span>
           <span style=color:#f92672>}</span>
       <span style=color:#f92672>}</span>
   
       <span style=color:#75715e>// 删除物理节点
</span><span style=color:#75715e></span>       <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>removePhysicalNode</span><span style=color:#f92672>(</span>String nodeIp<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
           <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> idx <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> idx <span style=color:#f92672>&lt;</span> VIRTUAL_COPIES<span style=color:#f92672>;</span> <span style=color:#f92672>++</span>idx<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
               <span style=color:#66d9ef>long</span> hash <span style=color:#f92672>=</span> FNVHash<span style=color:#f92672>(</span>nodeIp <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;#&#34;</span> <span style=color:#f92672>+</span> idx<span style=color:#f92672>);</span>
               virtualNodes<span style=color:#f92672>.</span><span style=color:#a6e22e>remove</span><span style=color:#f92672>(</span>hash<span style=color:#f92672>);</span>
           <span style=color:#f92672>}</span>
       <span style=color:#f92672>}</span>
   
       <span style=color:#75715e>// 查找对象映射的节点
</span><span style=color:#75715e></span>       <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getObjectNode</span><span style=color:#f92672>(</span>String object<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
           <span style=color:#66d9ef>long</span> hash <span style=color:#f92672>=</span> FNVHash<span style=color:#f92672>(</span>object<span style=color:#f92672>);</span>
           SortedMap<span style=color:#f92672>&lt;</span>Long<span style=color:#f92672>,</span> String<span style=color:#f92672>&gt;</span> tailMap <span style=color:#f92672>=</span> virtualNodes<span style=color:#f92672>.</span><span style=color:#a6e22e>tailMap</span><span style=color:#f92672>(</span>hash<span style=color:#f92672>);</span> <span style=color:#75715e>// 所有大于 hash 的节点
</span><span style=color:#75715e></span>           Long key <span style=color:#f92672>=</span> tailMap<span style=color:#f92672>.</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>()</span> <span style=color:#f92672>?</span> virtualNodes<span style=color:#f92672>.</span><span style=color:#a6e22e>firstKey</span><span style=color:#f92672>()</span> <span style=color:#f92672>:</span> tailMap<span style=color:#f92672>.</span><span style=color:#a6e22e>firstKey</span><span style=color:#f92672>();</span>
           <span style=color:#66d9ef>return</span> virtualNodes<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>key<span style=color:#f92672>);</span>
       <span style=color:#f92672>}</span>
   
       <span style=color:#75715e>// 统计对象与节点的映射关系
</span><span style=color:#75715e></span>       <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dumpObjectNodeMap</span><span style=color:#f92672>(</span>String label<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> objectMin<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> objectMax<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
           <span style=color:#75715e>// 统计
</span><span style=color:#75715e></span>           Map<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>,</span> Integer<span style=color:#f92672>&gt;</span> objectNodeMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TreeMap<span style=color:#f92672>&lt;&gt;();</span> <span style=color:#75715e>// IP =&gt; COUNT
</span><span style=color:#75715e></span>           <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> object <span style=color:#f92672>=</span> objectMin<span style=color:#f92672>;</span> object <span style=color:#f92672>&lt;=</span> objectMax<span style=color:#f92672>;</span> <span style=color:#f92672>++</span>object<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
               String nodeIp <span style=color:#f92672>=</span> getObjectNode<span style=color:#f92672>(</span>Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>(</span>object<span style=color:#f92672>));</span>
               Integer count <span style=color:#f92672>=</span> objectNodeMap<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>nodeIp<span style=color:#f92672>);</span>
               objectNodeMap<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>nodeIp<span style=color:#f92672>,</span> <span style=color:#f92672>(</span>count <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> 0 <span style=color:#f92672>:</span> count <span style=color:#f92672>+</span> 1<span style=color:#f92672>));</span>
           <span style=color:#f92672>}</span>
   
           <span style=color:#75715e>// 打印
</span><span style=color:#75715e></span>           <span style=color:#66d9ef>double</span> totalCount <span style=color:#f92672>=</span> objectMax <span style=color:#f92672>-</span> objectMin <span style=color:#f92672>+</span> 1<span style=color:#f92672>;</span>
           System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;======== &#34;</span> <span style=color:#f92672>+</span> label <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; ========&#34;</span><span style=color:#f92672>);</span>
           <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Map<span style=color:#f92672>.</span><span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>,</span> Integer<span style=color:#f92672>&gt;</span> entry <span style=color:#f92672>:</span> objectNodeMap<span style=color:#f92672>.</span><span style=color:#a6e22e>entrySet</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
               <span style=color:#66d9ef>long</span> percent <span style=color:#f92672>=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span><span style=color:#f92672>)</span> <span style=color:#f92672>(</span>100 <span style=color:#f92672>*</span> entry<span style=color:#f92672>.</span><span style=color:#a6e22e>getValue</span><span style=color:#f92672>()</span> <span style=color:#f92672>/</span> totalCount<span style=color:#f92672>);</span>
               System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;IP=&#34;</span> <span style=color:#f92672>+</span> entry<span style=color:#f92672>.</span><span style=color:#a6e22e>getKey</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: RATE=&#34;</span> <span style=color:#f92672>+</span> percent <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;%&#34;</span><span style=color:#f92672>);</span>
           <span style=color:#f92672>}</span>
       <span style=color:#f92672>}</span>
   
       <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
           ConsistentHashing ch <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConsistentHashing<span style=color:#f92672>();</span>
   
           <span style=color:#75715e>// 初始情况
</span><span style=color:#75715e></span>           ch<span style=color:#f92672>.</span><span style=color:#a6e22e>dumpObjectNodeMap</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;初始情况&#34;</span><span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> 65536<span style=color:#f92672>);</span>
   
           <span style=color:#75715e>// 删除物理节点
</span><span style=color:#75715e></span>           ch<span style=color:#f92672>.</span><span style=color:#a6e22e>removePhysicalNode</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;192.168.1.105&#34;</span><span style=color:#f92672>);</span>
           ch<span style=color:#f92672>.</span><span style=color:#a6e22e>dumpObjectNodeMap</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;删除物理节点&#34;</span><span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> 65536<span style=color:#f92672>);</span>
   
           <span style=color:#75715e>// 添加物理节点
</span><span style=color:#75715e></span>           ch<span style=color:#f92672>.</span><span style=color:#a6e22e>addPhysicalNode</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;192.168.1.107&#34;</span><span style=color:#f92672>);</span>
           ch<span style=color:#f92672>.</span><span style=color:#a6e22e>dumpObjectNodeMap</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;添加物理节点&#34;</span><span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> 65536<span style=color:#f92672>);</span>
       <span style=color:#f92672>}</span>
   <span style=color:#f92672>}</span>
</code></pre></div><p>复制倍数为 1 时的均衡性（VIRTUAL_COPIES = 1）</p><pre><code>  ======== 初始情况 ========
  IP=192.168.1.101: RATE=28%
  IP=192.168.1.102: RATE=3%
  IP=192.168.1.103: RATE=28%
  IP=192.168.1.104: RATE=19%
  IP=192.168.1.105: RATE=16%
  IP=192.168.1.106: RATE=2%
  ======== 删除物理节点 ========
  IP=192.168.1.101: RATE=45%
  IP=192.168.1.102: RATE=3%
  IP=192.168.1.103: RATE=28%
  IP=192.168.1.104: RATE=19%
  IP=192.168.1.106: RATE=2%
  ======== 添加物理节点 ========
  IP=192.168.1.101: RATE=45%
  IP=192.168.1.102: RATE=3%
  IP=192.168.1.103: RATE=25%
  IP=192.168.1.104: RATE=19%
  IP=192.168.1.106: RATE=2%
  IP=192.168.1.107: RATE=3%
</code></pre><p>复制倍数为 32 时的均衡性（VIRTUAL_COPIES = 32）</p><pre><code> ======== 初始情况 ========
 IP=192.168.1.101: RATE=17%
 IP=192.168.1.102: RATE=12%
 IP=192.168.1.103: RATE=23%
 IP=192.168.1.104: RATE=12%
 IP=192.168.1.105: RATE=12%
 IP=192.168.1.106: RATE=21%
 ======== 删除物理节点 ========
 IP=192.168.1.101: RATE=17%
 IP=192.168.1.102: RATE=12%
 IP=192.168.1.103: RATE=25%
 IP=192.168.1.104: RATE=23%
 IP=192.168.1.106: RATE=21%
 ======== 添加物理节点 ========
 IP=192.168.1.101: RATE=16%
 IP=192.168.1.102: RATE=12%
 IP=192.168.1.103: RATE=14%
 IP=192.168.1.104: RATE=23%
 IP=192.168.1.106: RATE=15%
 IP=192.168.1.107: RATE=17%
</code></pre><p>复制倍数为 1M 时的均衡性（VIRTUAL_COPIES = 1048576）</p><pre><code> ======== 初始情况 ========
 IP=192.168.1.101: RATE=16%
 IP=192.168.1.102: RATE=16%
 IP=192.168.1.103: RATE=16%
 IP=192.168.1.104: RATE=16%
 IP=192.168.1.105: RATE=16%
 IP=192.168.1.106: RATE=16%
 ======== 删除物理节点 ========
 IP=192.168.1.101: RATE=19%
 IP=192.168.1.102: RATE=19%
 IP=192.168.1.103: RATE=20%
 IP=192.168.1.104: RATE=19%
 IP=192.168.1.106: RATE=19%
 ======== 添加物理节点 ========
 IP=192.168.1.101: RATE=16%
 IP=192.168.1.102: RATE=16%
 IP=192.168.1.103: RATE=16%
 IP=192.168.1.104: RATE=16%
 IP=192.168.1.106: RATE=16%
 IP=192.168.1.107: RATE=16%
</code></pre><h4><a href=https://pinkhello.github.io/>Back to Home</a></h4></div></div><footer class=container><hr class=soften><p><a href=https://pinkhello.github.io/>hugo.386 theme</a> |
&copy;
<a href=https://pinkhello.github.io/ target=_blank>一杯哈希不加盐</a>
<span id=thisyear>2020</span>
| Built on <a href=//gohugo.io target=_blank>Hugo</a></p><p class=text-center><a href=https://github.com/PinkHello>GitHub</a></p></footer></body><link rel=stylesheet href=/css/bootstrap.css><link rel=stylesheet href=/css/bootstrap-responsive.css><link rel=stylesheet href=/css/style.css><script src=/js/jquery.js></script><script src=/js/bootstrap-386.js></script><script src=/js/bootstrap-transition.js></script><script src=/js/bootstrap-alert.js></script><script src=/js/bootstrap-modal.js></script><script src=/js/bootstrap-dropdown.js></script><script src=/js/bootstrap-scrollspy.js></script><script src=/js/bootstrap-tab.js></script><script src=/js/bootstrap-tooltip.js></script><script src=/js/bootstrap-popover.js></script><script src=/js/bootstrap-button.js></script><script src=/js/bootstrap-collapse.js></script><script src=/js/bootstrap-carousel.js></script><script src=/js/bootstrap-typeahead.js></script><script src=/js/bootstrap-affix.js></script><script>_386={fastLoad:false,onePass:false,speedFactor:1};function ThisYear(){document.getElementById('thisyear').innerHTML=new Date().getFullYear();};</script></html>