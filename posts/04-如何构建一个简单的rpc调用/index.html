<!doctype html><html lang=en><head><title>一杯哈希不加盐</title><meta charset=utf-8><meta content="utf-8" http-equiv=encoding><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#000084"><link rel=icon href=https://pinkhello.github.io//favicon.ico><link rel=canonical href=https://pinkhello.github.io/></head><body><nav class="navbar navbar-inverse navbar-fixed-top"><div class=navbar-inner><div class=container><button type=button class="btn btn-navbar" data-toggle=collapse data-target=.nav-collapse></button>
<a class=brand href=https://pinkhello.github.io/>一杯哈希不加盐</a><div class="nav-collapse collapse"><ul class=nav><li><a href=/about/><span>About</span></a></li><li><a href=/posts/><span>Archive</span></a></li></ul></div></div></div></nav><div id=content class=container><div class="row-fluid navmargin"><div class=page-header><h1>04 如何构建一个简单的RPC调用 - Wed, Feb 10, 2021</h1></div><p class=lead></p><p>1、什么叫RPC?</p><p><img src=/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BARPC%E8%B0%83%E7%94%A8/RPC%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E8%BF%87%E7%A8%8B.jpg alt=RPC调用服务过程></p><p>RPC构成</p><ul><li>RPC Consumer</li><li>RPC Provider</li><li>ConfigServer</li></ul><ul><li>1、<code>Provider</code> 启动 <code>ConfigServer</code> 注册服务</li><li>2、<code>Consumer</code> 启动 <code>ConfigServer</code> 订阅服务，</li><li>3、发起调用 <code>Consumer</code> &mdash;> <code>Provider</code></li><li>4、响应调用 <code>Consumer</code> &lt;&mdash; <code>Provider</code></li></ul><p>2、什么是 <code>Netty</code> ? <a href=https://netty.io/>https://netty.io/</a></p><p><img src=/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BARPC%E8%B0%83%E7%94%A8/netty%E6%A1%86%E6%9E%B6%E5%9B%BE.png alt=netty框架图></p><p>3、现有的开源的项目是否使用了 <code>Netty</code> ?</p><ul><li>Dubbo</li><li>Grpc</li><li>Spark</li><li>&mldr;.</li></ul><p>4、<code>RPC Provider</code> 启动</p><ul><li><code>Netty Server</code> 方式启动</li><li><code>Rpc</code> 服务的注册
<img src=/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BARPC%E8%B0%83%E7%94%A8/RPC%E4%B8%8ENetty%E7%BB%93%E5%90%88Provider%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png alt=RPC与Netty结合Provider调用过程></li></ul><p>5、<code>RPC Consumer</code> 启动</p><ul><li><code>Netty Client</code> 方式启动</li><li><code>RPC</code> 泛化调用、通过字节码基于反射来实现远程调度</li><li><code>Consumer</code> 服务订阅</li><li>启动时建立长连接
<img src=/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BARPC%E8%B0%83%E7%94%A8/RPC%E4%B8%8ENetty%E7%BB%93%E5%90%88Consumer%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png alt=RPC与Netty结合Consumer调用过程></li></ul><p>6、从第四可以看出，多个 <code>Provider</code> 是由一个 <code>NettyServer</code> 提供的，通过 <code>HandlerMap</code> 映射找到对应的 <code>Ioc Bean</code>，完成服务调用</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>服务端

EventLoopGroup bossGroup <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NioEventLoopGroup<span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
EventLoopGroup workerGroup <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NioEventLoopGroup<span style=color:#f92672>();</span>
<span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
    ServerBootstrap b <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerBootstrap<span style=color:#f92672>();</span>
    b<span style=color:#f92672>.</span><span style=color:#a6e22e>group</span><span style=color:#f92672>(</span>bossGroup<span style=color:#f92672>,</span> workerGroup<span style=color:#f92672>)</span>
     <span style=color:#f92672>.</span><span style=color:#a6e22e>channel</span><span style=color:#f92672>(</span>NioServerSocketChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
     <span style=color:#f92672>.</span><span style=color:#a6e22e>option</span><span style=color:#f92672>(</span>ChannelOption<span style=color:#f92672>.</span><span style=color:#a6e22e>SO_BACKLOG</span><span style=color:#f92672>,</span> 100<span style=color:#f92672>)</span>
     <span style=color:#f92672>.</span><span style=color:#a6e22e>handler</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> LoggingHandler<span style=color:#f92672>(</span>LogLevel<span style=color:#f92672>.</span><span style=color:#a6e22e>INFO</span><span style=color:#f92672>))</span>
     <span style=color:#f92672>.</span><span style=color:#a6e22e>childHandler</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ChannelInitializer<span style=color:#f92672>&lt;</span>SocketChannel<span style=color:#f92672>&gt;()</span> <span style=color:#f92672>{</span>
        <span style=color:#a6e22e>@Override</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initChannel</span><span style=color:#f92672>(</span>SocketChannel ch<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
            ChannelPipeline p <span style=color:#f92672>=</span> ch<span style=color:#f92672>.</span><span style=color:#a6e22e>pipeline</span><span style=color:#f92672>();</span>
            p<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RpcEncoder<span style=color:#f92672>(</span>RpcRequest<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>));</span>
            p<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RpcDecoder<span style=color:#f92672>(</span>RpcResponse<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>));</span>
            p<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RpcHandler<span style=color:#f92672>());</span>
        <span style=color:#f92672>}});</span>
     <span style=color:#75715e>// Start the server.
</span><span style=color:#75715e></span>     ChannelFuture f <span style=color:#f92672>=</span> b<span style=color:#f92672>.</span><span style=color:#a6e22e>bind</span><span style=color:#f92672>(</span>PORT<span style=color:#f92672>).</span><span style=color:#a6e22e>sync</span><span style=color:#f92672>();</span>
     <span style=color:#75715e>// Wait until the server socket is closed.
</span><span style=color:#75715e></span>     f<span style=color:#f92672>.</span><span style=color:#a6e22e>channel</span><span style=color:#f92672>().</span><span style=color:#a6e22e>closeFuture</span><span style=color:#f92672>().</span><span style=color:#a6e22e>sync</span><span style=color:#f92672>();</span>
<span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>// Shut down all event loops to terminate all threads.
</span><span style=color:#75715e></span>    bossGroup<span style=color:#f92672>.</span><span style=color:#a6e22e>shutdownGracefully</span><span style=color:#f92672>();</span>
    workerGroup<span style=color:#f92672>.</span><span style=color:#a6e22e>shutdownGracefully</span><span style=color:#f92672>();</span>
<span style=color:#f92672>}</span>
</code></pre></div><p><img src=/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BARPC%E8%B0%83%E7%94%A8/Netty%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AFTCP%E9%93%BE%E6%8E%A5%E4%B8%8A%E7%9A%84%E8%AF%B7%E6%B1%82.jpg alt=Netty如何处理客户端TCP链接上的请求></p><p><img src=/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BARPC%E8%B0%83%E7%94%A8/NettyReactor%E5%B7%A5%E4%BD%9C%E6%A1%86%E6%9E%B6%E5%9B%BE.jpg alt=NettyReactor工作框架图></p><ul><li><code>BossGroup</code> -> 处理客户端的请求</li><li><code>EventGroup</code> —> 处理IO <code>Read/Write</code> 操作、执行任务系统Task、定时任务</li><li><code>ChildChannelHandler</code> 方式是对 <code>ChannelPipeline</code> 的设置、</li><li><code>ChannelPipeline</code> 是相当于任务链的模式, 是一串 <code>ChannelHandler</code> 的实例</li><li><code>ChannelHandlerContext</code> 是 <code>ChannelPipeline</code> 和 <code>ChannelHandler</code> 的关系</li><li>每个链接对于 <code>Sever</code> 端都会创建一个 <code>Channel</code> ，可以将 <code>Channel</code> 理解为 <code>Connection</code> （其实真正的是 <code>Connection</code> 属于 <code>Channel</code> 的一部分）</li><li>每个 <code>Channel</code> 都有一个自己的唯一的 <code>ChannelPipeline</code> 操作，对于其他的 <code>Channel</code> 的 <code>ChannelPipeline</code> 是隔离的</li><li><code>RPC Handler</code> 是我们对于自己的找寻 <code>RPC</code> 服务处理的 <code>Handler</code> 实现</li><li><code>RPC Encoder</code> 是我们对于自己的找寻 <code>RPC</code> 序列化的编码的 <code>Handler</code> 实现</li><li><code>RPC Decoder</code> 是我们对于自己的找寻 <code>RPC</code> 序列化的解码的 <code>Handler</code> 实现</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>客户端
 
 EventLoopGroup group <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NioEventLoopGroup<span style=color:#f92672>();</span>
 <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
     Bootstrap b <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Bootstrap<span style=color:#f92672>();</span>
     b<span style=color:#f92672>.</span><span style=color:#a6e22e>group</span><span style=color:#f92672>(</span>group<span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span><span style=color:#a6e22e>channel</span><span style=color:#f92672>(</span>NioSocketChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span><span style=color:#a6e22e>option</span><span style=color:#f92672>(</span>ChannelOption<span style=color:#f92672>.</span><span style=color:#a6e22e>TCP_NODELAY</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span><span style=color:#a6e22e>handler</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ChannelInitializer<span style=color:#f92672>&lt;</span>SocketChannel<span style=color:#f92672>&gt;()</span> <span style=color:#f92672>{</span>
        <span style=color:#a6e22e>@Override</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initChannel</span><span style=color:#f92672>(</span>SocketChannel ch<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
         ChannelPipeline p <span style=color:#f92672>=</span> ch<span style=color:#f92672>.</span><span style=color:#a6e22e>pipeline</span><span style=color:#f92672>();</span>
         p<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RpcEncoder<span style=color:#f92672>(</span>RpcResponse<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>));</span>
         p<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RpcDecoder<span style=color:#f92672>(</span>RpcRequest<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>));</span>
         p<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RpcClientHandler<span style=color:#f92672>());</span>
        <span style=color:#f92672>}});</span>
     <span style=color:#75715e>// Start the client.
</span><span style=color:#75715e></span>     ChannelFuture f <span style=color:#f92672>=</span> b<span style=color:#f92672>.</span><span style=color:#a6e22e>connect</span><span style=color:#f92672>(</span>HOST<span style=color:#f92672>,</span> PORT<span style=color:#f92672>).</span><span style=color:#a6e22e>sync</span><span style=color:#f92672>();</span>
     <span style=color:#75715e>// Wait until the connection is closed.
</span><span style=color:#75715e></span>     f<span style=color:#f92672>.</span><span style=color:#a6e22e>channel</span><span style=color:#f92672>().</span><span style=color:#a6e22e>closeFuture</span><span style=color:#f92672>().</span><span style=color:#a6e22e>sync</span><span style=color:#f92672>();</span>
 <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
     <span style=color:#75715e>// Shut down the event loop to terminate all threads.
</span><span style=color:#75715e></span>     group<span style=color:#f92672>.</span><span style=color:#a6e22e>shutdownGracefully</span><span style=color:#f92672>();</span>
 <span style=color:#f92672>}</span>
</code></pre></div><p>7、<code>RPC</code> 序列化</p><ul><li>二进制数据</li><li>Hessian</li><li>Avro</li><li>ProtoBuffer (Protobuf)</li><li>JSON</li><li>XML</li></ul><p>8、关于 <code>RPC</code> 的实现思考与技术讨论</p><ul><li>业务方法、因为是收到请求消息而触发的后续动作调用，不做额外设置，肯定是使用的 <code>WorkGroup</code> 里面的线程操作的。
而作为业务层，不应该与底层关联，应该切割开来，势必会引入真的业务侧线程池。
那么如何引用、怎么引用？(关于 业务线程池 与 <code>WorkGroup</code> 的 <code>EvenLoop</code> 的思考 )</li><li>关于 <code>RPC</code> 调用大部分是同步的调用，而 <code>Netty</code> 底层是完全异步事件机制，在RPC框架层面如何实现同步的调用方式的？</li><li>基于 <code>TCP</code> 的长链接调用，在 <code>RPC</code> 上你会想到其他的哪些东东？</li><li>在此环境下，我没有介绍 <code>RPC</code> 服务于 IOC容器的结合，可以思考一下，如何做到 注解机制、<code>JAVA CONFIG</code> 机制、<code>XML SCHEMA</code> 机制来做?<ul><li>GUICE</li><li>SPRING</li><li>SPI</li><li>&mldr;.</li></ul></li></ul><h4><a href=https://pinkhello.github.io/>Back to Home</a></h4></div></div><footer class=container><hr class=soften><p><a href=https://pinkhello.github.io/>hugo.386 theme</a> |
&copy;
<a href=https://pinkhello.github.io/ target=_blank>一杯哈希不加盐</a>
<span id=thisyear>2020</span>
| Built on <a href=//gohugo.io target=_blank>Hugo</a></p><p class=text-center><a href=https://github.com/PinkHello>GitHub</a></p></footer></body><link rel=stylesheet href=/css/bootstrap.css><link rel=stylesheet href=/css/bootstrap-responsive.css><link rel=stylesheet href=/css/style.css><script src=/js/jquery.js></script><script src=/js/bootstrap-386.js></script><script src=/js/bootstrap-transition.js></script><script src=/js/bootstrap-alert.js></script><script src=/js/bootstrap-modal.js></script><script src=/js/bootstrap-dropdown.js></script><script src=/js/bootstrap-scrollspy.js></script><script src=/js/bootstrap-tab.js></script><script src=/js/bootstrap-tooltip.js></script><script src=/js/bootstrap-popover.js></script><script src=/js/bootstrap-button.js></script><script src=/js/bootstrap-collapse.js></script><script src=/js/bootstrap-carousel.js></script><script src=/js/bootstrap-typeahead.js></script><script src=/js/bootstrap-affix.js></script><script>_386={fastLoad:false,onePass:false,speedFactor:1};function ThisYear(){document.getElementById('thisyear').innerHTML=new Date().getFullYear();};</script></html>