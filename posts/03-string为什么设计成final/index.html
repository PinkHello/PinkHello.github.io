<!doctype html><html lang=en><head><title>一杯哈希不加盐</title><meta charset=utf-8><meta content="utf-8" http-equiv=encoding><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=theme-color content="#000084"><link rel=icon href=https://pinkhello.github.io//favicon.ico><link rel=canonical href=https://pinkhello.github.io/></head><body><nav class="navbar navbar-inverse navbar-fixed-top"><div class=navbar-inner><div class=container><button type=button class="btn btn-navbar" data-toggle=collapse data-target=.nav-collapse></button>
<a class=brand href=https://pinkhello.github.io/>一杯哈希不加盐</a><div class="nav-collapse collapse"><ul class=nav><li><a href=/about/><span>About</span></a></li><li><a href=/posts/><span>Archive</span></a></li></ul></div></div></div></nav><div id=content class=container><div class="row-fluid navmargin"><div class=page-header><h1>03 String为什么设计成final - Wed, Feb 10, 2021</h1></div><p class=lead></p><h1 id=string源码剖析><code>String</code>源码剖析</h1><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>String</span>
    <span style=color:#66d9ef>implements</span> java<span style=color:#f92672>.</span><span style=color:#a6e22e>io</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Serializable</span><span style=color:#f92672>,</span> Comparable<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;,</span> CharSequence <span style=color:#f92672>{</span>
    
    <span style=color:#75715e>/** The value is used for character storage. */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>char</span> value<span style=color:#f92672>[];</span>
    
    <span style=color:#75715e>/** Cache the hash code for the string */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> hash<span style=color:#f92672>;</span> <span style=color:#75715e>// Default to 0 
</span><span style=color:#75715e></span>    
    <span style=color:#75715e>/** use serialVersionUID from JDK 1.0.2 for interoperability */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> serialVersionUID <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>6849794470754667710L<span style=color:#f92672>;</span>   
    
    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Class String is special cased within the Serialization Stream Protocol.
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     * A String instance is written into an ObjectOutputStream according to
</span><span style=color:#75715e>     * &lt;a href=&#34;{@docRoot}/../platform/serialization/spec/output.html&#34;&gt;
</span><span style=color:#75715e>     * Object Serialization Specification, Section 6.2, &#34;Stream Elements&#34;&lt;/a&gt;
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> ObjectStreamField<span style=color:#f92672>[]</span> serialPersistentFields <span style=color:#f92672>=</span>
        <span style=color:#66d9ef>new</span> ObjectStreamField<span style=color:#f92672>[</span>0<span style=color:#f92672>];</span>    
<span style=color:#f92672>}</span>
</code></pre></div><p><code>String</code> 如何保证 不可变的呢？</p><blockquote><p>字符数组使用了 <code>final</code> 修饰，这也只是表示了 字符数组的引用地址不可变，并不代表内容不可变。
其使用 <code>private</code> 修饰，外部没有入口达到变动，从而保证了 String 的不可变性</p></blockquote><p>为什么保证 <code>String</code> 是 <code>final</code> 的呢？特点：</p><blockquote><ul><li>因为只有保证 <code>String</code> 是 <code>final</code> 的呢 <strong>只有当字符串不可变的，字符串池才可能实现</strong>;字符串池的实现可以节省很多的 <code>Heap</code>空间，因为不同的字符串变量都指向池中的同一个字符串.</li><li>假如字符串可变，那么<code>String</code> <code>interning</code> 不能实现，那么变量改变了这个字符串的值，那么其他指向这个值的变量的值也改变了。 （安全问题来了，用户名密码，端口、IP等）</li><li>字符串不可变，多线程安全，同一个字符串实例可以被对歌线程共享，不需要考虑同步问题</li><li>上面看出，在字符串不可变的情况下，创建的时候 <code>hashcode</code>也被缓存了，不需要重新计算。一部分性能问题可以很好的选择字符串</li></ul></blockquote><h1 id=string-在-jvm-层理解-拓展><code>String</code> 在 <code>JVM</code> 层理解 拓展</h1><p><code>JVM</code> 层面有 虚拟机栈、本地方法栈、堆、程序计数器、元数据区(方法区)
<img src=/String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%88%90final%E5%BD%A2%E6%80%81/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png alt=运行时数据区></p><ul><li>字符串创建形式</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>String s1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>;</span>
String s2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>);</span>
</code></pre></div><blockquote><ul><li>编译期间 &ldquo;1&rdquo; 作为常量进入字符串常量池（这时候是静态常量池）;</li><li>当编译 <code>s1</code> 时候，将 <code>s1</code> 推进局部变量区（栈帧内部）; 先判断 &ldquo;1&rdquo; 在字符串常量池在不在，不存在的话创建常量 &ldquo;1&rdquo; 加入常量池，并直接将 <code>s1</code> 指向字符串常量池的对象 &ldquo;1&rdquo; 地址；</li><li>当代码运行 <code>s2</code> 时候，使用的 <code>new</code> 字段，<code>JVM</code> 先检查字符串常量在常量池存不存在，如果已经存在，直接在堆中复制改对象的副本，并且将 <code>s2</code> 指向堆中的刚刚创建的对象地址。
如果不存在，则会实例化该字符串 &ldquo;1&rdquo; 并且将其放到常量池中（这时候是运行时常量池）,然后在堆中复制刚刚加入常量池对象的副本创建出新的对象，并将 <code>s2</code> 指向它</li></ul></blockquote><ul><li>&lsquo;+&lsquo;号连接的字符串</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>String s1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>+</span><span style=color:#e6db74>&#34;2&#34;</span><span style=color:#f92672>+</span><span style=color:#e6db74>&#34;3&#34;</span><span style=color:#f92672>;</span>
</code></pre></div><blockquote><ul><li>编译期间就能确定，直接作为 &ldquo;123&rdquo; 的常量进入常量池;</li></ul></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>String s2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>+</span><span style=color:#e6db74>&#34;2&#34;</span><span style=color:#f92672>+</span><span style=color:#66d9ef>new</span> String<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;3&#34;</span><span style=color:#f92672>)+</span><span style=color:#e6db74>&#34;4&#34;</span><span style=color:#f92672>;</span>
</code></pre></div><blockquote><ul><li>当 &lsquo;+&rsquo; 中间有变量时候，也只能在运行期才能确定，但是在编译期间会尽量的将字符串常量连接起来，形成新的字符串常量;</li><li>反编译后 <code>String s2 = new StringBuilder("12").append(new String("3"")).append("4").toString()</code>;</li><li>也就是说用 &lsquo;+&rsquo; 连接中间有变量的时候，&ldquo;13&rdquo;, &ldquo;3&rdquo;, &ldquo;4&rdquo; 在常量池中，在堆中有 <code>StringBuilder("1234")</code>, <code>String("4")</code>,以及<code>toString</code>后产生的<code>String</code>对象</li></ul></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>String s3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;3&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;3&#34;</span><span style=color:#f92672>);</span>
</code></pre></div><blockquote><ul><li>&ldquo;3&rdquo; 在常量池中（编译的时候）</li><li>运行时，在堆中产生 &ldquo;3&rdquo; 的副本两个 <code>String</code> 对象，并产生 <code>StringBuilder("11")</code> 对象以及 <code>toString</code> 的 <code>String</code> 对象</li></ul></blockquote><h4><a href=https://pinkhello.github.io/>Back to Home</a></h4></div></div><footer class=container><hr class=soften><p><a href=https://pinkhello.github.io/>hugo.386 theme</a> |
&copy;
<a href=https://pinkhello.github.io/ target=_blank>一杯哈希不加盐</a>
<span id=thisyear>2020</span>
| Built on <a href=//gohugo.io target=_blank>Hugo</a></p><p class=text-center><a href=https://github.com/PinkHello>GitHub</a></p></footer></body><link rel=stylesheet href=/css/bootstrap.css><link rel=stylesheet href=/css/bootstrap-responsive.css><link rel=stylesheet href=/css/style.css><script src=/js/jquery.js></script><script src=/js/bootstrap-386.js></script><script src=/js/bootstrap-transition.js></script><script src=/js/bootstrap-alert.js></script><script src=/js/bootstrap-modal.js></script><script src=/js/bootstrap-dropdown.js></script><script src=/js/bootstrap-scrollspy.js></script><script src=/js/bootstrap-tab.js></script><script src=/js/bootstrap-tooltip.js></script><script src=/js/bootstrap-popover.js></script><script src=/js/bootstrap-button.js></script><script src=/js/bootstrap-collapse.js></script><script src=/js/bootstrap-carousel.js></script><script src=/js/bootstrap-typeahead.js></script><script src=/js/bootstrap-affix.js></script><script>_386={fastLoad:false,onePass:false,speedFactor:1};function ThisYear(){document.getElementById('thisyear').innerHTML=new Date().getFullYear();};</script></html>