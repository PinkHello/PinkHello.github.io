<!doctype html><html><head><title>回望K8S 白话容器</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><meta property="og:title" content="回望K8S 白话容器"><meta property="og:description" content="进程开启 容器, 到底是什么?  前面提出: 容器是一种沙盒技术. 就是一个集装箱, 把应用装起来的技术. 这样, 应用与应用之间有了边界不至于互相干扰; 有了这些集装箱, 也方便搬来搬去.
 码农都知道可执行的二进制文件是代码的可执行镜像(executable image). 一旦程序执行起来, 内存数据、寄存器的值、堆栈的指令、打开的文件等这些集合汇集成一个程序的计算机执行环境总和: 进程.
进程: 静态表现是程序, 动态表现计算机的数据和状态的总和。
容器的核心功能, 就是通过约束和修改进程的动态表现, 从而为其创造一个&#34;边界&#34;.
 Cgroups 技术 制造约束的主要手段 Namespace 技术 修改进程视图的主要方法  docker run , -it 告诉 Docker 启动容器后, 需要分配一个文本输入/输出环境, 也就是 TTY, 跟容器的标准输入相关联, 这样我们就可以和这个Docker容器进行交互了。而 /bin/sh 就是我们在 Docker 容器里运行的程序.
> docker run -it busybox /bin/sh / # 帮我启动一个容器, 在容器里执行 /bin/sh, 并且给我分配一个命令行终端跟这个容器进行交互, 在这个执行环境下可以完全执行LINUX命令,且与宿主机完全隔离在不同的世界中.
Docker对被隔离应用的进程空间做了手脚, 使得这些进程只能看到重新计算的进程编号, 可是实际上, 他们在宿主机的操作系统里, 还是原来的第N号进程. 这种技术就是Linux内部的Namespace机制。
Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 clone()，比如："><meta property="og:type" content="article"><meta property="og:url" content="https://pinkhello.me/posts/18-%E5%9B%9E%E6%9C%9Bk8s-%E7%99%BD%E8%AF%9D%E5%AE%B9%E5%99%A8/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-15T10:16:34+08:00"><meta property="article:modified_time" content="2020-02-15T10:16:34+08:00"><meta property="og:site_name" content="PinkHello"><meta name=twitter:card content="summary"><meta name=twitter:title content="回望K8S 白话容器"><meta name=twitter:description content="进程开启 容器, 到底是什么?  前面提出: 容器是一种沙盒技术. 就是一个集装箱, 把应用装起来的技术. 这样, 应用与应用之间有了边界不至于互相干扰; 有了这些集装箱, 也方便搬来搬去.
 码农都知道可执行的二进制文件是代码的可执行镜像(executable image). 一旦程序执行起来, 内存数据、寄存器的值、堆栈的指令、打开的文件等这些集合汇集成一个程序的计算机执行环境总和: 进程.
进程: 静态表现是程序, 动态表现计算机的数据和状态的总和。
容器的核心功能, 就是通过约束和修改进程的动态表现, 从而为其创造一个&#34;边界&#34;.
 Cgroups 技术 制造约束的主要手段 Namespace 技术 修改进程视图的主要方法  docker run , -it 告诉 Docker 启动容器后, 需要分配一个文本输入/输出环境, 也就是 TTY, 跟容器的标准输入相关联, 这样我们就可以和这个Docker容器进行交互了。而 /bin/sh 就是我们在 Docker 容器里运行的程序.
> docker run -it busybox /bin/sh / # 帮我启动一个容器, 在容器里执行 /bin/sh, 并且给我分配一个命令行终端跟这个容器进行交互, 在这个执行环境下可以完全执行LINUX命令,且与宿主机完全隔离在不同的世界中.
Docker对被隔离应用的进程空间做了手脚, 使得这些进程只能看到重新计算的进程编号, 可是实际上, 他们在宿主机的操作系统里, 还是原来的第N号进程. 这种技术就是Linux内部的Namespace机制。
Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 clone()，比如："><script src=/vendor/js/jquery.min.js></script><script src=/vendor/js/popper.min.js></script><script src=/vendor/js/bootstrap.min.js></script><script src=/vendor/js/smooth-scroll.polyfills.min.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script><link rel=stylesheet href=https://pinkhello.me/scss/journal.min.5e8f3f653e9f6ce67bf72ff8ee6fee69decf7b5639a3ae7f8344750ad4e065b1.css integrity="sha256-Xo8/ZT6fbOZ79y/47m/uad7Pe1Y5o65/g0R1CtTgZbE=" media=screen><link rel=stylesheet href=https://pinkhello.me/scss/dark-mode.min.bdfa63b2e89903517dcbb1032b537d54cff3f425c19d008a78dfe49e6cd07ced.css integrity="sha256-vfpjsuiZA1F9y7EDK1N9VM/z9CXBnQCKeN/knmzQfO0=" media=screen><script src=https://pinkhello.me//js/loadCSS.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons")</script><script src=https://pinkhello.me//js/toc-collapse.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script src=/vendor/js/md5.min.js></script><script>var gitalk=new Gitalk({clientID:'8c0085cae1e614334721',clientSecret:'7a38150ae970beb3b45a710466594003ee659b6c',repo:'PinkHello.github.io',owner:'PinkHello',admin:['PinkHello'],id:md5(location.pathname),distractionFreeMode:'false',proxy:'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'});window.onload=function(){gitalk.render('gitalk-container')}</script></head><body><div id=app><div ref=sideContainer class=side-container><a class="a-block nav-head false" href=https://pinkhello.me/><div class=nav-title>PinkHello</div><div class=nav-subtitle>做一个快乐的程序猿</div></a><div class=nav-link-list><a class="a-block nav-link-item false" href=/about>关于我</a>
<a class="a-block nav-link-item active" href=/posts>文章</a>
<a class="a-block nav-link-item false" href=/categories>类目</a>
<a class="a-block nav-link-item false" href=/tags>标签</a>
<a class="a-block nav-link-item false" href=/links>链接</a>
<a class="a-block nav-link-item false" href=/index.xml>RSS Feed</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
PinkHello, All Rights Reserved</div></div><div ref=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- 目录 -</center><ul><li><a href=#%e8%bf%9b%e7%a8%8b%e5%bc%80%e5%90%af onclick="onNavClick(`#进程开启-nav`)" id=进程开启-nav>进程开启</a></li><ul class=collapse data-toggle=collapse><li><a href=#%e5%ae%b9%e5%99%a8-%e5%88%b0%e5%ba%95%e6%98%af%e4%bb%80%e4%b9%88 onclick="onNavClick(`#容器-到底是什么-nav`)" id=容器-到底是什么-nav>容器, 到底是什么?</a></li></ul><li><a href=#%e9%9a%94%e7%a6%bb%e5%92%8c%e9%99%90%e5%88%b6 onclick="onNavClick(`#隔离和限制-nav`)" id=隔离和限制-nav>隔离和限制</a></li><ul class=collapse data-toggle=collapse><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e9%9a%94%e7%a6%bb onclick="onNavClick(`#为什么需要隔离-nav`)" id=为什么需要隔离-nav>为什么需要隔离</a></li><li><a href=#%e4%b8%8a%e8%bf%b0%e6%98%af%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e9%9a%94%e7%a6%bb%e4%b8%8b%e9%9d%a2%e8%af%b4%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e9%99%90%e5%88%b6%e8%bf%99%e4%b8%aa%e9%97%ae%e9%a2%98 onclick="onNavClick(`#上述是为什么要隔离下面说为什么要限制这个问题-nav`)" id=上述是为什么要隔离下面说为什么要限制这个问题-nav>上述是为什么要隔离，下面说为什么要限制这个问题。</a></li></ul><li><a href=#%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f onclick="onNavClick(`#容器镜像-nav`)" id=容器镜像-nav>容器镜像</a></li><ul class=collapse data-toggle=collapse><li><a href=#%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84%e8%bf%9b%e7%a8%8b%e7%9c%8b%e5%88%b0%e7%9a%84%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e5%8f%88%e6%98%af%e4%bb%80%e4%b9%88%e6%a0%b7%e5%ad%90%e7%9a%84%e5%91%a2 onclick="onNavClick(`#容器中的进程看到的文件系统又是什么样子的呢-nav`)" id=容器中的进程看到的文件系统又是什么样子的呢-nav>容器中的进程看到的文件系统又是什么样子的呢？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%ae%b9%e5%99%a8%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e5%91%a2 onclick="onNavClick(`#什么是容器的一致性呢-nav`)" id=什么是容器的一致性呢-nav>什么是容器的一致性呢？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e6%af%8f%e6%ac%a1%e5%8d%87%e7%ba%a7%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e9%87%8d%e5%a4%8d%e5%88%b6%e4%bd%9c-rootfs-%e7%9a%84%e9%97%ae%e9%a2%98%e5%91%a2 onclick="onNavClick(`#如何解决每次升级如何解决重复制作-rootfs-的问题呢-nav`)" id=如何解决每次升级如何解决重复制作-rootfs-的问题呢-nav>如何解决每次升级，如何解决重复制作 rootfs 的问题呢？</a></li><li><a href=#docker-layer%e6%a6%82%e5%bf%b5 onclick="onNavClick(`#docker-layer概念-nav`)" id=docker-layer概念-nav>docker layer概念</a></li></ul><li><a href=#docker%e5%ae%b9%e5%99%a8 onclick="onNavClick(`#docker容器-nav`)" id=docker容器-nav>Docker容器</a></li><ul class=collapse data-toggle=collapse><li><a href=#docker-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%ae%b9%e5%99%a8%e7%9a%84 onclick="onNavClick(`#docker-如何实现容器的-nav`)" id=docker-如何实现容器的-nav>docker 如何实现容器的</a></li><li><a href=#%e5%bc%80%e5%8f%91%e7%9a%84%e5%ba%94%e7%94%a8%e7%9a%84%e5%a6%82%e4%bd%95%e5%ae%b9%e5%99%a8%e5%8c%96%e7%9a%84%e6%ad%a5%e9%aa%a4 onclick="onNavClick(`#开发的应用的如何容器化的步骤-nav`)" id=开发的应用的如何容器化的步骤-nav>开发的应用的如何容器化的步骤</a></li><ul class=collapse data-toggle=collapse><li><a href=#1dockerfile-%e5%88%b6%e4%bd%9c%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f onclick="onNavClick(`#1dockerfile-制作容器镜像-nav`)" id=1dockerfile-制作容器镜像-nav>1、Dockerfile 制作容器镜像</a></li><li><a href=#2volume-%e6%9c%ba%e5%88%b6%e5%85%81%e8%ae%b8%e5%b0%86%e5%ae%bf%e4%b8%bb%e6%9c%ba%e4%b8%8a%e7%9a%84%e6%8c%87%e5%ae%9a%e7%9a%84%e7%9b%ae%e5%bd%95%e6%88%96%e8%80%85%e6%96%87%e4%bb%b6%e6%8c%82%e8%bd%bd%e5%88%b0%e5%ae%b9%e5%99%a8%e9%87%8c%e9%9d%a2%e8%bf%9b%e8%a1%8c%e8%af%bb%e5%8f%96%e5%92%8c%e4%bf%ae%e6%94%b9 onclick="onNavClick(`#2volume-机制允许将宿主机上的指定的目录或者文件挂载到容器里面进行读取和修改-nav`)" id=2volume-机制允许将宿主机上的指定的目录或者文件挂载到容器里面进行读取和修改-nav>2、Volume 机制，允许将宿主机上的指定的目录或者文件挂载到容器里面进行读取和修改</a></li></ul></ul><li><a href=#kubernetes-%e6%9c%ac%e8%b4%a8 onclick="onNavClick(`#kubernetes-本质-nav`)" id=kubernetes-本质-nav>Kubernetes 本质</a></li><ul class=collapse data-toggle=collapse><li><a href=#%e5%9b%9e%e9%a1%be onclick="onNavClick(`#回顾-nav`)" id=回顾-nav>回顾</a></li><li><a href=#%e6%80%bb%e7%bb%93 onclick="onNavClick(`#总结-nav`)" id=总结-nav>总结</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e6%8a%80%e6%9c%af onclick="onNavClick(`#容器编排技术-nav`)" id=容器编排技术-nav>容器编排技术</a></li><ul class=collapse data-toggle=collapse><li><a href=#kubernetes-%e9%a1%b6%e5%b1%82%e8%ae%be%e8%ae%a1 onclick="onNavClick(`#kubernetes-顶层设计-nav`)" id=kubernetes-顶层设计-nav>Kubernetes 顶层设计</a></li></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a class=pagination-action v-on:click=toggleDarkMode><i class="material-icons pagination-action-icon" v-if=isDarkMode>brightness_4</i>
<i class="material-icons pagination-action-icon" v-else=isDarkMode>brightness_7</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item false" href=/about>关于我</a>
<a class="a-block drawer-menu-item active" href=/posts>文章</a>
<a class="a-block drawer-menu-item false" href=/categories>类目</a>
<a class="a-block drawer-menu-item false" href=/tags>标签</a>
<a class="a-block drawer-menu-item false" href=/links>链接</a>
<a class="a-block drawer-menu-item false" href=/index.xml>RSS Feed</a><div class=toc><div class=toc-content><center>- 目录 -</center><ul><li><a href=#%e8%bf%9b%e7%a8%8b%e5%bc%80%e5%90%af onclick="onNavClick(`#进程开启-nav`)" id=进程开启-nav>进程开启</a></li><ul class=collapse data-toggle=collapse><li><a href=#%e5%ae%b9%e5%99%a8-%e5%88%b0%e5%ba%95%e6%98%af%e4%bb%80%e4%b9%88 onclick="onNavClick(`#容器-到底是什么-nav`)" id=容器-到底是什么-nav>容器, 到底是什么?</a></li></ul><li><a href=#%e9%9a%94%e7%a6%bb%e5%92%8c%e9%99%90%e5%88%b6 onclick="onNavClick(`#隔离和限制-nav`)" id=隔离和限制-nav>隔离和限制</a></li><ul class=collapse data-toggle=collapse><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e9%9a%94%e7%a6%bb onclick="onNavClick(`#为什么需要隔离-nav`)" id=为什么需要隔离-nav>为什么需要隔离</a></li><li><a href=#%e4%b8%8a%e8%bf%b0%e6%98%af%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e9%9a%94%e7%a6%bb%e4%b8%8b%e9%9d%a2%e8%af%b4%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e9%99%90%e5%88%b6%e8%bf%99%e4%b8%aa%e9%97%ae%e9%a2%98 onclick="onNavClick(`#上述是为什么要隔离下面说为什么要限制这个问题-nav`)" id=上述是为什么要隔离下面说为什么要限制这个问题-nav>上述是为什么要隔离，下面说为什么要限制这个问题。</a></li></ul><li><a href=#%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f onclick="onNavClick(`#容器镜像-nav`)" id=容器镜像-nav>容器镜像</a></li><ul class=collapse data-toggle=collapse><li><a href=#%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84%e8%bf%9b%e7%a8%8b%e7%9c%8b%e5%88%b0%e7%9a%84%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e5%8f%88%e6%98%af%e4%bb%80%e4%b9%88%e6%a0%b7%e5%ad%90%e7%9a%84%e5%91%a2 onclick="onNavClick(`#容器中的进程看到的文件系统又是什么样子的呢-nav`)" id=容器中的进程看到的文件系统又是什么样子的呢-nav>容器中的进程看到的文件系统又是什么样子的呢？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%ae%b9%e5%99%a8%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e5%91%a2 onclick="onNavClick(`#什么是容器的一致性呢-nav`)" id=什么是容器的一致性呢-nav>什么是容器的一致性呢？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e6%af%8f%e6%ac%a1%e5%8d%87%e7%ba%a7%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e9%87%8d%e5%a4%8d%e5%88%b6%e4%bd%9c-rootfs-%e7%9a%84%e9%97%ae%e9%a2%98%e5%91%a2 onclick="onNavClick(`#如何解决每次升级如何解决重复制作-rootfs-的问题呢-nav`)" id=如何解决每次升级如何解决重复制作-rootfs-的问题呢-nav>如何解决每次升级，如何解决重复制作 rootfs 的问题呢？</a></li><li><a href=#docker-layer%e6%a6%82%e5%bf%b5 onclick="onNavClick(`#docker-layer概念-nav`)" id=docker-layer概念-nav>docker layer概念</a></li></ul><li><a href=#docker%e5%ae%b9%e5%99%a8 onclick="onNavClick(`#docker容器-nav`)" id=docker容器-nav>Docker容器</a></li><ul class=collapse data-toggle=collapse><li><a href=#docker-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%ae%b9%e5%99%a8%e7%9a%84 onclick="onNavClick(`#docker-如何实现容器的-nav`)" id=docker-如何实现容器的-nav>docker 如何实现容器的</a></li><li><a href=#%e5%bc%80%e5%8f%91%e7%9a%84%e5%ba%94%e7%94%a8%e7%9a%84%e5%a6%82%e4%bd%95%e5%ae%b9%e5%99%a8%e5%8c%96%e7%9a%84%e6%ad%a5%e9%aa%a4 onclick="onNavClick(`#开发的应用的如何容器化的步骤-nav`)" id=开发的应用的如何容器化的步骤-nav>开发的应用的如何容器化的步骤</a></li><ul class=collapse data-toggle=collapse><li><a href=#1dockerfile-%e5%88%b6%e4%bd%9c%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f onclick="onNavClick(`#1dockerfile-制作容器镜像-nav`)" id=1dockerfile-制作容器镜像-nav>1、Dockerfile 制作容器镜像</a></li><li><a href=#2volume-%e6%9c%ba%e5%88%b6%e5%85%81%e8%ae%b8%e5%b0%86%e5%ae%bf%e4%b8%bb%e6%9c%ba%e4%b8%8a%e7%9a%84%e6%8c%87%e5%ae%9a%e7%9a%84%e7%9b%ae%e5%bd%95%e6%88%96%e8%80%85%e6%96%87%e4%bb%b6%e6%8c%82%e8%bd%bd%e5%88%b0%e5%ae%b9%e5%99%a8%e9%87%8c%e9%9d%a2%e8%bf%9b%e8%a1%8c%e8%af%bb%e5%8f%96%e5%92%8c%e4%bf%ae%e6%94%b9 onclick="onNavClick(`#2volume-机制允许将宿主机上的指定的目录或者文件挂载到容器里面进行读取和修改-nav`)" id=2volume-机制允许将宿主机上的指定的目录或者文件挂载到容器里面进行读取和修改-nav>2、Volume 机制，允许将宿主机上的指定的目录或者文件挂载到容器里面进行读取和修改</a></li></ul></ul><li><a href=#kubernetes-%e6%9c%ac%e8%b4%a8 onclick="onNavClick(`#kubernetes-本质-nav`)" id=kubernetes-本质-nav>Kubernetes 本质</a></li><ul class=collapse data-toggle=collapse><li><a href=#%e5%9b%9e%e9%a1%be onclick="onNavClick(`#回顾-nav`)" id=回顾-nav>回顾</a></li><li><a href=#%e6%80%bb%e7%bb%93 onclick="onNavClick(`#总结-nav`)" id=总结-nav>总结</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e6%8a%80%e6%9c%af onclick="onNavClick(`#容器编排技术-nav`)" id=容器编排技术-nav>容器编排技术</a></li><ul class=collapse data-toggle=collapse><li><a href=#kubernetes-%e9%a1%b6%e5%b1%82%e8%ae%be%e8%ae%a1 onclick="onNavClick(`#kubernetes-顶层设计-nav`)" id=kubernetes-顶层设计-nav>Kubernetes 顶层设计</a></li></ul></div></div></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=https://pinkhello.me/>PinkHello</a>
<button type=button class=nav-darkmode-toggle v-on:click=toggleDarkMode>
<i class=material-icons v-if=isDarkMode>brightness_4</i>
<i class=material-icons v-else=isDarkMode>brightness_7</i></button></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://pinkhello.me/><div class=single-column-header-title>PinkHello</div><div class=single-column-header-subtitle>做一个快乐的程序猿</div></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>回望K8S 白话容器<div class=post-meta><time itemprop=datePublished>2020-02-15 10:16</time>
<i class=material-icons>folder</i>
<a href=/categories/k8s>k8s</a>
&nbsp;
<i class=material-icons>label</i>
<a href=/tags/k8s>k8s</a>
&nbsp;
<a href=/tags/%E5%AE%B9%E5%99%A8>容器</a>
&nbsp;
<i class=material-icons>schedule</i>
36 min
46 s.</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h1 id=进程开启>进程开启</h1><h2 id=容器-到底是什么>容器, 到底是什么?</h2><blockquote><p>前面提出: 容器是一种沙盒技术. 就是一个集装箱, 把应用装起来的技术. 这样, 应用与应用之间有了边界不至于互相干扰; 有了这些集装箱, 也方便搬来搬去.</p></blockquote><p>码农都知道可执行的二进制文件是代码的可执行镜像(<code>executable image</code>). 一旦程序执行起来, 内存数据、寄存器的值、堆栈的指令、打开的文件等这些集合汇集成一个程序的计算机执行环境总和: 进程.</p><p><code>进程</code>: 静态表现是程序, 动态表现计算机的数据和状态的总和。</p><p>容器的核心功能, 就是通过约束和修改进程的动态表现, 从而为其创造一个"边界".</p><ul><li><code>Cgroups 技术</code> 制造约束的主要手段</li><li><code>Namespace 技术</code> 修改进程视图的主要方法</li></ul><p><code>docker run</code> , <code>-it</code> 告诉 <code>Docker</code> 启动容器后, 需要分配一个文本输入/输出环境, 也就是 <code>TTY</code>, 跟容器的标准输入相关联, 这样我们就可以和这个<code>Docker</code>容器进行交互了。而 <code>/bin/sh</code> 就是我们在 <code>Docker</code> 容器里运行的程序.</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; docker run -it busybox /bin/sh
/ <span style=color:#228b22>#</span>
</code></pre></div><p>帮我启动一个容器, 在容器里执行 <code>/bin/sh</code>, 并且给我分配一个命令行终端跟这个容器进行交互, 在这个执行环境下可以完全执行<code>LINUX</code>命令,且与宿主机完全隔离在不同的世界中.</p><p><code>Docker</code>对被隔离应用的进程空间做了手脚, 使得这些进程只能看到重新计算的进程编号, 可是实际上, 他们在宿主机的操作系统里, 还是原来的第<code>N</code>号进程. 这种技术就是<code>Linux</code>内部的<code>Namespace</code>机制。</p><p><code>Namespace</code> 的使用方式也非常有意思：它其实只是 <code>Linux</code> 创建新进程的一个可选参数。我们知道，在 <code>Linux</code> 系统中创建线程的系统调用是 <code>clone()</code>，比如：</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>int <span style=color:#00688b>pid</span> = clone(main_function, stack_size, SIGCHLD, NULL);
</code></pre></div><p>这个系统调用就会创建一个新的进程，并且返回的它的进程号 pid。</p><p>当调用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，比如：</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>int <span style=color:#00688b>pid</span> = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);
</code></pre></div><p>这时，新创建的这个进程就会看到一个全新的进程空间，在这个进程空间里，他的<code>PID</code>是<code>1</code>，之所以说看到，是因为是一个障眼法，在宿主机真实的进程空间里，这个<code>PID</code>还是真实的数值.当多次执行<code>clone()</code>调用, 会创建多个 <code>PID Namespace</code>, 每个 Namespace 里的应用进程，都会认为自己是当前容器里的第<code>1</code>号进程，看不仅<code>宿主机</code>的也看不到其他的<code>Namespace</code>.</p><blockquote><p>备注:
Linux提供了不同的Namespace，去应对不同的进程上下文</p><ul><li>PID Namespace</li><li>Mount Namespace</li><li>IPC Namespace</li><li>UTS Namespace</li><li>Network Namespace</li><li>User Namespace</li></ul></blockquote><p>Docker容器，就是在创建容器进程时候，指定了这个进程所需要启用的一组 Namespace 参数, 这样, 容器就只能 看到 当前 Namespace 所限定的 资源、文件、设备、状态 或者 配置。所以说, 容器，其实是一种特殊的进程。</p><p><img src=/%E5%9B%9E%E6%9C%9BK8S/%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg alt=容器与虚拟机工作原理></p><p>可以看出图中 <code>Hypervisor</code> 是虚拟机主要部分。它通过硬件虚拟化功能，模拟出了运行一个操作系统需要的各种硬件，比如 CPU、内存、I/O设备等。 这样，用户的进程可以在这个虚拟的机器中，只能看到虚拟环境的文件和目录以及设备，起到隔离的作用。
而右边的图，<code>Docker Engine</code>替换了<code>Hypervisor</code>,但是有个核心一点<code>Docker Engine</code>并不少<code>轻量级</code>虚拟化技术。</p><p>在<code>Linux</code>的<code>Namespace</code>工作方式后, 在使用<code>Docker</code>的时候,<code>Docker</code>并没有一个真正的<code>Docker容器</code>运行在宿主机里面，而是<code>Docker</code>启动还是原来的应用进程，只不过在创建这些进程时候，加上了各种<code>Namespace</code>参数，使得这些进程觉得自己是在各自的<code>PID Namespace</code>是第一号进程，并且只能看到各自<code>Mount Namespace</code>里挂在的目录和文件、只能访问各自<code>Network Namespace</code>里的网络设备.</p><h1 id=隔离和限制>隔离和限制</h1><p>前面提到实现 <code>隔离</code> 的手段: <code>Namespace</code>. <code>Namespace</code> 技术实际修改了应用进程看待整个计算机的"视图"，即它的"视线"被操作系统做了限制，只能"看到"某些知道的内容.</p><h2 id=为什么需要隔离>为什么需要<code>隔离</code></h2><ul><li>首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。</li><li>在Linux内核中，还有许多资源和对象是不能被 Namespace 化的，最典型的例子是：时间<blockquote><p>容器中使用 settimeofday(2) 系统调用修改了时间，整个宿主机的时间都会被随之修改。这样肯定与预期不符</p></blockquote></li></ul><h2 id=上述是为什么要隔离下面说为什么要限制这个问题>上述是为什么要<code>隔离</code>，下面说为什么要<code>限制</code>这个问题。</h2><blockquote><p>在宿主机上,启动多个容器都是在宿主机上的特殊进程,但是在不同的进程之间, 资源（CPU、内存）还是可能被其他进程（或者容器）占用的。</p></blockquote><p><code>Linux Cgroups</code>全称<code>Linux Control Group</code> 就是 Linux 内核中用来为进程设置资源限制的一个重要功能, 限制一个进程组能够使用的资源上限, 包括 CPU、内存、磁盘、网络带宽 等等。此外 <code>Cgroups</code> 还能够对进程进行优先级设置、审计，以及将进程挂起和恢复操作。</p><p>在<code>Linux</code>中,<code>Cgroups</code>给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 <code>/sys/fs/cgroup</code> 路径下</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#228b22># Ubuntu 下 mount 指令展示出来</span>
&gt; mount -t cgroup 
cpuset on /sys/fs/cgroup/cpuset <span style=color:#658b00>type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
cpu on /sys/fs/cgroup/cpu <span style=color:#658b00>type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpu)
cpuacct on /sys/fs/cgroup/cpuacct <span style=color:#658b00>type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct)
blkio on /sys/fs/cgroup/blkio <span style=color:#658b00>type</span> cgroup (rw,nosuid,nodev,noexec,relatime,blkio)
memory on /sys/fs/cgroup/memory <span style=color:#658b00>type</span> cgroup (rw,nosuid,nodev,noexec,relatime,memory)
...
</code></pre></div><p>可以看到在 <code>/sys/fs/cgroup</code> 下面又很多诸如<code>cpuset</code>、<code>cpu</code>、<code>memory</code>这样的子目,也叫子系统.这些都是可以被<code>Cgroups</code>进行限制的资源种类,而在子系统对应的资源种类下, 你就可以看到该类资源具体可以被限制的方法。比如, 对<code>CPU</code>子系统来说，我们就可以看到几个配置文件，这个指令是：</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; ls /sys/fs/cgroup/cpu
cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us  cpu.shares notify_on_release
cgroup.procs      cpu.cfs_quota_us  cpu.rt_runtime_us cpu.stat  tasks
</code></pre></div><p>输出中<code>cfs_period</code>和<code>cfs_quota</code>这样的关键词。组合使用,限制进程在长度为<code>cfs_period</code>的一段时间内,只能被分配到总量为<code>cfs_quota</code>的<code>CPU</code>时间</p><p>如何使用<code>cgroups</code>呢？</p><p>在对应的子系统的下面创建一个目录，比如限制CPU进入 <code>/sys/fs/cgroups/cpu</code> 目录下</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; <span style=color:#658b00>cd</span> /sys/fs/cgroups/cpu
&gt; mkdir container
&gt; ls container/
cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us cpu.shares notify_on_releasecgroup.procs cpu.cfs_quota_us cpu.rt_runtime_us cpu.stat tasks
</code></pre></div><p>这个目录就称为一个控制组，操作系统自动在新创建的 <code>container</code> 目录下，自动生成该子系统的对应的资源限制文件.</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#228b22># 查看 container 控制组的 CPU quota 还没有任何限制：-1，CPU period 则是默认的 100 ms (100000 us)</span>
&gt; cat /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us 
-1
&gt; cat /sys/fs/cgroup/cpu/container/cpu.cfs_period_us
<span style=color:#b452cd>100000</span>
</code></pre></div><p>向 <code>container</code> 组里的 <code>cfs_quota</code> 文件写入 20 ms（20000 us）</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#228b22>#意味着在每 100 ms 的时间里，被该控制组限制的进程只能使用 20 ms 的 CPU 时间，也就是说这个进程只能使用到 20% 的 CPU 带宽。</span>
&gt; <span style=color:#658b00>echo</span> <span style=color:#b452cd>20000</span> &gt; /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us
<span style=color:#228b22># 现在把需要被限制的进程的 PID 写入 container 组里的 tasks 文件，上面的设置就会对该进程生效了</span>
&gt; <span style=color:#658b00>echo</span> <span style=color:#cd5555>${</span><span style=color:#00688b>需要限制的进程PID</span><span style=color:#cd5555>}</span> &gt; /sys/fs/cgroup/cpu/container/tasks
<span style=color:#228b22># top 指令查看, 计算机CPU使用率立刻降低到20%</span>
&gt; top
%Cpu0 : 20.3 us, 0.0 sy, 0.0 ni, 79.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
</code></pre></div><p>这样, <code>Cgroups</code> 的每一个子系统都有其独有的资源限制能力</p><ul><li><code>cpu</code>, 为进程设定<code>cpu</code>使用的限制;</li><li><code>blkio</code>, 为块设备设定 I/O 限制, 一般用户磁盘等设备;</li><li><code>cpuset</code>, 为进程分配单独的 CPU核和对应的内存节点;</li><li><code>memory</code>, 为进程设定内存使用的限制</li></ul><p><code>Linux Cgroups</code>的设计，它就是<code>一个子系统的目录加上一组资源限制文件的组合</code>。而对于<code>Docker</code>等<code>Linux</code>容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组(即创建一个新目录), 然后在启动进程之后，把这个进程的<code>PID</code>写到对应的控制组的<code>tasks</code>文件中.</p><p>那么在<code>Docker</code>容器中，如何启动的时候知道控制组下面的资源如何使用呢？</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#228b22># docker run 时的参数指定</span>
&gt; docker run -it --cpu-period=<span style=color:#b452cd>100000</span> --cpu-quota=<span style=color:#b452cd>20000</span> ubuntu /bin/bash
</code></pre></div><p>在启动这个容器后，我们可以通过 <code>Cgroups</code> 文件系统下，<code>CPU</code>子系统中, <code>docker</code>这个控制组里的资源限制文件内容来确认：</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_period_us 
<span style=color:#b452cd>100000</span>
&gt; cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_quota_us 
<span style=color:#b452cd>20000</span>
</code></pre></div><p>这就意味着这个<code>Docker</code>容器,只能使用到 <code>20%</code> 的<code>CPU带宽</code></p><p>核心概念：</p><blockquote><p>容器就是一个<code>单进程</code>模型. 一个正在运行的<code>Docker</code>容器,其实就是启用了多个<code>Linux Namespace</code>的应用进程,而这个进程能够使用的资源量,则受<code>Cgroups</code>配置的限制</p></blockquote><p>一个容器的本质是一个进程, 用户的应用进程实际上就是容器的<code>PID=1</code>的进程, 也是其他后续创建所有进程的父进程。这就意味着，在一个容器中，你没有办法同时运行两个不同的应用，除非你能事先找到公共的<code>PID=1</code>的程序充当两个不同应用的父进程，这就是为什么很多会使用<code>systemd</code>或者<code>supervisord</code>代理应用本身作为容器的启动进程。</p><p>容器的本身设计，希望容器和应用能够同生命周期，这个对后续的容器编排非常重要。</p><p><code>Linux</code>下的<code>/proc</code>目录存储的是纪录当前内核运行状态的一些列特殊文件，用户可以通过访问这些文件，查看系统以及当前正在运行的进程的信息, 比如 CPU使用、内存占用，<code>top</code>指令查看系统信息的主要数据来源. 在容器中执行 top 指令, 发现宿主机的CPU和内存的数据，不是当前容器的数据。</p><blockquote><p>造成这个问题的原因就是，<code>/proc</code> 文件系统并不知道用户通过 <code>Cgroups</code> 给这个容器做了什么样的资源限制，即：<code>/proc</code> 文件系统不了解 <code>Cgroups</code> 限制的存在。
当然可以借助其他 <code>lxcfs</code> 可解决此问题</p></blockquote><h1 id=容器镜像>容器镜像</h1><h2 id=容器中的进程看到的文件系统又是什么样子的呢>容器中的进程看到的文件系统又是什么样子的呢？</h2><p>嘿嘿, <code>Mount Namespace</code> 开启后，容器进行看到的文件系统也跟宿主机完全一样。<code>Mount Namespace</code> 修改的，是容器进程对文件系统"挂载点"的认知。<code>Mount Namespace</code> 跟其他的 <code>Namespace</code> 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（<code>mount</code>）才能生效。</p><p>在<code>Linux</code>操作系统中，有一个 <code>chroot</code> 的命令：<code>change root file system</code>， 改变进程的根目录到你指定的位置。这个 <code>Mount Namespace</code> 正是基于对 <code>chroot</code> 的不断改良的，也是 <code>Linux</code> 操作系统里第一个 <code>Namespace</code>。
而挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统，就是所谓的容器镜像。它还有一个更专业的名字叫做 <code>rootfs</code>（根文件系统）</p><p>一个常见的 <code>rootfs</code>，包含一些目录和文件:</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; ls /
bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var
</code></pre></div><p>而进入容器之后执行的 <code>/bin/bash</code>, 就是 <code>/bin</code> 目录下的可执行文件, 与宿主机的 <code>/bin/bash</code> 完全不同。</p><p>对于 <code>Docker</code> 项目来说，它最核心的原理就是为带创建的用户进程：</p><ul><li>启用 <code>Linux Namespace</code> 配置；</li><li>设置指定的 <code>Cgroups</code> 参数；</li><li>切换进程的根目录（<code>Change Root</code>）.</li></ul><p>这样，一个完整的容器就诞生了。不过，在<code>Docker</code>项目在最后一步的切换上优先使用<code>pivot_root</code>系统调用,如果系统不支持，才会使用<code>chroot</code>。</p><p><code>rootfs</code>只是操作系统所包含的文件、配置和目录，并不包含操作系统内核。在<code>Linux</code>操作系统中，这两部分分开存放的。操作系统只在开机启动的时候才会加载指定版本的内核镜像。
所以说<code>rootfs</code>只是操作系统的"躯壳"，并没有操作系统的"灵魂"，同一台机器的所有容器，都共享宿主机操作系统的内核。因为共享的宿主机内核，应用程序需要配置的内核参数、加载额外的内核模块，以及跟内核进行的直接交互。内核相对于主机上所有容器的是一个全局变量，牵一发而动全身。</p><p>由于<code>rootfs</code>的存在,容器有了最重要的特性: 一致性</p><h2 id=什么是容器的一致性呢>什么是容器的一致性呢？</h2><p>在开发过程中、本地环境、云环境、打包是一个十分痛苦的过程（对于<code>PAAS</code>环境来说），有了容器镜像（<code>rootfs</code>）之后，优雅的解决了这个问题。</p><blockquote><p>由于 <code>rootfs</code> 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着应用以及它运行的所需要的所有依赖，都被封装在一起。</p></blockquote><blockquote><p>对于一个应用来说，操作系统本身才是它运行所需要的完整的"依赖库"，有了容器镜像打包操作系统的能力，这个最基础的依赖环境也终于变成了应用沙盒的一部分。这就赋予了容器的一致性：无论在本地、云端，还是在任何地方的机器上，用户只需要解压打包好的容器镜像，这样这个应用所需要的完整的执行环境就被重现出来了。</p></blockquote><h2 id=如何解决每次升级如何解决重复制作-rootfs-的问题呢>如何解决每次升级，如何解决重复制作 <code>rootfs</code> 的问题呢？</h2><p><code>Docker</code>公司实现<code>Docker</code>镜像的时候没有使用重制作<code>rootfs</code>流程，而是在<code>Docker</code>在镜像的设计中，引入了层（<code>layer</code>）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量的<code>rootfs</code>.</p><p>联合文件系统(<code>Union File System</code>) <code>UnionFS</code>, 最主要的功能是将不同位置的目录联合挂载（<code>union mount</code>）到同一个目录下。</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; tree
.
|- A
| |- a
| |- x
|--- B
  |-- b
  |-- x

<span style=color:#228b22># 联合挂载，两个目录挂载到公共目录C上</span>
&gt; mkdir C
&gt; mount -t aufs -o <span style=color:#00688b>dirs</span>=./A:./B none ./C

<span style=color:#228b22># 展示C文件</span>
&gt; tree ./C
./C
|-- a
|-- b
|-- x
<span style=color:#228b22># 此时对 C 里的文件进行修改，在目录 A 和 B 中都会生效</span>
</code></pre></div><h2 id=docker-layer概念><code>docker</code> <code>layer</code>概念</h2><p>关键目录:</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/var/lib/docker/aufs/diff/&lt;layer_id&gt;
</code></pre></div><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#228b22># 拉取ubuntu镜像</span>
&gt; docker pull ubuntu:latest
<span style=color:#228b22># 展示image的层</span>
&gt; docker image inspect ubuntu:latest
...
     <span style=color:#cd5555>&#34;RootFS&#34;</span>: {
      <span style=color:#cd5555>&#34;Type&#34;</span>: <span style=color:#cd5555>&#34;layers&#34;</span>,
      <span style=color:#cd5555>&#34;Layers&#34;</span>: [
        <span style=color:#cd5555>&#34;sha256:f49017d4d5ce9c0f544c...&#34;</span>,
        <span style=color:#cd5555>&#34;sha256:8f2b771487e9d6354080...&#34;</span>,
        <span style=color:#cd5555>&#34;sha256:ccd4d61916aaa2159429...&#34;</span>,
        <span style=color:#cd5555>&#34;sha256:c01d74f99de40e097c73...&#34;</span>,
        <span style=color:#cd5555>&#34;sha256:268a067217b5fe78e000...&#34;</span>
      ]
    }
</code></pre></div><p><code>ubuntu</code>镜像的是五层组成，这五层就是5个增量 <code>rootfs</code>,每一层都是 <code>ubuntu</code> 操作系统文件与目录的一部分; 而在使用镜像时, <code>Docker</code> 会把这些增量的联合挂载在一个统一的挂载点上。挂载点就是 <code>/var/lib/docker/aufs/mnt/</code>,比如:</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fcfa2a2f5c89dc21ee30e166be823ceaeba15dce645b3e
</code></pre></div><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#228b22># 这个目录下是一个完整的 ubuntu 操作系统</span>
&gt; ls /var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fcfa2a2f5c89dc21ee30e166be823ceaeba15dce645b3e
bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
</code></pre></div><p>前面的五个镜像层，如何被挂载到这样一个完整的<code>Ubuntu</code>的文件系统的呢？这个信息纪录在 <code>AuFS</code> 的系统目录 <code>/sys/fs/aufs</code> 下面。查看 <code>AuFS</code> 的挂载信息, 我们可以找到这个目录对应的 <code>AuFS</code> 的内部ID（也叫<code>si</code>），</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#228b22># si=972c6d361e6b32ba</span>
&gt; cat /proc/mounts| grep aufs
none /var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fc... aufs rw,relatime,si=972c6d361e6b32ba,dio,dirperm1 <span style=color:#b452cd>0</span> <span style=color:#b452cd>0</span>

<span style=color:#228b22># 查看被联合挂载在一起的各个层的信息</span>
&gt; cat /sys/fs/aufs/si_972c6d361e6b32ba/br[0-9]*
/var/lib/docker/aufs/diff/6e3be5d2ecccae7cc...=rw
/var/lib/docker/aufs/diff/6e3be5d2ecccae7cc...-init=ro+wh
/var/lib/docker/aufs/diff/32e8e20064858c0f2...=ro+wh
/var/lib/docker/aufs/diff/2b8858809bce62e62...=ro+wh
/var/lib/docker/aufs/diff/20707dce8efc0d267...=ro+wh
/var/lib/docker/aufs/diff/72b0744e06247c7d0...=ro+wh
/var/lib/docker/aufs/diff/a524a729adadedb90...=ro+wh

<span style=color:#228b22># 镜像的层都放置在 `/var/lib/docker/aufs/diff` 目录下，然后被联合挂载在 `/var/lib/docker/aufs/mnt` 里面  </span>
</code></pre></div><p><img src=/%E5%9B%9E%E6%9C%9BK8S/ubuntu-layer.png alt=容器的rootfs的展示></p><ul><li>第一部分: 只读层<blockquote><p>它是这个容器 <code>rootfs</code> 最下面的 5 层, 对应的正是 <code>ubuntu</code> 镜像的五层.他们的挂载方式都是只读的（ro+wh readonly+whiteout）</p></blockquote></li><li>第二部分: 可读写层<blockquote><p>它是这个容器的 <code>rootfs</code> 最上面的一层（6e3be5d2ecccae7cc），它的挂载方式为：<code>rw</code> （read write）, 在这个容器中进行修改产生的内容就会以增量的方式出现在这一层。
假如删除只读层的一个文件呢？这时候 <code>AuFS</code> 在可读写层创建了一个 <code>whiteout</code> 文件，把只读层里的文件 遮挡 起来了。对上层来说，这个文件就是不可见的。
这边可读写层的作用就是存放我们自己修改后的 <code>rootfs</code> 后产生的增量，无论增删改都在此处处理，增量的 <code>rootfs</code></p></blockquote></li><li>第三部分: <code>Init</code> 层<blockquote><p>它是以"-init"结尾的层，夹在只读层和读写层之间, <code>Init</code> 层是<code>Docker</code>项目单独生成的内部层，专门用来存放 <code>/etc/hosts</code>、<code>/etc/resolv.conf</code> 等信息，这些文件本来属于只读的<code>Ubuntu</code>镜像一部分，但用户往往需要在启动的时候写入一定指定的值 <code>hostname</code>，用户可以在可读写层对他们进行修改。</p><p>可是我们修改往往只对当前容器生效，我们并不希望执行 <code>docker commit</code> 时，把这些信息连同可读写层一起提交掉。所以<code>Docker</code>的做法，时修改的这些文件以后，以一个单独的层挂载出来，而用户执行的 <code>docker commit</code> 只会提交可读写层，所以不会包含这些内容。</p><p>最终这 7 层都被联合挂载到 <code>/var/lib/docker/aufs/mnt</code> 目录下</p></blockquote></li></ul><h1 id=docker容器><code>Docker</code>容器</h1><h2 id=docker-如何实现容器的>docker 如何实现容器的</h2><ul><li><code>Linux Namespace</code> 隔离能力</li><li><code>Linux Cgroups</code> 限制能力</li><li>基于 <code>rootfs</code> 文件系统的增量实现</li></ul><h2 id=开发的应用的如何容器化的步骤>开发的应用的如何容器化的步骤</h2><h3 id=1dockerfile-制作容器镜像>1、<code>Dockerfile</code> 制作容器镜像</h3><p>制作<code>rootfs</code>过程，<code>Docker</code>提供了一个便捷的方式: <code>Dockerfile</code></p><p>举例个写个 <code>app.py</code>, 使用 <code>Flask</code> 启动一个<code>Web</code>服务器。</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#8b008b;font-weight:700>from</span> <span style=color:#008b45;text-decoration:underline>flask</span> <span style=color:#8b008b;font-weight:700>import</span> Flask
<span style=color:#8b008b;font-weight:700>import</span> <span style=color:#008b45;text-decoration:underline>socket</span>
<span style=color:#8b008b;font-weight:700>import</span> <span style=color:#008b45;text-decoration:underline>os</span>

app = Flask(__name__)

<span style=color:#707a7c>@app.route</span>(<span style=color:#cd5555>&#39;/&#39;</span>)
<span style=color:#8b008b;font-weight:700>def</span> <span style=color:#008b45>hello</span>():
    html = <span style=color:#cd5555>&#34;&lt;h3&gt;Hello {name}!&lt;/h3&gt;&#34;</span> \
           <span style=color:#cd5555>&#34;&lt;b&gt;Hostname:&lt;/b&gt; {hostname}&lt;br/&gt;&#34;</span>           
    <span style=color:#8b008b;font-weight:700>return</span> html.format(name=os.getenv(<span style=color:#cd5555>&#34;NAME&#34;</span>, <span style=color:#cd5555>&#34;world&#34;</span>), hostname=socket.gethostname())
    
<span style=color:#8b008b;font-weight:700>if</span> __name__ == <span style=color:#cd5555>&#34;__main__&#34;</span>:
    app.run(host=<span style=color:#cd5555>&#39;0.0.0.0&#39;</span>, port=<span style=color:#b452cd>80</span>)
</code></pre></div><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#228b22># 展示 Python 依赖的关系</span>
&gt; cat requirements.txt
Flask
</code></pre></div><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#228b22># 使用官方 python镜像</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>FROM</span><span style=color:#cd5555> python</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#228b22># 切换工作目录</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>WORKDIR</span><span style=color:#cd5555> /app</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#228b22># 将当前目录下内容复制到 /app</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>ADD</span> . /app<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#228b22># 按照应用依赖</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>RUN</span> pip install -r requirements.txt<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#228b22># 允许外界访问容器80端口</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>EXPOSE</span><span style=color:#cd5555> 80</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#228b22># 设置环境变量</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>ENV</span> NAME helloworld<span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#228b22># 启动python应用</span><span style=color:#a61717;background-color:#e3d2d2>
</span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#8b008b;font-weight:700>CMD</span> [<span style=color:#cd5555>&#34;python&#34;</span>,<span style=color:#cd5555>&#34;app.py&#34;</span>]<span style=color:#a61717;background-color:#e3d2d2>
</span></code></pre></div><p>有了 Dockerfile 可以进行 Docker 镜像的制作</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#228b22># 使用dockerfile打一个 名为 helloworld 的镜像</span>
&gt; docker build -t helloword .
<span style=color:#228b22># 展示docker</span>
&gt; docker image ls
REPOSITORY            TAG                 IMAGE ID
helloworld         latest              654286cdf963
<span style=color:#228b22># 启动一个容器 8080 映射 80</span>
&gt; docker run -p 8080:80 helloword
<span style=color:#228b22># docker push</span>
<span style=color:#228b22># docker tag</span>
&gt; docker inspect --format <span style=color:#cd5555>&#39;{{ .State.Pid }}&#39;</span> 4ddf4638572d
<span style=color:#b452cd>25686</span>
<span style=color:#228b22># 可以看到，一个进程的每种 Linux Namespace，都在它对应的 /proc/[进程号]/ns 下有一个对应的虚拟文件，并且链接到一个真实的 Namespace 文件上。</span>
&gt; ls -l /proc/25686/ns
total <span style=color:#b452cd>0</span>
lrwxrwxrwx <span style=color:#b452cd>1</span> root root <span style=color:#b452cd>0</span> Aug <span style=color:#b452cd>13</span> 14:05 cgroup -&gt; cgroup:[4026531835]
lrwxrwxrwx <span style=color:#b452cd>1</span> root root <span style=color:#b452cd>0</span> Aug <span style=color:#b452cd>13</span> 14:05 ipc -&gt; ipc:[4026532278]
lrwxrwxrwx <span style=color:#b452cd>1</span> root root <span style=color:#b452cd>0</span> Aug <span style=color:#b452cd>13</span> 14:05 mnt -&gt; mnt:[4026532276]
lrwxrwxrwx <span style=color:#b452cd>1</span> root root <span style=color:#b452cd>0</span> Aug <span style=color:#b452cd>13</span> 14:05 net -&gt; net:[4026532281]
lrwxrwxrwx <span style=color:#b452cd>1</span> root root <span style=color:#b452cd>0</span> Aug <span style=color:#b452cd>13</span> 14:05 pid -&gt; pid:[4026532279]
lrwxrwxrwx <span style=color:#b452cd>1</span> root root <span style=color:#b452cd>0</span> Aug <span style=color:#b452cd>13</span> 14:05 pid_for_children -&gt; pid:[4026532279]
lrwxrwxrwx <span style=color:#b452cd>1</span> root root <span style=color:#b452cd>0</span> Aug <span style=color:#b452cd>13</span> 14:05 user -&gt; user:[4026531837]
lrwxrwxrwx <span style=color:#b452cd>1</span> root root <span style=color:#b452cd>0</span> Aug <span style=color:#b452cd>13</span> 14:05 uts -&gt; uts:[4026532277]
</code></pre></div><p>这也就意味着：一个进程，可以选择加入到某个进程已有的 <code>Namespace</code> 当中，从而达到“进入”这个进程所在容器的目的，这正是 <code>docker exec</code> 的实现原理。</p><h3 id=2volume-机制允许将宿主机上的指定的目录或者文件挂载到容器里面进行读取和修改>2、<code>Volume</code> 机制，允许将宿主机上的指定的目录或者文件挂载到容器里面进行读取和修改</h3><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; docker run -v /test ...
&gt; docker run -v /home:/test ...
</code></pre></div><p>只不过，在第一种情况下，由于你并没有显示声明宿主机目录，那么 <code>Docker</code> 就会默认在宿主机上创建一个临时目录 <code>/var/lib/docker/volumes/[VOLUME_ID]/_data</code>，然后把它挂载到容器的 <code>/test</code> 目录上。而在第二种情况下，<code>Docker</code> 就直接把宿主机的 <code>/home</code> 目录挂载到容器的 <code>/test</code> 目录上。</p><p>当容器进程被创建之后，尽管开启了 <code>Mount Namespace</code>，但是在它执行 <code>chroot</code>（或者 <code>pivot_root</code>）之前，容器进程一直可以看到宿主机上的整个文件系统。</p><p>而宿主机上的文件系统，也自然包括了我们要使用的容器镜像。这个镜像的各个层，保存在 <code>/var/lib/docker/aufs/diff</code> 目录下，在容器进程启动后，它们会被联合挂载在 <code>/var/lib/docker/aufs/mnt/</code> 目录中，这样容器所需的 <code>rootfs</code> 就准备好了。</p><p>所以，我们只需要在 <code>rootfs</code> 准备好之后，在执行 <code>chroot</code> 之前，把 <code>Volume</code> 指定的宿主机目录（比如 <code>/home</code> 目录），挂载到指定的容器目录（比如 <code>/test</code> 目录）在宿主机上对应的目录（即 <code>/var/lib/docker/aufs/mnt/[可读写层 ID]/test</code>）上，这个 <code>Volume</code> 的挂载工作就完成了。</p><p>更重要的是，由于执行这个挂载操作时，“容器进程”已经创建了，也就意味着此时 <code>Mount Namespace</code> 已经开启了。所以，这个挂载事件只在这个容器里可见。你在宿主机上，是看不见容器内部的这个挂载点的。这就保证了容器的隔离性不会被 <code>Volume</code> 打破。</p><p>而这里要使用到的挂载技术，就是 <code>Linux</code> 的绑定挂载（<code>bind mount</code>）机制。它的主要作用就是，允许你将一个目录或者文件，而不是整个设备，挂载到一个指定的目录上。并且，这时你在该挂载点上进行的任何操作，只是发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响。</p><p><img src=/%E5%9B%9E%E6%9C%9BK8S/python-app-image.jpg alt=应用的镜像></p><h1 id=kubernetes-本质><code>Kubernetes</code> 本质</h1><h2 id=回顾>回顾</h2><p>一个容器：<code>Linux Namespace</code>、<code>Linux Cgroups</code>、 <code>rootfs</code> 三种技术构建的进程隔离环境。</p><p>一个正在允许的 <code>Linux</code> 的容器:</p><ul><li>一组联合挂载在 <code>/var/lib/docker/aufs/mnt</code> 上的 <code>rootfs</code>, 容器的静态视图（容器镜像）</li><li>一个有 <code>Namespace</code> + <code>Cgroups</code> 构成的隔离环境，容器的动态视图（容器运行时）</li></ul><h2 id=总结>总结</h2><p>在整个开发流程中 &ldquo;开发 - 测试 - 发布&rdquo;，真正承载容器信息传递的是<code>容器镜像</code>！然而云计算商想要与全部用户关联起来，那么只有通过<code>容器镜像</code>。
容器只是开发者手里的小工具，但是想从容器进入容器云的方式，就需要 <code>容器编排</code> 技术.</p><h2 id=容器编排技术><code>容器编排</code>技术</h2><p>大战之后，Kubernetes 应运而生</p><h3 id=kubernetes-顶层设计>Kubernetes 顶层设计</h3><ul><li>编排、调度、容器云、集群管理</li><li>路由网关、水平扩展、监控、备份、灾难恢复</li></ul><p><img src=/%E5%9B%9E%E6%9C%9BK8S/kubernetes-%E6%9E%B6%E6%9E%84.png alt=kubernetes架构></p><p>Kubernetes 是由 Master 和 Node 两种节点，控制节点 与 计算节点</p><ul><li>控制节点（三个组件）<ul><li>kube-apiserver 负责API服务</li><li>kube-scheduler 负责调度</li><li>kube-controller-manager 负责容器编排</li></ul></li><li>计算节点<ul><li>核心 kubelet 负责和容器运行时（比如docker）交互<ul><li>交互的时候的依赖接口 CRI （Container Runtime Interface）的远程调用接口</li><li>通过 gRPC 协议 与 Device Plugin 进行交互</li><li>调用网络插件为容器配置网络 CNI （Container Networking Interface）</li><li>调用存储插件为容器配置持久化存储 CSI （Container Storage Interface）</li></ul></li></ul></li><li>etcd 整个集群的持久化数据，由 kube-apiserver 处理后保存在 Etcd 中</li></ul><p>从一开始，Kubernetes 就没有衣服到 Docker 项目上，没有将它作为架构的核心，只是将它作为了最底层的容器运行时的实现</p><p>Kubernetes 项目最主要的设计思想：从宏观的角度、以统一的方式定义任务之间的各种关系，为将来支持更多种类的关系留有余地</p><blockquote><p>例如：
Kubernetes 在访问关系上的操作</p><p>Pod 是 Kubernetes 的最基础的对象。
Service 是 Kubernetes 提供的访问关系的服务对象</p><p>我现在两个应用各自为POD，现在要做到A应用访问B应用，在使用时候，对于容器需要 IP 地址信息不变等等。
Kubernetes的做法是 Pod 绑定一个 Service 服务，而 Service 服务声明的 IP 地址等信息是不变的，这个Service服务主要作用就是作为 Pod 的代理入口，从而替代Pod对外暴露一个固定的网络地址。
这样对于调用方只需要关系 Service 声明信息，而Service后端真正代理的Pod 的IP地址、端口等信息的自动更新、维护是 Kubernetes的职责。</p></blockquote><p><img src=/%E5%9B%9E%E6%9C%9BK8S/kubernetes-%E5%85%A8%E6%99%AF%E5%9B%BE.png alt=kubernetes全景图></p><ul><li>Pod</li><li>Service 描述访问关系</li><li>Secret 密钥</li><li>Job 描述一次性运行的POD</li><li>DaemonSet 描述每个宿主机必须且只能运行一个副本的守护进程服务</li><li>CronJob 描述定时任务</li></ul><blockquote><p>如何编排一个K8S项目</p><ul><li>通过编排对象, 比如 Pod、Job、CronJob 等，来描述试图管理的应用；</li><li>定义服务对象, 比如 Service、Secret、Horizontal Pod Autoscaler等，会负责具体的平台级功能</li></ul></blockquote><p><code>声明式 API</code> 对应的 <code>编排对象</code> 和 <code>服务对象</code>，都是 Kubernetes 项目中的 API 对象（API Object）</p><hr width=100% id=EOF><p style=color:#777>最后修改于 2020-02-15</p></div></div><nav class=post-pagination><a class=newer-posts href=https://pinkhello.me/posts/19-%E5%9B%9E%E6%9C%9Bk8s-kubernetes%E6%8B%BC%E5%9B%BE/>下回<br>回望K8S Kubernetes拼图</a>
<a class=older-posts href=https://pinkhello.me/posts/17-%E5%9B%9E%E6%9C%9Bk8s-%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/>上回<br>回望K8S 小鲸鱼容器技术</a></nav><div class=post-comment-wrapper><div id=gitalk-container></div></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
PinkHello, All Rights Reserved</div></div><script>let app;app=new Vue({el:'#app',data:{scrollY:0,navOpacity:0,isDrawerOpen:!1,mounted:!1,isDarkMode:!1},methods:{sgn(a,b){let c=1/(1-2*a);return b<=a?0:b>=1-a?1:c*(b-a)},handleScroll(){this.scrollY=window.scrollY,this.navOpacity=this.sgn(0,Math.min(1,Math.max(0,window.scrollY/(this.pageHeadHeight()-this.navBarHeight()*.8))));const{navBar:c,navBackground:a,navTitle:b,extraContainer:d,streamContainer:e}=this.$refs;this.navOpacity>=1?(a.style.opacity=1,b.style.opacity=1):(a.style.opacity=0,b.style.opacity=0)},handleResize(){const{navBar:c,navBackground:d,navTitle:e,extraContainer:a,streamContainer:b}=this.$refs;a.style.left=b.offsetWidth-a.offsetWidth+'px'},navBarHeight(){return this.$refs.navBar.offsetHeight},pageHeadHeight(){return this.$refs.pageHead.offsetHeight},toggleDrawer(){this.isDrawerOpen=!this.isDrawerOpen,document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset'},closeDrawer(){this.isDrawerOpen=!1,document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset'},toggleDarkMode(){this.isDarkMode=!this.isDarkMode,this.isDarkMode==!0?(document.cookie="night=1;path=/",document.body.classList.add("night")):(document.cookie="night=0;path=/",document.body.classList.remove("night"))}},created(){window.addEventListener('scroll',this.handleScroll),window.addEventListener('resize',this.handleResize),window._nonDesktop=function(){let a=!1;return function(b){(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(b)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(b.substr(0,4)))&&(a=!0)}(navigator.userAgent||navigator.vendor||window.opera),a};var a=document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/,"$1");a==""?window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches&&this.toggleDarkMode():a=="1"&&this.toggleDarkMode()},mounted(){this.handleScroll(),this.handleResize(),this.mounted=!0},destroyed(){window.removeEventListener('scroll',this.handleScroll),window.removeEventListener('resize',this.handleResize)}})</script><script src=https://pinkhello.me//js/journal.js></script></body></html>