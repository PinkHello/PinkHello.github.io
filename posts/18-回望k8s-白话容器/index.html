<!doctype html><html><head><title>18 回望K8S 白话容器</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><meta property="og:title" content="18 回望K8S 白话容器"><meta property="og:description" content="进程开启 容器, 到底是什么?
 前面提出: 容器是一种沙盒技术. 就是一个集装箱, 把应用装起来的技术. 这样, 应用与应用之间有了边界不至于互相干扰; 有了这些集装箱, 也方便搬来搬去.
 码农都知道可执行的二进制文件是代码的可执行镜像(executable image). 一旦程序执行起来, 内存数据、寄存器的值、堆栈的指令、打开的文件等这些集合汇集成一个程序的计算机执行环境总和: 进程.
进程: 静态表现是程序, 动态表现计算机的数据和状态的总和。
容器的核心功能, 就是通过约束和修改进程的动态表现, 从而为其创造一个&#34;边界&#34;.
 Cgroups 技术 制造约束的主要手段 Namespace 技术 修改进程视图的主要方法  docker run , -it 告诉 Docker 启动容器后, 需要分配一个文本输入/输出环境, 也就是 TTY, 跟容器的标准输入相关联, 这样我们就可以和这个Docker容器进行交互了。而 /bin/sh 就是我们在 Docker 容器里运行的程序.
> docker run -it busybox /bin/sh / # 帮我启动一个容器, 在容器里执行 /bin/sh, 并且给我分配一个命令行终端跟这个容器进行交互, 在这个执行环境下可以完全执行LINUX命令,且与宿主机完全隔离在不同的世界中.
Docker对被隔离应用的进程空间做了手脚, 使得这些进程只能看到重新计算的进程编号, 可是实际上, 他们在宿主机的操作系统里, 还是原来的第N号进程. 这种技术就是Linux内部的Namespace机制。
Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 clone()，比如："><meta property="og:type" content="article"><meta property="og:url" content="https://pinkhello.github.io/posts/18-%E5%9B%9E%E6%9C%9Bk8s-%E7%99%BD%E8%AF%9D%E5%AE%B9%E5%99%A8/"><meta property="article:published_time" content="2021-02-15T10:16:34+08:00"><meta property="article:modified_time" content="2021-02-15T10:16:34+08:00"><meta property="og:site_name" content="一杯哈希不加盐"><meta name=twitter:card content="summary"><meta name=twitter:title content="18 回望K8S 白话容器"><meta name=twitter:description content="进程开启 容器, 到底是什么?
 前面提出: 容器是一种沙盒技术. 就是一个集装箱, 把应用装起来的技术. 这样, 应用与应用之间有了边界不至于互相干扰; 有了这些集装箱, 也方便搬来搬去.
 码农都知道可执行的二进制文件是代码的可执行镜像(executable image). 一旦程序执行起来, 内存数据、寄存器的值、堆栈的指令、打开的文件等这些集合汇集成一个程序的计算机执行环境总和: 进程.
进程: 静态表现是程序, 动态表现计算机的数据和状态的总和。
容器的核心功能, 就是通过约束和修改进程的动态表现, 从而为其创造一个&#34;边界&#34;.
 Cgroups 技术 制造约束的主要手段 Namespace 技术 修改进程视图的主要方法  docker run , -it 告诉 Docker 启动容器后, 需要分配一个文本输入/输出环境, 也就是 TTY, 跟容器的标准输入相关联, 这样我们就可以和这个Docker容器进行交互了。而 /bin/sh 就是我们在 Docker 容器里运行的程序.
> docker run -it busybox /bin/sh / # 帮我启动一个容器, 在容器里执行 /bin/sh, 并且给我分配一个命令行终端跟这个容器进行交互, 在这个执行环境下可以完全执行LINUX命令,且与宿主机完全隔离在不同的世界中.
Docker对被隔离应用的进程空间做了手脚, 使得这些进程只能看到重新计算的进程编号, 可是实际上, 他们在宿主机的操作系统里, 还是原来的第N号进程. 这种技术就是Linux内部的Namespace机制。
Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 clone()，比如："><script src=/vendor/js/jquery.min.js></script><script src=/vendor/js/popper.min.js></script><script src=/vendor/js/bootstrap.min.js></script><script src=/vendor/js/smooth-scroll.polyfills.min.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script><link rel=stylesheet href=https://pinkhello.github.io/scss/journal.min.c116bc90d171283f099f173854157ec8f183f9073b93443b2c8ad82899ee9025.css integrity="sha256-wRa8kNFxKD8Jnxc4VBV+yPGD+Qc7k0Q7LIrYKJnukCU=" media=screen><link rel=stylesheet href=https://pinkhello.github.io/scss/dark-mode.min.552aae4638a84aa57cf0b195750a49ea9131d3bb621d1ed3ebc9b14b18166536.css integrity="sha256-VSquRjioSqV88LGVdQpJ6pEx07tiHR7T68mxSxgWZTY=" media=screen><script src=https://pinkhello.github.io//js/loadCSS.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");</script><script src=https://pinkhello.github.io//js/toc-collapse.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script src=/vendor/js/md5.min.js></script><script>var gitalk=new Gitalk({clientID:'419eb00d100865eb61e7',clientSecret:'f171ccc842eab6f06942e6a943a62546fc95b411',repo:'PinkHello.github.io',owner:'PinkHello',admin:['PinkHello'],id:md5(location.pathname),distractionFreeMode:'false',proxy:'https:\/\/netnr-proxy.cloudno.de\/https:\/\/github.com\/login\/oauth\/access_token'});window.onload=function(){gitalk.render('gitalk-container')}</script></head><body><div id=app><div ref=sideContainer class=side-container><a class="a-block nav-head false" href=https://pinkhello.github.io/><div class=nav-title>一杯哈希不加盐</div><div class=nav-subtitle>做一个快乐的程序猿</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>Archive</a>
<a class="a-block nav-link-item false" href=/categories>Categories</a>
<a class="a-block nav-link-item false" href=/tags>Tags</a>
<a class="a-block nav-link-item false" href=/about>About</a>
<a class="a-block nav-link-item false" href=/links>Links</a>
<a class="a-block nav-link-item false" href=/index.xml>RSS Feed</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
一杯哈希不加盐, All Rights Reserved</div></div><div ref=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- 目录 -</center><ul><li><a href=#%e8%bf%9b%e7%a8%8b%e5%bc%80%e5%90%af onclick="onNavClick(`#进程开启-nav`)" id=进程开启-nav>进程开启</a></li><li><a href=#%e9%9a%94%e7%a6%bb%e5%92%8c%e9%99%90%e5%88%b6 onclick="onNavClick(`#隔离和限制-nav`)" id=隔离和限制-nav>隔离和限制</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f onclick="onNavClick(`#容器镜像-nav`)" id=容器镜像-nav>容器镜像</a></li><li><a href=#docker%e5%ae%b9%e5%99%a8 onclick="onNavClick(`#docker容器-nav`)" id=docker容器-nav>Docker容器</a></li><li><a href=#kubernetes-%e6%9c%ac%e8%b4%a8 onclick="onNavClick(`#kubernetes-本质-nav`)" id=kubernetes-本质-nav>Kubernetes 本质</a></li></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a class=pagination-action v-on:click=toggleDarkMode><i class="material-icons pagination-action-icon" v-if=isDarkMode>brightness_4</i>
<i class="material-icons pagination-action-icon" v-else=isDarkMode>brightness_7</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>Archive</a>
<a class="a-block drawer-menu-item false" href=/categories>Categories</a>
<a class="a-block drawer-menu-item false" href=/tags>Tags</a>
<a class="a-block drawer-menu-item false" href=/about>About</a>
<a class="a-block drawer-menu-item false" href=/links>Links</a>
<a class="a-block drawer-menu-item false" href=/index.xml>RSS Feed</a><div class=toc><div class=toc-content><center>- 目录 -</center><ul><li><a href=#%e8%bf%9b%e7%a8%8b%e5%bc%80%e5%90%af onclick="onNavClick(`#进程开启-nav`)" id=进程开启-nav>进程开启</a></li><li><a href=#%e9%9a%94%e7%a6%bb%e5%92%8c%e9%99%90%e5%88%b6 onclick="onNavClick(`#隔离和限制-nav`)" id=隔离和限制-nav>隔离和限制</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f onclick="onNavClick(`#容器镜像-nav`)" id=容器镜像-nav>容器镜像</a></li><li><a href=#docker%e5%ae%b9%e5%99%a8 onclick="onNavClick(`#docker容器-nav`)" id=docker容器-nav>Docker容器</a></li><li><a href=#kubernetes-%e6%9c%ac%e8%b4%a8 onclick="onNavClick(`#kubernetes-本质-nav`)" id=kubernetes-本质-nav>Kubernetes 本质</a></li></ul></div></div></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=https://pinkhello.github.io/>一杯哈希不加盐</a>
<button type=button class=nav-darkmode-toggle v-on:click=toggleDarkMode>
<i class=material-icons v-if=isDarkMode>brightness_4</i>
<i class=material-icons v-else=isDarkMode>brightness_7</i></button></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://pinkhello.github.io/><div class=single-column-header-title>一杯哈希不加盐</div><div class=single-column-header-subtitle>做一个快乐的程序猿</div></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>18 回望K8S 白话容器<div class=post-meta><time itemprop=datePublished>2021-02-15 10:16</time>
<i class=material-icons>folder</i>
<a href=/categories/k8s>k8s</a>
&nbsp;
<i class=material-icons>label</i>
<a href=/tags/k8s>k8s</a>
&nbsp;
<a href=/tags/%E5%AE%B9%E5%99%A8>容器</a>
&nbsp;
<i class=material-icons>schedule</i>
14 min
10 s.</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h1 id=进程开启>进程开启</h1><p>容器, 到底是什么?</p><blockquote><p>前面提出: 容器是一种沙盒技术. 就是一个集装箱, 把应用装起来的技术. 这样, 应用与应用之间有了边界不至于互相干扰; 有了这些集装箱, 也方便搬来搬去.</p></blockquote><p>码农都知道可执行的二进制文件是代码的可执行镜像(executable image). 一旦程序执行起来, 内存数据、寄存器的值、堆栈的指令、打开的文件等这些集合汇集成一个程序的计算机执行环境总和: 进程.</p><p><code>进程</code>: 静态表现是程序, 动态表现计算机的数据和状态的总和。</p><p>容器的核心功能, 就是通过约束和修改进程的动态表现, 从而为其创造一个"边界".</p><ul><li><code>Cgroups 技术</code> 制造约束的主要手段</li><li><code>Namespace 技术</code> 修改进程视图的主要方法</li></ul><p><code>docker run</code> , <code>-it</code> 告诉 <code>Docker</code> 启动容器后, 需要分配一个文本输入/输出环境, 也就是 <code>TTY</code>, 跟容器的标准输入相关联, 这样我们就可以和这个<code>Docker</code>容器进行交互了。而 <code>/bin/sh</code> 就是我们在 <code>Docker</code> 容器里运行的程序.</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; docker run -it busybox /bin/sh
/ <span style=color:#228b22>#</span>
</code></pre></div><p>帮我启动一个容器, 在容器里执行 <code>/bin/sh</code>, 并且给我分配一个命令行终端跟这个容器进行交互, 在这个执行环境下可以完全执行<code>LINUX</code>命令,且与宿主机完全隔离在不同的世界中.</p><p><code>Docker</code>对被隔离应用的进程空间做了手脚, 使得这些进程只能看到重新计算的进程编号, 可是实际上, 他们在宿主机的操作系统里, 还是原来的第<code>N</code>号进程. 这种技术就是<code>Linux</code>内部的<code>Namespace</code>机制。</p><p><code>Namespace</code> 的使用方式也非常有意思：它其实只是 <code>Linux</code> 创建新进程的一个可选参数。我们知道，在 <code>Linux</code> 系统中创建线程的系统调用是 <code>clone()</code>，比如：</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>int <span style=color:#00688b>pid</span> = clone(main_function, stack_size, SIGCHLD, NULL);
</code></pre></div><p>这个系统调用就会创建一个新的进程，并且返回的它的进程号 pid。</p><p>当调用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，比如：</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>int <span style=color:#00688b>pid</span> = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);
</code></pre></div><p>这时，新创建的这个进程就会看到一个全新的进程空间，在这个进程空间里，他的<code>PID</code>是<code>1</code>，之所以说看到，是因为是一个障眼法，在宿主机真实的进程空间里，这个<code>PID</code>还是真实的数值.当多次执行<code>clone()</code>调用, 会创建多个 <code>PID Namespace</code>, 每个 Namespace 里的应用进程，都会认为自己是当前容器里的第<code>1</code>号进程，看不仅<code>宿主机</code>的也看不到其他的<code>Namespace</code>.</p><blockquote><p>备注:
Linux提供了不同的Namespace，去应对不同的进程上下文</p><ul><li>PID Namespace</li><li>Mount Namespace</li><li>IPC Namespace</li><li>UTS Namespace</li><li>Network Namespace</li><li>User Namespace</li></ul></blockquote><p>Docker容器，就是在创建容器进程时候，指定了这个进程所需要启用的一组 Namespace 参数, 这样, 容器就只能 看到 当前 Namespace 所限定的 资源、文件、设备、状态 或者 配置。所以说, 容器，其实是一种特殊的进程。</p><p><img src=/%E5%9B%9E%E6%9C%9BK8S/%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg alt=容器与虚拟机工作原理></p><p>可以看出图中 <code>Hypervisor</code> 是虚拟机主要部分。它通过硬件虚拟化功能，模拟出了运行一个操作系统需要的各种硬件，比如 CPU、内存、I/O设备等。 这样，用户的进程可以在这个虚拟的机器中，只能看到虚拟环境的文件和目录以及设备，起到隔离的作用。
而右边的图，<code>Docker Engine</code>替换了<code>Hypervisor</code>,但是有个核心一点<code>Docker Engine</code>并不少<code>轻量级</code>虚拟化技术。</p><p>在<code>Linux</code>的<code>Namespace</code>工作方式后, 在使用<code>Docker</code>的时候,<code>Docker</code>并没有一个真正的<code>Docker容器</code>运行在宿主机里面，而是<code>Docker</code>启动还是原来的应用进程，只不过在创建这些进程时候，加上了各种<code>Namespace</code>参数，使得这些进程觉得自己是在各自的<code>PID Namespace</code>是第一号进程，并且只能看到各自<code>Mount Namespace</code>里挂在的目录和文件、只能访问各自<code>Network Namespace</code>里的网络设备.</p><h1 id=隔离和限制>隔离和限制</h1><p>前面提到实现 <code>隔离</code> 的手段: Namespace. Namespace 技术实际修改了应用进程看待整个计算机的"视图"，即它的"视线"被操作系统做了限制，只能"看到"某些知道的内容.</p><p>为什么需要<code>隔离</code></p><ul><li>首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。</li><li>在Linux内核中，还有许多资源和对象是不能被 Namespace 化的，最典型的例子是：时间<blockquote><p>容器中使用 settimeofday(2) 系统调用修改了时间，整个宿主机的时间都会被随之修改。这样肯定与预期不符</p></blockquote></li></ul><p>上述是为什么要<code>隔离</code>，下面说为什么要<code>限制</code>这个问题。</p><blockquote><p>在宿主机上,启动多个容器都是在宿主机上的特殊进程,但是在不同的进程之间, 资源（CPU、内存）还是可能被其他进程（或者容器）占用的。</p></blockquote><p><code>Linux Cgroups</code>全称<code>Linux Control Group</code> 就是 Linux 内核中用来为进程设置资源限制的一个重要功能, 限制一个进程组能够使用的资源上限, 包括 CPU、内存、磁盘、网络带宽 等等。此外 Cgroups 还能够对进程进行优先级设置、审计，以及将进程挂起和恢复操作。</p><p>在<code>Linux</code>中,<code>Cgroups</code>给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 <code>/sys/fs/cgroup</code> 路径下</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#228b22># Ubuntu 下 mount 指令展示出来</span>
&gt; mount -t cgroup 
cpuset on /sys/fs/cgroup/cpuset <span style=color:#658b00>type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
cpu on /sys/fs/cgroup/cpu <span style=color:#658b00>type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpu)
cpuacct on /sys/fs/cgroup/cpuacct <span style=color:#658b00>type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct)
blkio on /sys/fs/cgroup/blkio <span style=color:#658b00>type</span> cgroup (rw,nosuid,nodev,noexec,relatime,blkio)
memory on /sys/fs/cgroup/memory <span style=color:#658b00>type</span> cgroup (rw,nosuid,nodev,noexec,relatime,memory)
...
</code></pre></div><p>可以看到在 <code>/sys/fs/cgroup</code> 下面又很多诸如<code>cpuset</code>、<code>cpu</code>、<code>memory</code>这样的子目,也叫子系统.这些都是可以被<code>Cgroups</code>进行限制的资源种类,而在子系统对应的资源种类下, 你就可以看到该类资源具体可以被限制的方法。比如, 对<code>CPU</code>子系统来说，我们就可以看到几个配置文件，这个指令是：</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; ls /sys/fs/cgroup/cpu
cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us  cpu.shares notify_on_release
cgroup.procs      cpu.cfs_quota_us  cpu.rt_runtime_us cpu.stat  tasks
</code></pre></div><p>输出中<code>cfs_period</code>和<code>cfs_quota</code>这样的关键词。组合使用,限制进程在长度为<code>cfs_period</code>的一段时间内,只能被分配到总量为<code>cfs_quota</code>的<code>CPU</code>时间</p><p>如何使用cgroups呢？</p><p>在对应的子系统的下面创建一个目录，比如限制CPU进入 /sys/fs/cgroups/cpu 目录下</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; <span style=color:#658b00>cd</span> /sys/fs/cgroups/cpu
&gt; mkdir container
&gt; ls container/
cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us cpu.shares notify_on_releasecgroup.procs cpu.cfs_quota_us cpu.rt_runtime_us cpu.stat tasks
</code></pre></div><p>这个目录就称为一个控制组，操作系统自动在新创建的 container 目录下，自动生成该子系统的对应的资源限制文件.</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#228b22># 查看 container 控制组的 CPU quota 还没有任何限制：-1，CPU period 则是默认的 100 ms (100000 us)</span>
&gt; cat /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us 
-1
&gt; cat /sys/fs/cgroup/cpu/container/cpu.cfs_period_us
<span style=color:#b452cd>100000</span>
</code></pre></div><p>向 container 组里的 cfs_quota 文件写入 20 ms（20000 us）</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#228b22>#意味着在每 100 ms 的时间里，被该控制组限制的进程只能使用 20 ms 的 CPU 时间，也就是说这个进程只能使用到 20% 的 CPU 带宽。</span>
&gt; <span style=color:#658b00>echo</span> <span style=color:#b452cd>20000</span> &gt; /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us
<span style=color:#228b22># 现在把需要被限制的进程的 PID 写入 container 组里的 tasks 文件，上面的设置就会对该进程生效了</span>
&gt; <span style=color:#658b00>echo</span> <span style=color:#cd5555>${</span><span style=color:#00688b>需要限制的进程PID</span><span style=color:#cd5555>}</span> &gt; /sys/fs/cgroup/cpu/container/tasks
<span style=color:#228b22># top 指令查看, 计算机CPU使用率立刻降低到20%</span>
&gt; top
%Cpu0 : 20.3 us, 0.0 sy, 0.0 ni, 79.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
</code></pre></div><p>这样, <code>Cgroups</code> 的每一个子系统都有其独有的资源限制能力</p><ul><li><code>cpu</code>, 为进程设定<code>cpu</code>使用的限制;</li><li><code>blkio</code>, 为块设备设定 I/O 限制, 一般用户磁盘等设备;</li><li><code>cpuset</code>, 为进程分配单独的 CPU核和对应的内存节点;</li><li><code>memory</code>, 为进程设定内存使用的限制</li></ul><p><code>Linux Cgroups</code>的设计，它就是<code>一个子系统的目录加上一组资源限制文件的组合</code>。而对于<code>Docker</code>等<code>Linux</code>容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组(即创建一个新目录), 然后在启动进程之后，把这个进程的<code>PID</code>写到对应的控制组的<code>tasks</code>文件中.</p><p>那么在Docker容器中，如何启动的时候知道控制组下面的资源如何使用呢？</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#228b22># docker run 时的参数指定</span>
&gt; docker run -it --cpu-period=<span style=color:#b452cd>100000</span> --cpu-quota=<span style=color:#b452cd>20000</span> ubuntu /bin/bash
</code></pre></div><p>在启动这个容器后，我们可以通过 <code>Cgroups</code> 文件系统下，<code>CPU</code>子系统中, <code>docker</code>这个控制组里的资源限制文件内容来确认：</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_period_us 
<span style=color:#b452cd>100000</span>
&gt; cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_quota_us 
<span style=color:#b452cd>20000</span>
</code></pre></div><p>这就意味着这个<code>Docker</code>容器,只能使用到 <code>20%</code> 的<code>CPU带宽</code></p><p>核心概念：</p><blockquote><p>容器就是一个<code>单进程</code>模型. 一个正在运行的<code>Docker</code>容器,其实就是启用了多个<code>Linux Namespace</code>的应用进程,而这个进程能够使用的资源量,则受<code>Cgroups</code>配置的限制</p></blockquote><p>一个容器的本质是一个进程, 用户的应用进程实际上就是容器的<code>PID=1</code>的进程, 也是其他后续创建所有进程的父进程。这就意味着，在一个容器中，你没有办法同时运行两个不同的应用，除非你能事先找到公共的<code>PID=1</code>的程序充当两个不同应用的父进程，这就是为什么很多会使用<code>systemd</code>或者<code>supervisord</code>代理应用本身作为容器的启动进程。</p><h1 id=容器镜像>容器镜像</h1><h1 id=docker容器><code>Docker</code>容器</h1><h1 id=kubernetes-本质><code>Kubernetes</code> 本质</h1><hr width=100% id=EOF><p style=color:#777>最后修改于 2021-02-15</p></div></div><nav class=post-pagination><a class=newer-posts>下回<br>已经到头啦。</a>
<a class=older-posts href=https://pinkhello.github.io/posts/17-%E5%9B%9E%E6%9C%9Bk8s-%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/>上回<br>17 回望K8S 小鲸鱼容器技术</a></nav><div class=post-comment-wrapper><div id=gitalk-container></div></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
一杯哈希不加盐, All Rights Reserved</div></div><script>let app;app=new Vue({el:'#app',data:{scrollY:0,navOpacity:0,isDrawerOpen:false,mounted:false,isDarkMode:false},methods:{sgn(t,x){let k=1./(1.-2*t);if(x<=t)return 0;else if(x>=1-t)return 1;else{return k*(x-t);}},handleScroll(){this.scrollY=window.scrollY;this.navOpacity=this.sgn(.0,Math.min(1,Math.max(0,window.scrollY/(this.pageHeadHeight()-this.navBarHeight()*0.8))));const{navBar,navBackground,navTitle,extraContainer,streamContainer}=this.$refs;if(this.navOpacity>=1){navBackground.style.opacity=1;navTitle.style.opacity=1;}else{navBackground.style.opacity=0;navTitle.style.opacity=0;}},handleResize(){const{navBar,navBackground,navTitle,extraContainer,streamContainer}=this.$refs;extraContainer.style.left=(streamContainer.offsetWidth-extraContainer.offsetWidth)+'px';},navBarHeight(){return this.$refs.navBar.offsetHeight;},pageHeadHeight(){return this.$refs.pageHead.offsetHeight;},toggleDrawer(){this.isDrawerOpen=!this.isDrawerOpen;document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset';},closeDrawer(){this.isDrawerOpen=false;document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset';},toggleDarkMode(){this.isDarkMode=!this.isDarkMode;if(this.isDarkMode==true){document.cookie="night=1;path=/";document.body.classList.add("night");}else{document.cookie="night=0;path=/";document.body.classList.remove("night");}}},created(){window.addEventListener('scroll',this.handleScroll);window.addEventListener('resize',this.handleResize);window._nonDesktop=function(){let check=false;(function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check=true;})(navigator.userAgent||navigator.vendor||window.opera);return check;};var night=document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/,"$1");if(night==""){if(window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches){}}else{if(night=="1"){this.toggleDarkMode();}}},mounted(){this.handleScroll();this.handleResize();this.mounted=true;},destroyed(){window.removeEventListener('scroll',this.handleScroll);window.removeEventListener('resize',this.handleResize);}});</script><script src=https://pinkhello.github.io//js/journal.js></script></body></html>